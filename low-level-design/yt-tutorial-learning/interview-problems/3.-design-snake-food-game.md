# 3. Design Snake Food Game

## Design Snake & Food Game

### Overview

The Snake & Food game is a classic arcade game where the player controls a snake moving on a grid, attempting to eat food items while avoiding collisions. The game requires strategic movement to maximize the snake's growth without running into walls or itself.

### Game Rules

#### Setup

* The game is played on an N × N grid
* The snake starts at an initial position with a small length
* The player controls movement using directional inputs (Up, Down, Left, Right)

#### Game Mechanics

* The snake moves one step at a time in the chosen direction
* When the snake eats a food item, it grows in length
* A new food item spawns at a predetermined position after consumption
* The game continues until collision occurs

#### Game Over Conditions

* Snake collides with the boundary of the grid
* Snake collides with itself (its own body)

### System Requirements

#### Core Features

* Grid-based game board with configurable width × height
* Single player snake control
* Food placement and consumption mechanics
* Collision detection (self-collision and wall collision)
* Snake movement and growth mechanics
* Score tracking system
* Predefined food positions

#### Key Requirements

1. **Game Grid**: Specific width and height dimensions
2. **Snake Entity**: Player-controlled with body segments
3. **Food Objects**: Appear at predefined positions
4. **Movement System**: Updates game state with each move
5. **Collision System**: Detects walls and self-collision
6. **Scoring**: Based on food consumption

### Complete System Architecture

#### Overall Class Diagram

```
                    ┌──────────────────────┐
                    │   SnakeGameMain      │
                    ├──────────────────────┤
                    │ +main(String[])      │
                    │ +convertInput()      │
                    │ +displayGameState()  │
                    └──────────┬───────────┘
                               │ creates and uses
                               │
                    ┌──────────▼───────────┐
                    │    SnakeGame         │
                    ├──────────────────────┤
                    │ -board: GameBoard    │
                    │ -snake: Deque<Pair>  │
                    │ -snakeMap: Map       │
                    │ -food: int[][]       │
                    │ -foodIndex: int      │
                    │ -strategy: Movement  │
                    ├──────────────────────┤
                    │ +SnakeGame(...)      │
                    │ +setMovementStrategy()│
                    │ +move(String)        │
                    └────┬──────────┬──────┘
                         │          │
              ┌──────────┘          └─────────┐
              │ uses                        uses│
              ▼                                 ▼
    ┌─────────────────┐              ┌──────────────────┐
    │   GameBoard     │              │ MovementStrategy │
    │  <<Singleton>>  │              │  <<interface>>   │
    ├─────────────────┤              ├──────────────────┤
    │ -instance       │              │ +getNextPosition │
    │ -width: int     │              │  (Pair, String)  │
    │ -height: int    │              └────────┬─────────┘
    ├─────────────────┤                       │
    │ +getInstance()  │              ┌────────┴────────┐
    │ +getWidth()     │              │                 │
    │ +getHeight()    │              ▼                 ▼
    └─────────────────┘    ┌──────────────┐  ┌──────────────┐
                           │   Human      │  │     AI       │
                           │  Movement    │  │  Movement    │
                           │  Strategy    │  │  Strategy    │
                           └──────────────┘  └──────────────┘


                    ┌──────────────────────┐
                    │    FoodFactory       │
                    │  <<Factory Pattern>> │
                    ├──────────────────────┤
                    │ +createFood(...)     │
                    └──────────┬───────────┘
                               │ creates
                               │
                    ┌──────────▼───────────┐
                    │     FoodItem         │
                    │    <<abstract>>      │
                    ├──────────────────────┤
                    │ #row: int            │
                    │ #column: int         │
                    │ #points: int         │
                    ├──────────────────────┤
                    │ +getRow()            │
                    │ +getColumn()         │
                    │ +getPoints()         │
                    └────┬──────────┬──────┘
                         │          │
              ┌──────────┘          └─────────┐
              ▼                                ▼
    ┌─────────────────┐              ┌─────────────────┐
    │   NormalFood    │              │   BonusFood     │
    ├─────────────────┤              ├─────────────────┤
    │ points = 1      │              │ points = 3      │
    └─────────────────┘              └─────────────────┘
```

### Design Patterns Used

#### 1. Strategy Pattern (Movement)

This pattern allows different movement behaviors to be plugged into the game dynamically.

```
                    ┌────────────────────────────────────┐
                    │      MovementStrategy              │
                    │       <<interface>>                │
                    ├────────────────────────────────────┤
                    │ +getNextPosition(                  │
                    │     Pair<Integer,Integer> current, │
                    │     String direction)              │
                    │   : Pair<Integer,Integer>          │
                    └──────────────┬─────────────────────┘
                                   │
                                   │ implements
                    ┌──────────────┴──────────────┐
                    │                             │
                    ▼                             ▼
    ┌───────────────────────────┐    ┌───────────────────────────┐
    │  HumanMovementStrategy    │    │   AIMovementStrategy      │
    ├───────────────────────────┤    ├───────────────────────────┤
    │ +getNextPosition(...)     │    │ +getNextPosition(...)     │
    │                           │    │                           │
    │ Direction Logic:          │    │ AI Pathfinding Logic:     │
    │  "U" → (row-1, col)       │    │  - Avoid obstacles        │
    │  "D" → (row+1, col)       │    │  - Find shortest path     │
    │  "L" → (row, col-1)       │    │  - Seek food location     │
    │  "R" → (row, col+1)       │    │  - Self-preservation      │
    └───────────────────────────┘    └───────────────────────────┘
```

**Implementation:**

```java
// Movement strategy interface
interface MovementStrategy {
    Pair getNextPosition(Pair currentHead, String direction);
}

// Human player movement strategy
class HumanMovementStrategy implements MovementStrategy {
    @Override
    public Pair getNextPosition(Pair currentHead, String direction) {
        int row = currentHead.getRow();
        int col = currentHead.getCol();
        
        switch (direction) {
            case "U": return new Pair(row - 1, col);  // Up
            case "D": return new Pair(row + 1, col);  // Down
            case "L": return new Pair(row, col - 1);  // Left
            case "R": return new Pair(row, col + 1);  // Right
            default: return currentHead;
        }
    }
}

// AI movement strategy
class AIMovementStrategy implements MovementStrategy {
    @Override
    public Pair getNextPosition(Pair currentHead, String direction) {
        // AI logic for pathfinding and obstacle avoidance
        // Could implement A* algorithm or simple heuristics
        // Placeholder implementation
        return currentHead;
    }
}
```

#### 2. Factory Pattern (Food Creation)

Enables dynamic creation of different food types without modifying existing code.

```
                    ┌────────────────────────────────┐
                    │        FoodFactory             │
                    │     <<Factory Pattern>>        │
                    ├────────────────────────────────┤
                    │ +createFood(int[] position,    │
                    │             String type)       │
                    │   : FoodItem                   │
                    └──────────────┬─────────────────┘
                                   │
                                   │ creates
                                   │
                    ┌──────────────▼─────────────────┐
                    │         FoodItem               │
                    │        <<abstract>>            │
                    ├────────────────────────────────┤
                    │ #row: int                      │
                    │ #column: int                   │
                    │ #points: int                   │
                    ├────────────────────────────────┤
                    │ +FoodItem(row, column)         │
                    │ +getRow(): int                 │
                    │ +getColumn(): int              │
                    │ +getPoints(): int              │
                    └────────────┬───────────────────┘
                                 │
                    ┌────────────┴────────────┐
                    │                         │
                    ▼                         ▼
        ┌──────────────────────┐  ┌──────────────────────┐
        │    NormalFood        │  │     BonusFood        │
        ├──────────────────────┤  ├──────────────────────┤
        │ +NormalFood(row,col) │  │ +BonusFood(row,col)  │
        │  points = 1          │  │  points = 3          │
        └──────────────────────┘  └──────────────────────┘
```

**Implementation:**

```java
// Abstract food item class
abstract class FoodItem {
    protected int row, column;
    protected int points;
    
    public FoodItem(int row, int column) {
        this.row = row;
        this.column = column;
    }
    
    public int getRow() { return row; }
    public int getColumn() { return column; }
    public int getPoints() { return points; }
}

// Normal food - 1 point
class NormalFood extends FoodItem {
    public NormalFood(int row, int column) {
        super(row, column);
        this.points = 1;
    }
}

// Bonus food - 3 points
class BonusFood extends FoodItem {
    public BonusFood(int row, int column) {
        super(row, column);
        this.points = 3;
    }
}

// Factory for creating food items
class FoodFactory {
    public static FoodItem createFood(int[] position, String type) {
        if ("bonus".equals(type)) {
            return new BonusFood(position[0], position[1]);
        }
        return new NormalFood(position[0], position[1]);
    }
}
```

#### 3. Singleton Pattern (Game Board)

Ensures only one instance of the game board exists throughout the game.

```
        ┌─────────────────────────────────────────┐
        │            GameBoard                    │
        │          <<Singleton>>                  │
        ├─────────────────────────────────────────┤
        │ -instance: GameBoard <<static>>         │
        │ -width: int                             │
        │ -height: int                            │
        ├─────────────────────────────────────────┤
        │ -GameBoard(int width, int height)       │
        │ +getInstance(width, height): GameBoard  │
        │ +getWidth(): int                        │
        │ +getHeight(): int                       │
        └─────────────────────────────────────────┘
                         │
                         │
                Single Instance ─┐
                Shared Globally  │
                                 ▼
                    ┌────────────────────┐
                    │  Only One Board    │
                    │  Exists At A Time  │
                    └────────────────────┘
```

**Implementation:**

```java
public class GameBoard {
    private static GameBoard instance;
    private int width;
    private int height;
    
    // Private constructor prevents direct instantiation
    private GameBoard(int width, int height) {
        this.width = width;
        this.height = height;
    }
    
    // Get singleton instance
    public static GameBoard getInstance(int width, int height) {
        if (instance == null) {
            instance = new GameBoard(width, height);
        }
        return instance;
    }
    
    public int getWidth() { return width; }
    public int getHeight() { return height; }
}
```

#### 4. Observer Pattern (Game Events)

Notifies observers about game events such as moves, food consumption, and game over.

```
        ┌────────────────────────────────────┐
        │         GameObserver               │
        │         <<interface>>              │
        ├────────────────────────────────────┤
        │ +onMoveMade(Pair newHeadPosition)  │
        │ +onFoodEaten(int foodIndex,        │
        │              int newScore)         │
        │ +onGameOver(int finalScore)        │
        └──────────────┬─────────────────────┘
                       │
                       │ implements
                       │
        ┌──────────────▼─────────────────────┐
        │     ConsoleGameObserver            │
        ├────────────────────────────────────┤
        │ +onMoveMade(Pair position)         │
        │ +onFoodEaten(int idx, int score)   │
        │ +onGameOver(int score)             │
        └────────────────────────────────────┘
                       ▲
                       │ notifies
                       │
        ┌──────────────┴─────────────────────┐
        │          SnakeGame                 │
        ├────────────────────────────────────┤
        │ -observers: List<GameObserver>     │
        ├────────────────────────────────────┤
        │ +addObserver(GameObserver)         │
        │ -notifyMoveMade(Pair)              │
        │ -notifyFoodEaten(int, int)         │
        │ -notifyGameOver(int)               │
        └────────────────────────────────────┘
```

**Implementation:**

```java
// Observer interface
public interface GameObserver {
    void onMoveMade(Pair newHeadPosition);
    void onFoodEaten(int foodIndex, int newScore);
    void onGameOver(int finalScore);
}

// Concrete observer implementation
public class ConsoleGameObserver implements GameObserver {
    @Override
    public void onMoveMade(Pair newHeadPosition) {
        System.out.println("Snake moved to position: [" + 
            newHeadPosition.getRow() + ", " + 
            newHeadPosition.getCol() + "]");
    }
    
    @Override
    public void onFoodEaten(int foodIndex, int newScore) {
        System.out.println("Food eaten! Current score: " + newScore);
    }
    
    @Override
    public void onGameOver(int finalScore) {
        System.out.println("Game Over! Final score: " + finalScore);
    }
}
```

### Core Implementation

#### Pair Class (Coordinate System)

```java
public class Pair {
    private int row;
    private int col;
    
    public Pair(int row, int col) {
        this.row = row;
        this.col = col;
    }
    
    public int getRow() { return row; }
    public int getCol() { return col; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Pair pair = (Pair) o;
        return row == pair.row && col == pair.col;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(row, col);
    }
}
```

#### Snake Game Controller

```java
public class SnakeGame {
    private GameBoard board;
    private Deque<Pair> snake;
    private Map<Pair, Boolean> snakeMap;
    private int[][] food;
    private int foodIndex;
    private MovementStrategy movementStrategy;
    private List<GameObserver> observers;
    
    // Initialize the game
    public SnakeGame(int width, int height, int[][] food) {
        this.board = GameBoard.getInstance(width, height);
        this.food = food;
        this.foodIndex = 0;
        
        // Initialize snake at [0,0]
        this.snake = new LinkedList<>();
        this.snakeMap = new HashMap<>();
        Pair initialPos = new Pair(0, 0);
        this.snake.offerFirst(initialPos);
        this.snakeMap.put(initialPos, true);
        
        // Set default movement strategy
        this.movementStrategy = new HumanMovementStrategy();
        
        // Initialize observers list
        this.observers = new ArrayList<>();
    }
    
    // Set movement strategy
    public void setMovementStrategy(MovementStrategy strategy) {
        this.movementStrategy = strategy;
    }
    
    // Add observer
    public void addObserver(GameObserver observer) {
        observers.add(observer);
    }
    
    // Notify observers of move
    private void notifyMoveMade(Pair newHead) {
        for (GameObserver observer : observers) {
            observer.onMoveMade(newHead);
        }
    }
    
    // Notify observers of food eaten
    private void notifyFoodEaten(int foodIndex, int newScore) {
        for (GameObserver observer : observers) {
            observer.onFoodEaten(foodIndex, newScore);
        }
    }
    
    // Notify observers of game over
    private void notifyGameOver(int finalScore) {
        for (GameObserver observer : observers) {
            observer.onGameOver(finalScore);
        }
    }
    
    // Process a move - returns score or -1 if game over
    public int move(String direction) {
        // Get current head
        Pair currentHead = this.snake.peekFirst();
        
        // Get next position using strategy pattern
        Pair newHead = this.movementStrategy.getNextPosition(currentHead, direction);
        int newHeadRow = newHead.getRow();
        int newHeadCol = newHead.getCol();
        
        // Check boundary conditions
        boolean crossesBoundary = newHeadRow < 0 || 
                                 newHeadRow >= this.board.getHeight() ||
                                 newHeadCol < 0 || 
                                 newHeadCol >= this.board.getWidth();
        
        // Get current tail for collision check
        Pair currentTail = this.snake.peekLast();
        
        // Check if snake bites itself (excluding tail which will move away)
        boolean bitesItself = this.snakeMap.containsKey(newHead) &&
                             !(newHead.getRow() == currentTail.getRow() &&
                               newHead.getCol() == currentTail.getCol());
        
        // Game over conditions
        if (crossesBoundary || bitesItself) {
            notifyGameOver(this.snake.size() - 1);
            return -1;
        }
        
        // Check if snake eats food
        boolean ateFood = (this.foodIndex < this.food.length) &&
                         (this.food[this.foodIndex][0] == newHeadRow) &&
                         (this.food[this.foodIndex][1] == newHeadCol);
        
        if (ateFood) {
            // Increment food index
            this.foodIndex++;
            int newScore = this.snake.size();
            notifyFoodEaten(this.foodIndex - 1, newScore);
        } else {
            // Remove tail if no food eaten
            this.snake.pollLast();
            this.snakeMap.remove(currentTail);
        }
        
        // Add new head
        this.snake.addFirst(newHead);
        this.snakeMap.put(newHead, true);
        
        // Notify observers
        notifyMoveMade(newHead);
        
        // Calculate and return score
        int score = this.snake.size() - 1;
        return score;
    }
}
```

### Game Flow

#### Movement Process

```
                    Start Move
                        │
                        ▼
            Get Current Head Position
                        │
                        ▼
            Calculate Next Position
            (Using Movement Strategy)
                        │
                        ▼
            ┌───────────────────────┐
            │   Collision Check     │
            └───────────┬───────────┘
                        │
            ┌───────────┴───────────┐
            │                       │
            ▼                       ▼
      Wall Collision?      Self Collision?
            │                       │
            └───────────┬───────────┘
                        │
                 Yes ───┴─── No
                  │           │
                  ▼           ▼
            Game Over    Check Food
                              │
                    ┌─────────┴─────────┐
                    │                   │
                    ▼                   ▼
              Food Hit?             No Food
                    │                   │
                    ▼                   ▼
              Grow Snake          Move Snake
              (Keep Tail)      (Remove Tail)
                    │                   │
                    └─────────┬─────────┘
                              │
                              ▼
                      Add New Head
                              │
                              ▼
                      Update Score
                              │
                              ▼
                   Notify Observers
                              │
                              ▼
                      Return Score
```

### Complete Example

#### Main Application

```java
public class SnakeGameMain {
    public static void main(String[] args) {
        // Define game configuration
        int width = 20;
        int height = 15;
        
        // Define food positions
        int[][] foodPositions = {
            {5, 5},   // First food
            {10, 8},  // Second food
            {3, 12},  // Third food
            {8, 17},  // Fourth food
            {12, 3}   // Fifth food
        };
        
        // Initialize the game
        SnakeGame game = new SnakeGame(width, height, foodPositions);
        
        // Add observer for game events
        game.addObserver(new ConsoleGameObserver());
        
        // Display game instructions
        System.out.println("===== SNAKE GAME =====");
        System.out.println("Controls: W (Up), S (Down), A (Left), D (Right), Q (Quit)");
        System.out.println("Eat food to grow your snake and increase your score.");
        System.out.println("Don't hit the walls or bite yourself!");
        System.out.println("=======================");
        
        // Create scanner for user input
        Scanner scanner = new Scanner(System.in);
        boolean gameRunning = true;
        int score = 0;
        
        // Main game loop
        while (gameRunning) {
            // Display current game state
            displayGameState(game);
            
            // Get user input
            System.out.print("Enter move (W/A/S/D) or Q to quit: ");
            String input = scanner.nextLine().toUpperCase();
            
            // Handle quit command
            if (input.equals("Q")) {
                System.out.println("Game ended by player. Final score: " + score);
                gameRunning = false;
                continue;
            }
            
            // Convert WASD input to UDLR for game processing
            String direction = convertInput(input);
            
            // Skip invalid inputs
            if (direction.isEmpty()) {
                System.out.println("Invalid input! Use W/A/S/D to move or Q to quit.");
                continue;
            }
            
            // Make the move and get the new score
            score = game.move(direction);
            
            // Check for game over
            if (score == -1) {
                System.out.println("GAME OVER! You hit a wall or bit yourself.");
                gameRunning = false;
            } else {
                System.out.println("Score: " + score);
            }
        }
        
        scanner.close();
        System.out.println("Thanks for playing!");
    }
    
    // Convert user-friendly WASD input to UDLR for the game engine
    private static String convertInput(String input) {
        switch (input) {
            case "W": return "U";  // Up
            case "S": return "D";  // Down
            case "A": return "L";  // Left
            case "D": return "R";  // Right
            default: return "";    // Invalid input
        }
    }
    
    // Display the game state in the console
    private static void displayGameState(SnakeGame game) {
        System.out.println("\nCurrent snake length: " + game.snake.size());
        // In a real implementation, you would render the board with
        // the snake, food, and boundaries visually
    }
}
```

### Advanced Features

#### 1. Extensible Board Size

The Singleton GameBoard implementation supports variable grid dimensions.

```
        ┌──────────────────────────────────────┐
        │        SnakeGameMain                 │
        ├──────────────────────────────────────┤
        │ +void createGameWithDifferentSizes() │
        │   - Small: 8×8 (mobile)              │
        │   - Medium: 20×15 (desktop)          │
        │   - Large: 40×30 (advanced)          │
        └──────────────┬───────────────────────┘
                       │
                       │ creates with
                       │ different sizes
                       │
        ┌──────────────▼───────────────────────┐
        │          SnakeGame                   │
        ├──────────────────────────────────────┤
        │ -board: GameBoard                    │
        │                                      │
        │ Example Usage:                       │
        │  new SnakeGame(8, 8, food)          │
        │  new SnakeGame(20, 15, food)        │
        │  new SnakeGame(40, 30, food)        │
        └──────────────┬───────────────────────┘
                       │ uses
                       │
        ┌──────────────▼───────────────────────┐
        │          GameBoard                   │
        │         <<Singleton>>                │
        ├──────────────────────────────────────┤
        │ +getInstance(width, height)          │
        │  Adapts to different dimensions      │
        └──────────────────────────────────────┘
```

**Implementation:**

```java
public class SnakeGameMain {
    public static void main(String[] args) {
        // Create a small 8x8 board for mobile
        SnakeGame smallGame = new SnakeGame(8, 8, foodPositions);
        
        // Create a larger 20x15 board for desktop
        SnakeGame largeGame = new SnakeGame(20, 15, foodPositions);
        
        // Board size is flexible and configurable
    }
}
```

#### 2. Observer Pattern for Game Event Tracking

Extended observer implementation with the SnakeGame controller.

```
        ┌────────────────────────────────────────┐
        │           SnakeGame                    │
        ├────────────────────────────────────────┤
        │ -observers: List<GameObserver>         │
        ├────────────────────────────────────────┤
        │ +addObserver(GameObserver)             │
        │ +void addObserver(observer)            │
        │ -void notifyMoveMade(Pair)             │
        │ -void notifyFoodEaten(int, int)        │
        │ -void notifyGameOver(int)              │
        └──────────────┬─────────────────────────┘
                       │
                       │ notifies
                       │
        ┌──────────────▼─────────────────────────┐
        │      GameObserver Interface            │
        ├────────────────────────────────────────┤
        │ +onMoveMade(Pair newHeadPosition)      │
        │ +onFoodEaten(int foodIndex, int score) │
        │ +onGameOver(int finalScore)            │
        └──────────────┬─────────────────────────┘
                       │
                       │ implements
                       │
        ┌──────────────▼─────────────────────────┐
        │     ConsoleGameObserver                │
        ├────────────────────────────────────────┤
        │ +onMoveMade(...)                       │
        │   → Logs position to console           │
        │ +onFoodEaten(...)                      │
        │   → Displays score update              │
        │ +onGameOver(...)                       │
        │   → Shows final score                  │
        └────────────────────────────────────────┘
```

**Observer Pattern Implementation in SnakeGame:**

```java
class SnakeGame {
    private List<GameObserver> observers;
    
    public SnakeGame(int width, int height, int[][] food) {
        // ... existing initialization ...
        this.observers = new ArrayList<>();
    }
    
    public void addObserver(GameObserver observer) {
        observers.add(observer);
    }
    
    private void notifyMoveMade(Pair newHead) {
        for (GameObserver observer : observers) {
            observer.onMoveMade(newHead);
        }
    }
    
    private void notifyFoodEaten(int foodIndex, int newScore) {
        for (GameObserver observer : observers) {
            observer.onFoodEaten(foodIndex, newScore);
        }
    }
    
    private void notifyGameOver(int finalScore) {
        for (GameObserver observer : observers) {
            observer.onGameOver(finalScore);
        }
    }
    
    public int move(String direction) {
        // ... movement logic ...
        
        // Notify observers at appropriate points
        if (crossesBoundary || bitesItself) {
            notifyGameOver(this.snake.size() - 1);
            return -1;
        }
        
        if (ateFood) {
            notifyFoodEaten(this.foodIndex - 1, newScore);
        }
        
        notifyMoveMade(newHead);
        return score;
    }
}
```

#### 3. No Walls Mode (Infinite Board)

In this mode, the snake wraps around the edges instead of hitting walls.

```
        ┌──────────────────────────────────────┐
        │        SnakeGameMain                 │
        ├──────────────────────────────────────┤
        │ +void main(String[] args)            │
        │   → Creates game with:               │
        │      hasWalls = false                │
        └──────────────┬───────────────────────┘
                       │ creates with
                       │ hasWalls=false
                       │
        ┌──────────────▼───────────────────────┐
        │          SnakeGame                   │
        ├──────────────────────────────────────┤
        │ -boolean hasWalls                    │
        ├──────────────────────────────────────┤
        │ +SnakeGame(w, h, food, hasWalls)     │
        │ -Pair wrapPosition(row, col)         │
        │ +int move(String direction)          │
        │                                      │
        │ Modified move() logic:               │
        │  1. Edge wrapping when hasWalls=false│
        │  2. Collision only on self-hit       │
        └──────────────┬───────────────────────┘
                       │ uses
                       │
        ┌──────────────▼───────────────────────┐
        │          GameBoard                   │
        ├──────────────────────────────────────┤
        │ Width and Height define wrap points  │
        │  - Top edge wraps to bottom          │
        │  - Bottom edge wraps to top          │
        │  - Left edge wraps to right          │
        │  - Right edge wraps to left          │
        └──────────────────────────────────────┘
```

**Implementation:**

```java
class SnakeGame {
    private boolean hasWalls;
    
    // Constructor with walls parameter
    public SnakeGame(int width, int height, int[][] food, boolean hasWalls) {
        this.board = GameBoard.getInstance(width, height);
        this.food = food;
        this.foodIndex = 0;
        this.hasWalls = hasWalls;
        
        // Initialize snake
        this.snake = new LinkedList<>();
        this.snakeMap = new HashMap<>();
        Pair initialPos = new Pair(0, 0);
        this.snake.offerFirst(initialPos);
        this.snakeMap.put(initialPos, true);
        
        this.movementStrategy = new HumanMovementStrategy();
        this.observers = new ArrayList<>();
    }
    
    // Constructor with default walls setting (has walls)
    public SnakeGame(int width, int height, int[][] food) {
        this(width, height, food, true);
    }
    
    // Wrap position around board edges (for no-walls mode)
    private Pair wrapPosition(int row, int col) {
        int height = this.board.getHeight();
        int width = this.board.getWidth();
        
        // Wrap around height
        if (row < 0) {
            row = height - 1;
        } else if (row >= height) {
            row = 0;
        }
        
        // Wrap around width
        if (col < 0) {
            col = width - 1;
        } else if (col >= width) {
            col = 0;
        }
        
        return new Pair(row, col);
    }
    
    public int move(String direction) {
        Pair currentHead = this.snake.peekFirst();
        Pair newHead = this.movementStrategy.getNextPosition(currentHead, direction);
        int newHeadRow = newHead.getRow();
        int newHeadCol = newHead.getCol();
        
        // Check boundary conditions if walls are enabled
        boolean crossesBoundary = false;
        if (hasWalls) {
            // Traditional boundary checking with walls
            crossesBoundary = newHeadRow < 0 || 
                             newHeadRow >= this.board.getHeight() ||
                             newHeadCol < 0 || 
                             newHeadCol >= this.board.getWidth();
        } else {
            // No walls - wrap around the edges
            newHead = wrapPosition(newHeadRow, newHeadCol);
            newHeadRow = newHead.getRow();
            newHeadCol = newHead.getCol();
        }
        
        Pair currentTail = this.snake.peekLast();
        
        // Check if snake bites itself
        boolean bitesItself = this.snakeMap.containsKey(newHead) &&
                             !(newHead.getRow() == currentTail.getRow() &&
                               newHead.getCol() == currentTail.getCol());
        
        // Game over conditions
        if (crossesBoundary || bitesItself) {
            notifyGameOver(this.snake.size() - 1);
            return -1;
        }
        
        // Rest of the movement logic remains the same
        boolean ateFood = (this.foodIndex < this.food.length) &&
                         (this.food[this.foodIndex][0] == newHeadRow) &&
                         (this.food[this.foodIndex][1] == newHeadCol);
        
        if (ateFood) {
            this.foodIndex++;
            int newScore = this.snake.size();
            notifyFoodEaten(this.foodIndex - 1, newScore);
        } else {
            this.snake.pollLast();
            this.snakeMap.remove(currentTail);
        }
        
        this.snake.addFirst(newHead);
        this.snakeMap.put(newHead, true);
        notifyMoveMade(newHead);
        
        int score = this.snake.size() - 1;
        return score;
    }
}
```

**Usage Example:**

```java
public class SnakeGameMain {
    public static void main(String[] args) {
        int width = 20;
        int height = 15;
        int[][] foodPositions = { {5, 5}, {10, 8}, {3, 12} };
        
        // Initialize game with NO walls - passing 'false'
        SnakeGame game = new SnakeGame(width, height, foodPositions, false);
        
        // Add observer
        game.addObserver(new ConsoleGameObserver());
        
        System.out.println("===== SNAKE GAME (NO WALLS MODE) =====");
        System.out.println("You can move through edges and appear on the opposite side!");
        System.out.println("Don't bite yourself!");
        
        // Game loop continues as before
    }
}
```

### Design Strengths

#### Scalability

* Easy to add new movement strategies (AI, multiplayer)
* Simple to introduce new food types with different effects
* Straightforward board size configuration
* Extensible for multiple game modes

#### Modularity

* Clear separation of concerns
* Each component has a single responsibility
* Independent movement strategy
* Decoupled observer system

#### Flexibility

* Strategy pattern allows runtime behavior changes
* Factory pattern simplifies object creation
* Singleton ensures consistent game board
* Observer pattern enables event-driven architecture

#### Maintainability

* Clean class structure and relationships
* Well-defined interfaces
* Intuitive architecture
* Easy to understand and extend

### Interview Tips

#### Key Discussion Points

1. **Requirements Clarification**
   * Ask about grid dimensions and constraints
   * Clarify food placement mechanism (random vs predefined)
   * Discuss scoring system and game modes
   * Inquire about single vs multiplayer support
2. **Design Pattern Selection**
   * Explain why each pattern was chosen
   * Discuss alternatives and trade-offs
   * Show understanding of SOLID principles
   * Demonstrate pattern composition
3. **Extensibility**
   * Demonstrate how to add new features
   * Discuss potential enhancements
   * Show forward-thinking design
   * Consider performance implications
4. **Edge Cases**
   * Handle concurrent access scenarios
   * Validate business rules
   * Consider error handling
   * Think about boundary conditions

#### Common Interview Questions

**Q: How would you add multiplayer support?**

* Create multiple Snake instances
* Implement collision detection between snakes
* Use Observer pattern to notify all players
* Consider turn-based or real-time modes

**Q: How would you implement different difficulty levels?**

* Adjust snake speed (timing between moves)
* Change board size
* Add obstacles to the board
* Vary food spawn frequency

**Q: How would you add a scoring system with combos?**

* Track consecutive food items eaten
* Implement multiplier logic in food consumption
* Use Observer pattern to track combo events
* Add timer for combo duration

**Q: How would you persist game state?**

* Serialize Snake, Board, and Food state
* Implement save/load functionality
* Use Memento pattern for undo/redo
* Consider database or file storage

### Conclusion

This Snake & Food game design demonstrates a robust, scalable architecture that adheres to software engineering best practices. The implementation showcases:

* **Design Pattern Mastery**: Strategic use of Strategy, Factory, Singleton, and Observer patterns
* **SOLID Principles**: Single responsibility, open-closed, and dependency inversion
* **Clean Code**: Readable, maintainable, and well-documented
* **Extensibility**: Easy to enhance with new features
* **Real-World Applicability**: Production-ready design

The use of design patterns makes the codebase:

* **Flexible**: Easy to swap implementations
* **Testable**: Components can be tested in isolation
* **Maintainable**: Clear structure and responsibilities
* **Scalable**: Can grow with new requirements

This approach effectively balances theoretical knowledge with practical implementation, making it an excellent example for technical interviews and real-world applications.

### Additional Enhancements

#### Possible Future Extensions

1. **Power-ups System**
   * Speed boost
   * Invincibility
   * Score multipliers
   * Snake shrink
2. **Obstacle System**
   * Static obstacles on the board
   * Moving obstacles
   * Temporary barriers
3. **Leaderboard System**
   * High score tracking
   * Player statistics
   * Global rankings
4. **Visual Enhancements**
   * Graphical user interface
   * Animation effects
   * Sound effects
   * Themes and skins
5. **AI Opponent**
   * Computer-controlled snakes
   * Different difficulty levels
   * Learning algorithms

Each of these extensions can be implemented using the existing design patterns, demonstrating the robustness and flexibility of the architecture.
