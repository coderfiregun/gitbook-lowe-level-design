# 1. Design Tic Tac Toe

## Design Tic Tac Toe Game

**Source:** [Original Article](https://codewitharyan.com/tech-blogs/design-tic-tac-toe-game)

***

### Low-Level Design: Tic Tac Toe Game

Tic Tac Toe, known colloquially as "Xs and Os," is a two-player game typically played on a 3x3 grid. The objective is simple: be the first to form a horizontal, vertical, or diagonal line of three of your marks (either "X" or "O"). The elegance of the game lies in its deceptive complexity, while the rules are straightforward, devising an unbeatable strategy demands a keen understanding of the game's dynamics.

### Rules of the Game

| Rule              | Description                                                                                                 |
| ----------------- | ----------------------------------------------------------------------------------------------------------- |
| **Setup**         | Game is played on a 3×3 grid. One player uses 'X', another uses 'O'. Players take turns.                    |
| **Winner**        | First player to get three symbols in a row (horizontal, vertical, or diagonal) wins. Game ends immediately. |
| **Draw**          | If all cells are filled and no player has three in a row, the game is a tie/draw.                           |
| **Illegal Moves** | Cannot place symbol on occupied cell. Move must be made to an empty cell.                                   |

### Interview Setting

#### Point 1: Introduction and Vague Problem Statement

**Interviewer:** Let's start with a basic problem statement. Design a Tic Tac Toe game system.

**Candidate:** Certainly! Let me outline the flow of the game based on my understanding of the Tic Tac Toe game first:

* We have a standard 3x3 grid.
* Two players take turns marking the spaces on the grid with 'X' and 'O'.
* The game continues until one player gets three of their marks in a row (horizontal, vertical, or diagonal), or the grid is filled resulting in a draw.

Is this the kind of game flow you had in mind?

**Interviewer:** Yes, you are in-line with the flow. Please continue ahead.

**Candidate:** Sure, I'd like to clarify a few requirements to ensure we're on the same page:

* Are we focusing on a standard 3x3 board?
* Will this be a two-player human game?
* What are the core requirements?

#### Point 2: Clarifying Requirements

**Interviewer:** We want a simple system that:

* Supports a standard 3x3 Tic Tac Toe game
* Allows two human players to play
* Provides move validation
* Detects win or draw conditions

**Candidate:** To ensure we're on the same page, let me write down the key requirements:

1. A 3x3 game board.
2. Two human players.
3. Alternating turns between 'X' and 'O'.
4. Move validation to ensure no wrong moves are made.
5. Detection of win or draw scenarios.

**Interviewer:** Perfect, Let's Proceed.

#### Point 3: Identifying Key Components

**Candidate:** Now that we have the requirements clarified, let's identify the key components of our Tic Tac Toe system:

**1. Piece (Symbol Enum)**

Represents 'X' and 'O'.

**Description:** This enum represents the two possible pieces in the game: 'X' and 'O', as well as an empty cell.

```java
public enum Symbol {
   X, O, EMPTY
}
```

**2. Board Class**

The 3x3 grid where the game is played.

**Description:** This class represents the game board, which can be of any size. It includes methods for validating moves, making moves, and checking the game state.

```java
public class Board {
    // Implementation details to follow
}
```

**3. Player Class**

Each player (either X or O) taking turns.

**Description:** This class represents a player in the game. It stores the player's symbol and strategy for making moves.

```java
public class Player {
     Symbol symbol;
     PlayerStrategy playerStrategy;

     public Player(Symbol symbol, PlayerStrategy playerStrategy) {
         this.symbol = symbol;
         this.playerStrategy = playerStrategy;
     }

     public Symbol getSymbol() {
         return symbol;
     }

     public PlayerStrategy getPlayerStrategy() {
         return playerStrategy;
     }
}
```

**4. Position Class**

Represents the row and column coordinates on the board.

**Description:** This class encapsulates the position on the board. It is used to represent the location of a move and supports equality checks and readable formatting.

```java
public class Position {
    public int row;
    public int col;

    public Position(int row, int col) {
        this.row = row;
        this.col = col;
    }

    @Override
    public String toString() {
        return "(" + row + ", " + col + ")";
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Position)) return false;
        Position other = (Position) obj;
        return this.row == other.row && this.col == other.col;
    }

    @Override
    public int hashCode() {
        return 31 * row + col;
    }
}
```

**Interviewer:** That sounds good. Let's proceed with the design details for these components.

#### Point 4: Design Challenges

**Interviewer:** What design challenges do you anticipate?

**Candidate:** The key challenges for the Tic Tac Toe game will include:

| Challenge                            | Description                                                                                                    |
| ------------------------------------ | -------------------------------------------------------------------------------------------------------------- |
| **Managing Game State**              | Ensuring the system accurately reflects the current state of the game, including player turns and board status |
| **Implementing Move Validation**     | Verifying that each move is legal and within the rules of the game                                             |
| **Tracking Player Turns**            | Ensuring that players alternate turns correctly between 'X' and 'O'                                            |
| **Detecting Game-Ending Conditions** | Accurately identifying win or draw scenarios to conclude the game appropriately                                |

#### Point 5: Approach

**Interviewer:** How would you approach these challenges to ensure our game doesn't break?

**Candidate:** To tackle the design challenges, I propose utilizing design patterns effectively:

**Design Patterns to be Used**

| Pattern              | Purpose                  | Example                                                              |
| -------------------- | ------------------------ | -------------------------------------------------------------------- |
| **Strategy Pattern** | For Player Interactions  | `makeMove()` method implemented differently for human and AI players |
| **State Pattern**    | For Game Flow Management | `GameState` class with methods to transition between states          |
| **Observer Pattern** | For Game Event Tracking  | `GameEventListener` notified when moves are made or state changes    |
| **Factory Pattern**  | For Player Creation      | `PlayerFactory` creates instances of human or AI players             |

**Benefits:**

1. **Strategy Pattern:** Define a consistent player interface; allow flexible player move implementations
2. **State Pattern:** Manage different game states; handle state transitions systematically
3. **Observer Pattern:** Notify listeners about game state changes; support potential future extensions
4. **Factory Pattern:** Create players with consistent interfaces; enable easy addition of player types

**Interviewer:** That sounds like a solid approach. Let's delve into the design details for these patterns and components.

#### Point 6: Implementation

**Interviewer:** Ready to discuss implementation?

**Candidate:** Yes. I'll focus on a simple, readable design that meets the core Tic Tac Toe requirements.

### Tic Tac Toe Design with Patterns

#### 1. Strategy Pattern: Player Move Strategies

The Strategy Pattern allows defining a family of algorithms or strategies and making them interchangeable.

```java
// Strategy Interface for Player Moves
public interface PlayerStrategy {
    Position makeMove(Board board);
}

// Concrete Strategy for Human Player
public class HumanPlayerStrategy implements PlayerStrategy {
    private Scanner scanner;
    private String playerName;
    
    public HumanPlayerStrategy(String playerName) {
        this.playerName = playerName;
        this.scanner = new Scanner(System.in);
    }
    
    @Override
    public Position makeMove(Board board) {
        while (true) {
            System.out.printf("%s, enter your move (row [0-2] and column [0-2]): ", 
                             playerName);
            try {
                int row = scanner.nextInt();
                int col = scanner.nextInt();
                Position move = new Position(row, col);
                
                if (board.isValidMove(move)) {
                    return move;
                }
                
                System.out.println("Invalid move. Try again.");
            } catch (Exception e) {
                System.out.println("Invalid input. Please enter row and column as numbers.");
                scanner.nextLine(); // Clear input buffer
            }
        }
    }
}
```

**Benefits:**

* ✅ Easily add new player strategies (AI, networked players)
* ✅ No need to change existing codebase
* ✅ Flexible and extensible design

#### 2. State Pattern: Game State Management

The State Pattern allows an object to alter its behavior when its internal state changes.

**Defining the Game Interface**

```java
// GameState Interface
public interface GameState {
    void next(GameContext context, Player player, boolean hasWon);
    boolean isGameOver();
}
```

**Concrete States**

```java
// Concrete State: XTurnState
public class XTurnState implements GameState {
    @Override
    public void next(GameContext context, Player player, boolean hasWon) {
        if (hasWon) {
            context.setState(player.getSymbol() == Symbol.X ? 
                            new XWonState() : new OWonState());
        } else {
            context.setState(new OTurnState());
        }
    }

    @Override
    public boolean isGameOver() {
        return false;
    }
}

// Concrete State: OTurnState
public class OTurnState implements GameState {
    @Override
    public void next(GameContext context, Player player, boolean hasWon) {
        if (hasWon) {
            context.setState(player.getSymbol() == Symbol.X ? 
                            new XWonState() : new OWonState());
        } else {
            context.setState(new XTurnState());
        }
    }

    @Override
    public boolean isGameOver() {
        return false;
    }
}

// Concrete State: XWonState
public class XWonState implements GameState {
    @Override
    public void next(GameContext context, Player player, boolean hasWon) {
       // Game over, no next state
    }
    
    @Override
    public boolean isGameOver() {
        return true;
    }
}

// Concrete State: OWonState
public class OWonState implements GameState {
    @Override
    public void next(GameContext context, Player player, boolean hasWon) {
        // Game over, no next state
    }

    @Override
    public boolean isGameOver() {
        return true;
    }
}
```

**Context Class**

```java
// GameContext Class
public class GameContext {
    private GameState currentState;
    
    public GameContext() {
        currentState = new XTurnState(); // Start with X's turn
    }
    
    public void setState(GameState state) {
        this.currentState = state;
    }
    
    public void next(Player player, boolean hasWon) {
        currentState.next(this, player, hasWon);
    }
    
    public boolean isGameOver() {
        return currentState.isGameOver();
    }
    
    public GameState getCurrentState() {
        return currentState;
    }
}
```

**State Pattern Benefits:**

* ✅ Encapsulates state-specific logic
* ✅ Clean way to manage game states
* ✅ Easy to add new states

#### 3. Board Representation

```java
public class Board {
    private final int rows;
    private final int columns;
    private Symbol[][] grid;
    
    public Board(int rows, int columns) {
        this.rows = rows;
        this.columns = columns;
        grid = new Symbol[rows][columns];
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                grid[i][j] = Symbol.EMPTY;
            }
        }
    }
    
    public boolean isValidMove(Position pos) {
        return pos.row >= 0 && pos.row < rows && 
               pos.col >= 0 && pos.col < columns &&
               grid[pos.row][pos.col] == Symbol.EMPTY;
    }
    
    public void makeMove(Position pos, Symbol symbol) {
        grid[pos.row][pos.col] = symbol;
    }
    
    public void checkGameState(GameContext context, Player currentPlayer) {
        // Check rows
        for (int i = 0; i < rows; i++) {
            if (grid[i][0] != Symbol.EMPTY && isWinningLine(grid[i])) {
                context.next(currentPlayer, true);
                return;
            }
        }
        
        // Check columns
        for (int i = 0; i < columns; i++) {
            Symbol[] column = new Symbol[rows];
            for (int j = 0; j < rows; j++) {
                column[j] = grid[j][i];
            }
            if (column[0] != Symbol.EMPTY && isWinningLine(column)) {
                context.next(currentPlayer, true);
                return;
            }
        }
        
        // Check diagonals
        Symbol[] diagonal1 = new Symbol[Math.min(rows, columns)];
        Symbol[] diagonal2 = new Symbol[Math.min(rows, columns)];
        
        for (int i = 0; i < Math.min(rows, columns); i++) {
            diagonal1[i] = grid[i][i];
            diagonal2[i] = grid[i][columns - 1 - i];
        }
        
        if (diagonal1[0] != Symbol.EMPTY && isWinningLine(diagonal1)) {
            context.next(currentPlayer, true);
            return;
        }
        
        if (diagonal2[0] != Symbol.EMPTY && isWinningLine(diagonal2)) {
            context.next(currentPlayer, true);
            return;
        }
    }
    
    private boolean isWinningLine(Symbol[] line) {
        Symbol first = line[0];
        for (Symbol s : line) {
            if (s != first) {
                return false;
            }
        }
        return true;
    }
    
    public void printBoard() {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                Symbol symbol = grid[i][j];
                switch (symbol) {
                    case X:
                        System.out.print(" X ");
                        break;
                    case O:
                        System.out.print(" O ");
                        break;
                    case EMPTY:
                    default:
                        System.out.print(" . ");
                }
                if (j < columns - 1) {
                    System.out.print("|");
                }
            }
            System.out.println();
            if (i < rows - 1) {
                System.out.println("---+---+---");
            }
        }
        System.out.println();
    }
}
```

**Board Class Features:**

* ✅ Validates moves
* ✅ Makes moves
* ✅ Checks game state (win/draw)
* ✅ Prints board

#### 4. Running the Game (Controller Pattern)

```java
interface BoardGames {
    void play();
}

public class TicTacToeGame implements BoardGames {
    private Board board;
    private Player playerX;
    private Player playerO;
    private Player currentPlayer;
    private GameContext gameContext;
    
    public TicTacToeGame(PlayerStrategy xStrategy, PlayerStrategy oStrategy,
                        int rows, int columns) {
        board = new Board(rows, columns);
        playerX = new Player(Symbol.X, xStrategy);
        playerO = new Player(Symbol.O, oStrategy);
        currentPlayer = playerX;
        gameContext = new GameContext();
    }
    
    @Override
    public void play() {
        do {
            board.printBoard();
            Position move = currentPlayer.getPlayerStrategy().makeMove(board);
            board.makeMove(move, currentPlayer.getSymbol());
            board.checkGameState(gameContext, currentPlayer);
            switchPlayer();
        } while (!gameContext.isGameOver());
        
        announceResult();
    }
    
    private void switchPlayer() {
        currentPlayer = (currentPlayer == playerX) ? playerO : playerX;
    }
    
    private void announceResult() {
        GameState state = gameContext.getCurrentState();
        if (state instanceof XWonState) {
            System.out.println("Player X wins!");
        } else if (state instanceof OWonState) {
            System.out.println("Player O wins!");
        } else {
            System.out.println("It's a draw!");
        }
    }
}
```

**Controller Pattern Benefits:**

* ✅ Encapsulates game flow logic
* ✅ Clear separation of concerns
* ✅ Modular and maintainable
* ✅ Easy to modify and extend

#### 5. Main Method

```java
public class Main {
    public static void main(String[] args) {
        PlayerStrategy playerXStrategy = new HumanPlayerStrategy("Player X");
        PlayerStrategy playerOStrategy = new HumanPlayerStrategy("Player O");
        
        TicTacToeGame game = new TicTacToeGame(playerXStrategy, playerOStrategy, 3, 3);
        game.play();
    }
}
```

**Interviewer:** Sounds good. What makes your approach effective?

**Candidate:** Here are the key strengths of my approach:

| Strength                   | Description                                |
| -------------------------- | ------------------------------------------ |
| **Simplicity**             | Design is kept minimal and straightforward |
| **Clarity**                | Easy to understand and maintain            |
| **Efficiency**             | Direct and logical implementation          |
| **Separation of Concerns** | Each component has a clear responsibility  |

### Extensibility

#### 5.1 Support for Different Board Sizes

```java
public class Board {
    private Symbol[][] grid;
    
    public Board(int size) {
        grid = new Symbol[size][size];
        for (int row = 0; row < size; row++) {
            for (int col = 0; col < size; col++) {
                grid[row][col] = Symbol.EMPTY;
            }
        }
    }
}
```

#### 5.2 Multiple Players and Symbols

Instead of fixed two players:

```java
// ❌ Before - Fixed players
public class TicTacToeGame {
    private Player playerX;
    private Player playerO;
}

// ✅ After - Dynamic players
public class TicTacToeGame {
    private List<Player> players;
    private int currentPlayerIndex;
    
    public TicTacToeGame(List<PlayerStrategy> strategies) {
        board = new Board();
        players = new ArrayList<>();
        players.add(new Player(Symbol.X, strategies.get(0)));
        players.add(new Player(Symbol.O, strategies.get(1)));
        currentPlayerIndex = 0;
    }
}
```

#### 5.3 Observer Pattern for Game Event Tracking

**GameEventListener Interface**

```java
public interface GameEventListener {
    void onMoveMade(Position position, Symbol symbol);
    void onGameStateChanged(GameState state);
}

public class ConsoleGameEventListener implements GameEventListener {
    @Override
    public void onMoveMade(Position position, Symbol symbol) {
        System.out.println("Move made at position: " + position + " by " + symbol);
    }
    
    @Override
    public void onGameStateChanged(GameState state) {
        System.out.println("Game state changed to: " + state);
    }
}
```

**Integration in Board Class**

```java
public class Board {
    private List<GameEventListener> listeners;
    
    public Board(int rows, int columns) {
        // ... initialization
        listeners = new ArrayList<>();
    }
    
    public void addListener(GameEventListener listener) {
        listeners.add(listener);
    }
    
    public void notifyMoveMade(Position position, Symbol symbol) {
        for (GameEventListener listener : listeners) {
            listener.onMoveMade(position, symbol);
        }
    }
    
    public void notifyGameStateChanged(GameState state) {
        for (GameEventListener listener : listeners) {
            listener.onGameStateChanged(state);
        }
    }
    
    public void makeMove(Position pos, Symbol symbol) {
        grid[pos.row][pos.col] = symbol;
        notifyMoveMade(pos, symbol);
    }
}
```

**Observer Pattern Benefits:**

* ✅ Notifies users about each move
* ✅ Updates on game state changes
* ✅ Facilitates logging and UI updates
* ✅ Decouples game logic from notifications

#### 5.4 Factory Pattern for Player Creation

```java
// PlayerFactory Interface
public interface PlayerFactory {
    Player createPlayer(Symbol symbol, PlayerStrategy strategy);
}

// Concrete PlayerFactory Class
public class SimplePlayerFactory implements PlayerFactory {
    @Override
    public Player createPlayer(Symbol symbol, PlayerStrategy strategy) {
        return new Player(symbol, strategy);
    }
}

// Usage in TicTacToeGame
public class TicTacToeGame {
    public TicTacToeGame(int boardSize, List<PlayerStrategy> strategies,
                        PlayerFactory playerFactory) {
        board = new Board(boardSize);
        players = new ArrayList<>();
        
        for (int i = 0; i < strategies.size(); i++) {
            Symbol symbol = Symbol.values()[i];
            players.add(playerFactory.createPlayer(symbol, strategies.get(i)));
        }
        currentPlayerIndex = 0;
    }
}
```

**Factory Pattern Benefits:**

* ✅ Consistent player interfaces
* ✅ Easy addition of new player types
* ✅ Centralized player creation logic
* ✅ Simplifies testing with mock players

### Design Patterns Summary

| Pattern        | Purpose                | Implementation                | Benefits                 |
| -------------- | ---------------------- | ----------------------------- | ------------------------ |
| **Strategy**   | Player move strategies | `PlayerStrategy` interface    | Flexible player types    |
| **State**      | Game state management  | `GameState` interface         | Clean state transitions  |
| **Observer**   | Event notifications    | `GameEventListener` interface | Decoupled notifications  |
| **Factory**    | Player creation        | `PlayerFactory` interface     | Consistent instantiation |
| **Controller** | Game flow              | `TicTacToeGame` class         | Centralized game logic   |

### Class Diagram Overview

```
┌─────────────────┐
│   BoardGames    │ (Interface)
└────────┬────────┘
         │ implements
         │
┌────────▼─────────┐
│ TicTacToeGame    │
├──────────────────┤
│ - board          │───────┐
│ - players        │       │
│ - gameContext    │       │
├──────────────────┤       │
│ + play()         │       │
│ - switchPlayer() │       │
└──────────────────┘       │
                           │
         ┌─────────────────┘
         │
┌────────▼─────────┐
│      Board       │
├──────────────────┤
│ - grid[][]       │
│ - listeners      │
├──────────────────┤
│ + makeMove()     │
│ + isValidMove()  │
│ + checkGameState()│
└──────────────────┘

┌──────────────────┐
│ PlayerStrategy   │ (Interface)
└────────┬─────────┘
         │ implements
         │
┌────────▼─────────────┐
│ HumanPlayerStrategy  │
├──────────────────────┤
│ + makeMove()         │
└──────────────────────┘

┌──────────────────┐
│   GameState      │ (Interface)
└────────┬─────────┘
         │ implements
         │
    ┌────┴──────┬──────────────┐
    │           │              │
┌───▼──────┐ ┌─▼─────────┐ ┌─▼────────┐
│XTurnState│ │OTurnState │ │XWonState │
└──────────┘ └───────────┘ └──────────┘
```

### Conclusion

This low-level design for Tic-Tac-Toe showcases a well-structured and scalable architecture, emphasizing modularity and extensibility.

#### Key Achievements

✅ **Modular Design:** Clear separation of concerns with distinct classes for Board, Player, and Game

✅ **Design Patterns:** Effective use of Strategy, State, Observer, and Factory patterns

✅ **Extensibility:** Supports custom board sizes, multiple players, and different game modes

✅ **Maintainability:** Clean code structure that's easy to understand and modify

✅ **Scalability:** Can easily accommodate new features like AI players, networking, or different game rules

#### What This Design Demonstrates

In an interview setting, presenting this design would demonstrate your ability to:

1. Break down complex problems into manageable components
2. Apply appropriate design patterns to solve specific challenges
3. Create flexible and extensible software architectures
4. Think about future requirements and maintainability
5. Balance simplicity with functionality

This design provides a solid foundation for a Tic-Tac-Toe game that can be easily extended and maintained, making it an excellent example of object-oriented design principles in action.

### Key Takeaways

* Low-level design requires clear identification of components and their responsibilities
* Design patterns provide proven solutions to common design challenges
* Strategy Pattern enables flexible player implementations (human, AI, network)
* State Pattern manages game flow and state transitions cleanly
* Observer Pattern decouples game logic from event notifications
* Factory Pattern provides consistent player creation and easy extensibility
* Controller Pattern centralizes game flow management
* Proper separation of concerns makes code more maintainable and testable
* Extensibility should be built into the design from the start
* Clear interfaces and abstractions enable future enhancements
* Board validation logic ensures game rules are enforced
* Supporting variable board sizes demonstrates design flexibility
