# 2. Design Chess Game

## Design Chess Game

**Source:** [Original Article](https://codewitharyan.com/tech-blogs/design-chess-game)

***

### Low-Level Design: Chess Game

Chess, a timeless classic, is a strategy game played between two players on an 8x8 grid. Each player commands an army of 16 pieces: one king, one queen, two rooks, two knights, two bishops, and eight pawns. The objective is to checkmate your opponent's king, placing it in a position where it cannot escape capture.

### Rules of the Game

#### 1. Setup

| Component      | Description                                                     |
| -------------- | --------------------------------------------------------------- |
| **Board**      | 8x8 grid with 64 squares of alternating colors (light and dark) |
| **Pieces**     | Each player has 16 pieces in predefined starting positions      |
| **First Move** | White always starts first                                       |

#### 2. Movement Rules

| Piece      | Movement Pattern                                                |
| ---------- | --------------------------------------------------------------- |
| **King**   | One square in any direction                                     |
| **Queen**  | Any number of squares in any direction                          |
| **Rook**   | Any number of squares horizontally or vertically                |
| **Bishop** | Any number of squares diagonally                                |
| **Knight** | "L" shape: two squares in one direction, then one perpendicular |
| **Pawn**   | Forward one square (or two on first move), captures diagonally  |

#### 3. Special Moves

| Move               | Description                                                |
| ------------------ | ---------------------------------------------------------- |
| **Castling**       | King moves two squares towards rook, rook jumps over king  |
| **En Passant**     | Special pawn capture move                                  |
| **Pawn Promotion** | Pawn reaching far end can become any piece (usually queen) |

#### 4. Winning the Game

| Condition     | Description                                                                   |
| ------------- | ----------------------------------------------------------------------------- |
| **Check**     | King is under threat of capture                                               |
| **Checkmate** | King is in check and cannot escape - game ends                                |
| **Stalemate** | Player has no legal moves and king is not in check - draw                     |
| **Draw**      | By agreement, threefold repetition, fifty-move rule, or insufficient material |

### Interview Setting

#### Point 1: Introduction and Vague Problem Statement

**Interviewer:** Let's start with a basic problem statement. Design a Chess game system.

**Candidate:** Certainly! Let me outline the flow of the game based on my understanding of Chess first:

* We have a standard 8x8 grid.
* Each player commands 16 pieces: one king, one queen, two rooks, two knights, two bishops, and eight pawns.
* The game continues until one player checkmates the opponent's king, or the game ends in a draw.

Is this the kind of game flow you had in mind?

**Interviewer:** Yes, you are in-line with the flow. Please continue ahead.

#### Point 2: Clarifying Requirements

**Candidate:** Sure, I'd like to clarify a few requirements to ensure we're on the same page:

* Are we focusing on a standard 8x8 board?
* Will this be a two-player human game?
* What are the core requirements?

**Interviewer:** We want a simple system that:

* Supports a standard 8x8 Chess game
* Allows two human players to play
* Provides move validation
* Detects check, checkmate, or draw conditions

**Candidate:** To ensure we're on the same page, let me write down the key requirements:

1. An 8x8 game board
2. Two human players
3. Alternating turns between players
4. Move validation to ensure no illegal moves are made
5. Detection of check, checkmate, or draw scenarios

**Interviewer:** Perfect, Let's Proceed.

#### Point 3: Identifying Key Components

**Candidate:** Now that we have the requirements clarified, let's identify the key components of our Chess system:

| Component  | Description                                                                     |
| ---------- | ------------------------------------------------------------------------------- |
| **Piece**  | Represents the different chess pieces (King, Queen, Rook, Knight, Bishop, Pawn) |
| **Board**  | The 8x8 grid where the game is played                                           |
| **Player** | Each player with their pieces                                                   |
| **Cell**   | Individual square on the board                                                  |
| **Move**   | Encapsulates move from start to end position                                    |

**Player Class**

```java
public class Player {
    private String name;
    private boolean isWhiteSide;

    public Player(String name, boolean isWhiteSide) {
        this.name = name;
        this.isWhiteSide = isWhiteSide;
    }

    public String getName() {
        return name;
    }

    public boolean isWhiteSide() {
        return isWhiteSide;
    }
}
```

**Interviewer:** That sounds good. Let's proceed with the design details for these components.

#### Point 4: Design Challenges

**Interviewer:** What design challenges do you anticipate?

**Candidate:** The key challenges for the Chess game will include:

| Challenge                            | Description                                                                |
| ------------------------------------ | -------------------------------------------------------------------------- |
| **Managing Game State**              | Ensuring accurate reflection of game state, player turns, and board status |
| **Implementing Move Validation**     | Verifying legal moves according to chess rules                             |
| **Tracking Player Turns**            | Ensuring proper alternation between players                                |
| **Detecting Game-Ending Conditions** | Accurately identifying check, checkmate, and draw scenarios                |

#### Point 5: Approach

**Interviewer:** How would you approach these challenges to ensure our game doesn't break?

**Candidate:** To tackle the design challenges, I propose utilizing design patterns effectively:

**Design Patterns to be Used**

| Pattern               | Purpose               | Benefit                                      |
| --------------------- | --------------------- | -------------------------------------------- |
| **Strategy Pattern**  | Piece Movements       | Different movement logic for each piece type |
| **Singleton Pattern** | Board                 | Single board instance throughout the game    |
| **Factory Pattern**   | Piece Creation        | Consistent piece instantiation               |
| **Observer Pattern**  | Game Event Tracking   | Notify listeners about game state changes    |
| **Enum Pattern**      | Game State Management | Track game status (ACTIVE, WIN, DRAW, etc.)  |

**Game Status Enum**

```java
public enum Status {
    ACTIVE, SAVED, BLACK_WIN, WHITE_WIN, STALEMATE
}
```

#### Point 6: Implementation

**Interviewer:** Ready to discuss implementation?

**Candidate:** Yes. I'll focus on a simple, readable design that meets the core Chess requirements.

### Chess Design with Patterns

#### 1. Factory Pattern for Piece Creation

**Define the Piece Abstract Class**

```java
public abstract class Piece {
    private boolean isWhitePiece;
    private boolean killed = false;

    public Piece(boolean isWhitePiece) {
        this.isWhitePiece = isWhitePiece;
    }

    public boolean isWhite() {
        return isWhitePiece;
    }

    public boolean isKilled() {
        return killed;
    }

    public void setKilled(boolean killed) {
        this.killed = killed;
    }
}
```

**Define Concrete Piece Classes**

**King.java:**

```java
public class King extends Piece {
    public King(boolean isWhitePiece) {
        super(isWhitePiece);
    }
}
```

**Queen.java:**

```java
public class Queen extends Piece {
    public Queen(boolean isWhitePiece) {
        super(isWhitePiece);
    }
}
```

**Bishop.java:**

```java
public class Bishop extends Piece {
    public Bishop(boolean isWhitePiece) {
        super(isWhitePiece);
    }
}
```

_Similar classes for Knight, Rook, and Pawn_

**Define the Piece Factory**

```java
public class PieceFactory {
    public static Piece createPiece(String pieceType, boolean isWhitePiece) {
        switch (pieceType.toLowerCase()) {
            case "king":
                return new King(isWhitePiece);
            case "queen":
                return new Queen(isWhitePiece);
            case "bishop":
                return new Bishop(isWhitePiece);
            case "knight":
                return new Knight(isWhitePiece);
            case "rook":
                return new Rook(isWhitePiece);
            case "pawn":
                return new Pawn(isWhitePiece);
            default:
                throw new IllegalArgumentException("Unknown piece type: " + pieceType);
        }
    }
}
```

**Factory Pattern Benefits:**

* ✅ Centralized piece creation logic
* ✅ Easy to add new piece types
* ✅ Consistent piece instantiation

#### 2. Cell and Move Classes

**Cell.java**

```java
public class Cell {
    private int row, col;
    private String label;
    private Piece piece;

    public Cell(int row, int col, Piece piece) {
        this.row = row;
        this.col = col;
        this.piece = piece;
    }

    public Piece getPiece() {
        return piece;
    }

    public void setPiece(Piece piece) {
        this.piece = piece;
    }
}
```

**Move.java**

```java
public class Move {
    private Cell startCell;
    private Cell endCell;

    public Move(Cell startCell, Cell endCell) {
        this.startCell = startCell;
        this.endCell = endCell;
    }

    public boolean isValid() {
        return !(startCell.getPiece().isWhite() == endCell.getPiece().isWhite());
    }

    public Cell getStartCell() {
        return startCell;
    }

    public Cell getEndCell() {
        return endCell;
    }
}
```

#### 3. Singleton Pattern for Board

```java
public class Board {
    private static Board instance;
    private Cell[][] board;

    // Private constructor to prevent instantiation
    private Board(int rows) {
        initializeBoard(rows);
    }

    // Method to get the single instance of Board
    public static Board getInstance(int rows) {
        if (instance == null) {
            instance = new Board(rows);
        }
        return instance;
    }

    // Initialize the board
    private void initializeBoard(int rows) {
        board = new Cell[rows][rows];
        
        // Setting White Pieces using PieceFactory
        setPieceRow(0, true);
        setPawnRow(1, rows, true);
        
        // Setting Black Pieces using PieceFactory
        setPieceRow(rows - 1, false);
        setPawnRow(rows - 2, rows, false);
        
        // Defining rest of the cells having no pieces
        for (int row = 2; row < rows - 2; row++) {
            for (int col = 0; col < rows; col++) {
                board[row][col] = new Cell(row, col, null);
            }
        }
    }

    // Set the major pieces for a given row
    private void setPieceRow(int row, boolean isWhite) {
        board[row][0] = new Cell(row, 0, PieceFactory.createPiece("rook", isWhite));
        board[row][1] = new Cell(row, 1, PieceFactory.createPiece("knight", isWhite));
        board[row][2] = new Cell(row, 2, PieceFactory.createPiece("bishop", isWhite));
        board[row][3] = new Cell(row, 3, PieceFactory.createPiece("queen", isWhite));
        board[row][4] = new Cell(row, 4, PieceFactory.createPiece("king", isWhite));
        board[row][5] = new Cell(row, 5, PieceFactory.createPiece("bishop", isWhite));
        board[row][6] = new Cell(row, 6, PieceFactory.createPiece("knight", isWhite));
        board[row][7] = new Cell(row, 7, PieceFactory.createPiece("rook", isWhite));
    }

    // Set pawns for a given row
    private void setPawnRow(int row, int rows, boolean isWhite) {
        for (int j = 0; j < rows; j++) {
            board[row][j] = new Cell(row, j, PieceFactory.createPiece("pawn", isWhite));
        }
    }
}
```

**Singleton Pattern Benefits:**

* ✅ Ensures single board instance
* ✅ Global access point
* ✅ Consistent game state

#### 4. Strategy Pattern for Piece Movements

**Movement Strategy Interface**

```java
// Common Interface for Move Strategies
public interface MovementStrategy {
    boolean canMove(Board board, Cell startCell, Cell endCell);
}
```

**Modified Piece Class**

```java
public abstract class Piece {
    private boolean isWhitePiece;
    private boolean killed = false;
    private MovementStrategy movementStrategy;

    public Piece(boolean isWhitePiece, MovementStrategy movementStrategy) {
        this.isWhitePiece = isWhitePiece;
        this.movementStrategy = movementStrategy;
    }

    public boolean isWhite() {
        return isWhitePiece;
    }

    public boolean isKilled() {
        return killed;
    }

    public void setKilled(boolean killed) {
        this.killed = killed;
    }

    public boolean canMove(Board board, Cell startBlock, Cell endBlock) {
        return movementStrategy.canMove(board, startBlock, endBlock);
    }
}
```

**Concrete Piece Classes with Strategies**

```java
// King class with movement strategy
public class King extends Piece {
    public King(boolean white) {
        super(white, new KingMovementStrategy());
    }
}

// Queen class with movement strategy
public class Queen extends Piece {
    public Queen(boolean white) {
        super(white, new QueenMovementStrategy());
    }
}

// Bishop class with movement strategy
public class Bishop extends Piece {
    public Bishop(boolean white) {
        super(white, new BishopMovementStrategy());
    }
}
```

**Strategy Pattern Benefits:**

* ✅ Encapsulates movement logic per piece
* ✅ Easy to add new movement patterns
* ✅ Testable and maintainable

#### 5. Running the Game

```java
interface BoardGames {
    // Interface for all board games
    void start();
}

public class ChessGame implements BoardGames {
    private Board board;
    private Player player1;  // WHITE
    private Player player2;  // BLACK
    private boolean isWhiteTurn;
    private ArrayList<Move> gameLog;
    private Status status;

    public ChessGame(Player player1, Player player2) {
        this.player1 = player1;
        this.player2 = player2;
        this.board = Board.getInstance(8);
        this.isWhiteTurn = true;
        this.status = Status.ACTIVE;
        this.gameLog = new ArrayList<>();
    }

    public void start() {
        while (this.status == Status.ACTIVE) {
            if (isWhiteTurn) {
                makeMove(new Move(startCell, endCell), player1);
            } else {
                makeMove(new Move(startCell, endCell), player2);
            }
        }
    }

    public void makeMove(Move move, Player player) {
        if (move.isValid()) {
            Piece sourcePiece = move.getStartCell().getPiece();
            
            if (sourcePiece.canMove(this.board, move.getStartCell(), move.getEndCell())) {
                Piece destinationPiece = move.getEndCell().getPiece();
                
                if (destinationPiece != null) {
                    if (destinationPiece instanceof King && isWhiteTurn) {
                        this.status = Status.WHITE_WIN;
                        return;
                    }
                    if (destinationPiece instanceof King && !isWhiteTurn) {
                        this.status = Status.BLACK_WIN;
                        return;
                    }
                    destinationPiece.setKilled(true);
                }
                
                gameLog.add(move);
                move.getEndCell().setPiece(sourcePiece);
                move.getStartCell().setPiece(null);
                isWhiteTurn = !isWhiteTurn;
            }
        }
    }
}
```

#### 6. Main Method

```java
public class Main {
    public static void main(String[] args) {
        // Create players
        Player player1 = new Player("Player1", true);  // White
        Player player2 = new Player("Player2", false); // Black

        // Initialize game
        ChessGame chessGame = new ChessGame(player1, player2);

        // Start the game
        chessGame.start();
    }
}
```

**Interviewer:** Sounds good. What makes your approach effective?

**Candidate:** Here are the key strengths of my approach:

| Strength                   | Description                                                    |
| -------------------------- | -------------------------------------------------------------- |
| **Simplicity**             | Avoids unnecessary complexity, uses well-defined patterns      |
| **Clarity**                | Easy to understand, facilitates implementation and maintenance |
| **Efficiency**             | Direct and logical implementation ensures smooth gameplay      |
| **Separation of Concerns** | Each component has clear, distinct responsibility              |
| **Extensibility**          | Easy to add new pieces, strategies, and game states            |
| **Maintainability**        | Clear structure makes updates easy without side effects        |
| **Robustness**             | Patterns ensure pieces adhere to movement rules                |

### Extensibility

#### 5.1 Support for Different Board Sizes

```java
public class Board {
    private static Board instance;
    private Cell[][] board;

    private Board(int rows) {
        initializeBoard(rows);
    }

    public static Board getInstance(int rows) {
        if (instance == null) {
            instance = new Board(rows); // Variable board size
        }
        return instance;
    }

    private void initializeBoard(int rows) {
        board = new Cell[rows][rows];
        // Initialize pieces for any board size
        setPieceRow(0, true);
        setPawnRow(1, rows, true);
        setPieceRow(rows - 1, false);
        setPawnRow(rows - 2, rows, false);
        
        for (int row = 2; row < rows - 2; row++) {
            for (int col = 0; col < rows; col++) {
                board[row][col] = new Cell(row, col, null);
            }
        }
    }
}
```

#### 5.2 Observer Pattern for Game Event Tracking

**GameEventListener Interface**

```java
public interface GameEventListener {
    void onMoveMade(Move move);
    void onGameStateChanged(Status state);
}

public class ConsoleGameEventListener implements GameEventListener {
    @Override
    public void onMoveMade(Move move) {
        System.out.println("Move made from: " + move.getStartCell().getLabel() + 
                          " to " + move.getEndCell().getLabel());
    }

    @Override
    public void onGameStateChanged(Status state) {
        System.out.println("Game state changed to: " + state);
    }
}
```

**Integration in Game Class**

```java
public class ChessGame {
    private Board board;
    private Player player1, player2;
    private boolean isWhiteTurn;
    private ArrayList<Move> gameLog;
    private Status status;
    private GameEventListener listener;

    public ChessGame(Player player1, Player player2) {
        this.player1 = player1;
        this.player2 = player2;
        this.board = Board.getInstance(8);
        this.isWhiteTurn = true;
        this.status = Status.ACTIVE;
        this.gameLog = new ArrayList<>();
    }

    public void setObserver(GameEventListener listener) {
        this.listener = listener;
    }

    private void notifyMoveMade(Move move) {
        if (listener != null) {
            listener.onMoveMade(move);
        }
    }

    private void notifyGameStateChanged(Status state) {
        if (listener != null) {
            listener.onGameStateChanged(state);
        }
    }

    public void makeMove(Move move, Player player) {
        if (move.isValid()) {
            Piece sourcePiece = move.getStartCell().getPiece();
            
            if (sourcePiece.canMove(this.board, move.getStartCell(), move.getEndCell())) {
                Piece destinationPiece = move.getEndCell().getPiece();
                
                if (destinationPiece != null) {
                    if (destinationPiece instanceof King && isWhiteTurn) {
                        this.status = Status.WHITE_WIN;
                        notifyGameStateChanged(this.status);
                        return;
                    }
                    if (destinationPiece instanceof King && !isWhiteTurn) {
                        this.status = Status.BLACK_WIN;
                        notifyGameStateChanged(this.status);
                        return;
                    }
                    destinationPiece.setKilled(true);
                }
                
                gameLog.add(move);
                move.getEndCell().setPiece(sourcePiece);
                move.getStartCell().setPiece(null);
                notifyMoveMade(move);
                isWhiteTurn = !isWhiteTurn;
            }
        }
    }
}
```

**Updated Main Method**

```java
public class Main {
    public static void main(String[] args) {
        Player player1 = new Player("Player1", true);
        Player player2 = new Player("Player2", false);

        ChessGame chessGame = new ChessGame(player1, player2);
        
        // Add observer for game state tracking
        chessGame.setObserver(new ConsoleGameEventListener());

        chessGame.start();
    }
}
```

#### 5.3 Strategy Pattern for Player Strategies

**Player Strategy Interface**

```java
public interface PlayerStrategy {
    Move determineMove(Board board, boolean isWhiteSide);
}
```

**Human Player Strategy**

```java
public class HumanPlayerStrategy implements PlayerStrategy {
    private Scanner scanner = new Scanner(System.in);

    @Override
    public Move determineMove(Board board, boolean isWhiteSide) {
        System.out.println((isWhiteSide ? "White" : "Black") + " player's turn.");
        System.out.print("Enter source position (e.g., a2): ");
        String source = scanner.nextLine();
        System.out.print("Enter destination position (e.g., a4): ");
        String destination = scanner.nextLine();

        Cell startCell = board.getCellFromNotation(source);
        Cell endCell = board.getCellFromNotation(destination);

        return new Move(startCell, endCell);
    }
}
```

**AI Player Strategy**

```java
public class AIPlayerStrategy implements PlayerStrategy {
    @Override
    public Move determineMove(Board board, boolean isWhiteSide) {
        List<Move> validMoves = generateValidMoves(board, isWhiteSide);
        
        if (validMoves.isEmpty()) {
            throw new IllegalStateException("No valid moves available");
        }

        Random random = new Random();
        return validMoves.get(random.nextInt(validMoves.size()));
    }

    private List<Move> generateValidMoves(Board board, boolean isWhiteSide) {
        List<Move> validMoves = new ArrayList<>();

        for (int row = 0; row < board.getSize(); row++) {
            for (int col = 0; col < board.getSize(); col++) {
                Cell startCell = board.getCell(row, col);
                Piece piece = startCell.getPiece();

                if (piece != null && piece.isWhite() == isWhiteSide) {
                    for (int destRow = 0; destRow < board.getSize(); destRow++) {
                        for (int destCol = 0; destCol < board.getSize(); destCol++) {
                            Cell endCell = board.getCell(destRow, destCol);
                            Move move = new Move(startCell, endCell);

                            if (move.isValid() && piece.canMove(board, startCell, endCell)) {
                                validMoves.add(move);
                            }
                        }
                    }
                }
            }
        }
        return validMoves;
    }
}
```

**Modified Player Class**

```java
public class Player {
    private String name;
    private boolean isWhiteSide;
    private PlayerStrategy strategy;

    public Player(String name, boolean isWhiteSide, PlayerStrategy strategy) {
        this.name = name;
        this.isWhiteSide = isWhiteSide;
        this.strategy = strategy;
    }

    public String getName() {
        return name;
    }

    public boolean isWhiteSide() {
        return isWhiteSide;
    }

    public Move makeMove(Board board) {
        return strategy.determineMove(board, isWhiteSide);
    }

    public void setStrategy(PlayerStrategy strategy) {
        this.strategy = strategy;
    }
}
```

**Board Helper Methods**

```java
public class Board {
    private static Board instance;
    private Cell[][] board;
    private int size;

    public Cell getCell(int row, int col) {
        if (row < 0 || row >= size || col < 0 || col >= size) {
            return null;
        }
        return board[row][col];
    }

    public Cell getCellFromNotation(String notation) {
        if (notation.length() != 2) {
            throw new IllegalArgumentException("Invalid notation: " + notation);
        }

        char file = notation.charAt(0);
        char rank = notation.charAt(1);

        if (file < 'a' || file >= 'a' + size || rank < '1' || rank >= '1' + size) {
            throw new IllegalArgumentException("Invalid notation: " + notation);
        }

        int col = file - 'a';
        int row = size - (rank - '0');

        return board[row][col];
    }

    public int getSize() {
        return size;
    }
}
```

**Final Main Method with Strategies**

```java
public class Main {
    public static void main(String[] args) {
        // Create players with different strategies
        Player player1 = new Player("Human Player", true, new HumanPlayerStrategy());
        Player player2 = new Player("AI Player", false, new AIPlayerStrategy());

        ChessGame chessGame = new ChessGame(player1, player2);
        chessGame.setObserver(new ConsoleGameEventListener());
        chessGame.start();
    }
}
```

### Design Patterns Summary

| Pattern       | Purpose                             | Implementation                                  | Benefits                                       |
| ------------- | ----------------------------------- | ----------------------------------------------- | ---------------------------------------------- |
| **Factory**   | Piece creation                      | `PieceFactory` class                            | Centralized creation, easy extensibility       |
| **Singleton** | Board management                    | `Board.getInstance()`                           | Single instance, global access                 |
| **Strategy**  | Piece movements & Player strategies | `MovementStrategy`, `PlayerStrategy` interfaces | Flexible behaviors, interchangeable algorithms |
| **Observer**  | Event notifications                 | `GameEventListener` interface                   | Decoupled notifications, extensible tracking   |

### Class Diagram Overview

```
┌─────────────────┐
│   BoardGames    │ (Interface)
└────────┬────────┘
         │ implements
         │
┌────────▼─────────┐
│   ChessGame      │
├──────────────────┤
│ - board          │───────┐
│ - player1        │       │
│ - player2        │       │
│ - isWhiteTurn    │       │
│ - gameLog        │       │
│ - status         │       │
├──────────────────┤       │
│ + start()        │       │
│ + makeMove()     │       │
└──────────────────┘       │
                           │
         ┌─────────────────┘
         │
┌────────▼─────────┐
│      Board       │ (Singleton)
├──────────────────┤
│ - board[][]      │
│ - instance       │
├──────────────────┤
│ + getInstance()  │
│ + getCell()      │
└──────────────────┘

┌──────────────────┐
│  PieceFactory    │ (Factory)
├──────────────────┤
│ + createPiece()  │
└────────┬─────────┘
         │ creates
         │
┌────────▼─────────┐
│      Piece       │ (Abstract)
├──────────────────┤
│ - isWhitePiece   │
│ - killed         │
│ - strategy       │
├──────────────────┤
│ + canMove()      │
└────────┬─────────┘
         │ extends
    ┌────┴──────────────────┬──────────┐
    │           │           │          │
┌───▼──┐ ┌─────▼────┐ ┌───▼────┐ ┌──▼───┐
│ King │ │  Queen   │ │ Rook   │ │ Pawn │
└──────┘ └──────────┘ └────────┘ └──────┘

┌──────────────────┐
│ MovementStrategy │ (Interface)
└────────┬─────────┘
         │ implements
    ┌────┴─────────────┬────────────┐
    │                  │            │
┌───▼──────────┐ ┌────▼────────┐ ┌─▼──────────┐
│KingMovement  │ │QueenMovement│ │RookMovement│
└──────────────┘ └─────────────┘ └────────────┘

┌──────────────────┐
│ PlayerStrategy   │ (Interface)
└────────┬─────────┘
         │ implements
    ┌────┴───────────┐
    │                │
┌───▼──────────┐ ┌──▼────────┐
│ HumanPlayer  │ │ AIPlayer  │
│  Strategy    │ │ Strategy  │
└──────────────┘ └───────────┘
```

### Conclusion

This low-level design for Chess showcases a well-structured and scalable architecture, emphasizing modularity and extensibility.

#### Key Achievements

✅ **Modular Design:** Clear separation with distinct classes for Piece, Board, Player, Cell, and Move

✅ **Design Patterns:** Effective use of Factory, Singleton, Strategy, and Observer patterns

✅ **Extensibility:** Supports custom board sizes, AI players, and different strategies

✅ **Maintainability:** Clean code structure that's easy to understand and modify

✅ **Scalability:** Can accommodate special moves (castling, en passant, promotion)

#### What This Design Demonstrates

In an interview setting, presenting this design would demonstrate:

1. Understanding of complex game mechanics and rules
2. Ability to apply multiple design patterns appropriately
3. Creation of flexible and extensible architectures
4. Consideration of both human and AI players
5. Proper encapsulation and separation of concerns
6. Planning for future requirements and maintainability

This design provides a solid foundation for a Chess game that can be easily extended with advanced features like:

* Move history and undo functionality
* Save/load game state
* Network multiplayer
* Advanced AI with minimax algorithm
* GUI integration
* Tournament mode

### Key Takeaways

* Chess design requires careful consideration of complex piece movement rules
* Factory Pattern simplifies piece creation and ensures consistency
* Singleton Pattern ensures single board instance throughout the game
* Strategy Pattern enables flexible piece movements and player types
* Observer Pattern decouples game logic from event notifications
* Board initialization uses factory to create all pieces systematically
* Move validation is separated into Move class and piece-specific strategies
* Player strategies allow both human input and AI decision-making
* Game state is tracked using enum for clear state management
* Extensibility is built in for custom board sizes and new piece types
* Each piece type encapsulates its own movement logic
* Clear separation between game logic, board management, and player interaction
