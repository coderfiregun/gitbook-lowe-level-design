# 9. Future and CompletableFuture

## Future and CompletableFuture

**Source:** [Original Article](https://codewitharyan.com/tech-blogs/future-and-completablefuture)

***

### Future and CompletableFuture in Java: Asynchronous Programming Essentials

In modern Java applications, handling asynchronous operations efficiently is crucial for creating responsive and scalable software. Two powerful tools for managing asynchronous tasks are the Future interface and its enhanced implementation, CompletableFuture. These constructs allow developers to work with results that may not be immediately available, enabling non-blocking operations and improving application performance.

### Future Interface: The Foundation of Asynchronous Results

The Future interface, introduced in Java 5, represents the result of an asynchronous computation. It provides a way to check if the computation is complete, wait for its completion, and retrieve the result.

#### Key Features of Future

**1. Result Retrieval üì•**

Allows access to the result of an asynchronous operation once it's available.

**Example:**

```java
import java.util.concurrent.*;

public class FutureResultExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(() -> 10 + 20);
        
        Integer result = future.get();  // blocks until result is ready
        System.out.println("Result: " + result);  // Result: 30
        
        executor.shutdown();
    }
}
```

**Explanation:**

* `submit()` starts the task asynchronously.
* `future.get()` blocks until the task finishes and returns the result.

**2. Status Checking ‚úÖ**

Provides methods to check if a task has completed or been cancelled.

**Example:**

```java
Future<Integer> future = executor.submit(() -> 42);

// ...some time later
if (future.isDone()) {
    System.out.println("Task completed!");
} else {
    System.out.println("Still working...");
}
```

**Explanation:** `isDone()` tells if the task is finished.

**3. Cancellation ‚ùå**

Supports cancellation of tasks that haven't started or are in progress.

**Example:**

```java
Future<?> future = executor.submit(() -> {
    while (true) {
        // long-running task
        if (Thread.currentThread().isInterrupted()) break;
    }
});

boolean cancelled = future.cancel(true); // interrupt the thread
System.out.println("Cancelled: " + cancelled);
```

**Output:**

```
Cancelled: true
```

**Why Check Thread.interrupted():**

When you call `future.cancel(true)`, it sends an interrupt signal to the thread running the task. But Java doesn't forcefully stop a thread ‚Äî it just sets the interrupted flag. So your task must periodically check if it has been interrupted using `Thread.interrupted()`.

**Better Example:**

```java
Future<?> future = executor.submit(() -> {
    while (true) {
        if (Thread.interrupted()) {
            System.out.println("Task was interrupted. Stopping...");
            break;
        }
        // Simulate work
    }
});

future.cancel(true);  // sends interrupt
```

**Output:**

```
Task was interrupted. Stopping...
```

**4. Blocking Operations ‚è≥**

Primarily uses blocking methods that wait for task completion.

**Example:**

```java
Future<String> future = executor.submit(() -> {
    Thread.sleep(3000);
    return "Finished after delay";
});

System.out.println("Waiting for result...");
String value = future.get(); // blocks for ~3 seconds
System.out.println(value);
```

**Output:**

```
Waiting for result...
Finished after delay
```

**Why Use Timeout:**

`future.get()` blocks the current thread until the task completes ‚Äî this could take forever if the task hangs. Use `get(long timeout, TimeUnit unit)` to add a maximum wait time. If the result isn't ready in that time, it throws a `TimeoutException`.

#### Basic Usage of Future

```java
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        // Submit a task that returns a result in the future
        Future<String> future = executor.submit(() -> {
            Thread.sleep(2000); // Simulate a task that takes 2 seconds
            return "Task completed!";
        });
        
        try {
            System.out.println("Task submitted, doing other work...");
            
            // Check if the task is completed (non-blocking)
            System.out.println("Is task done? " + future.isDone());
            
            // Get the result - this blocks until the task is finished
            String result = future.get();
            System.out.println("Result: " + result);
            
            // Re-check task status after completion
            System.out.println("Is task done? " + future.isDone());
        } catch (InterruptedException | ExecutionException e) {
            System.out.println("Error: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
}
```

**Output:**

```
Task submitted, doing other work...
Is task done? false
Result: Task completed!
Is task done? true
```

#### Limitations of Future in Java

| Limitation                         | Description                              | Impact                                              |
| ---------------------------------- | ---------------------------------------- | --------------------------------------------------- |
| **No Composition** ‚ùå               | Cannot chain multiple tasks together     | Difficult to manage sequential async operations     |
| **No Exception Handling** ‚ö†Ô∏è       | No built-in exception handling mechanism | Must manually catch exceptions using `get()`        |
| **Blocking Operations** üõë         | `get()` blocks the current thread        | Potential performance issues for long-running tasks |
| **No Completion Notification** üîî‚ùå | No event-driven mechanism for completion | Must explicitly poll or call `get()`                |

This is why **CompletableFuture** is preferred, as it addresses these limitations with features like chaining, exception handling, and non-blocking callbacks.

#### When to Use Future?

Future is a good choice for simpler asynchronous tasks where blocking is acceptable for result retrieval. However, for more advanced features like chaining, combining tasks, or non-blocking result handling, use **CompletableFuture**.

#### Future vs CompletableFuture: Side-by-Side Example

**Example 1: Using Future (Blocking)**

```java
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        Future<String> future = executor.submit(() -> {
            Thread.sleep(1000); // Simulate a delay
            return "Result from Future";
        });
        
        try {
            // Blocking call: waits for the result.
            String result = future.get();
            System.out.println("Future result: " + result);
            
            // Additional operation after the result is retrieved.
            System.out.println("Processing after Future result");
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

**Output:**

```
Future result: Result from Future
Processing after Future result
```

**Explanation:** The call to `future.get()` blocks the main thread until the task completes.

**Example 2: Using CompletableFuture (Non-Blocking)**

```java
import java.util.concurrent.CompletableFuture;

public class CompletableFutureExample {
    public static void main(String[] args) {
        // Start an asynchronous task
        CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000); // Simulate a delay
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return "Result from CompletableFuture";
        })
        // Register a callback that processes the result once it's ready.
        .thenAccept(result -> {
            System.out.println("CompletableFuture result: " + result);
            System.out.println("Processing after CompletableFuture result");
        });
        
        // Main thread is free to do other tasks
        System.out.println("Main thread is free to do other tasks while waiting...");
        
        // Wait for the async task to complete
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

**Output:**

```
Main thread is free to do other tasks while waiting...
CompletableFuture result: Result from CompletableFuture
Processing after CompletableFuture result
```

**Explanation:** The main thread continues execution without blocking while the asynchronous task runs in the background.

### CompletableFuture: Advanced Asynchronous Programming

CompletableFuture, introduced in Java 8, extends the Future interface and implements the CompletionStage interface. It addresses the limitations of Future and provides a rich set of methods for composing, combining, and handling asynchronous computations.

#### Key Features of CompletableFuture

| Feature                           | Description                                               |
| --------------------------------- | --------------------------------------------------------- |
| **Non-blocking Operations** üèÉ‚Äç‚ôÇÔ∏è | Supports non-blocking, asynchronous programming           |
| **Composition** üîó                | Allows chaining of multiple asynchronous operations       |
| **Combination** ü§ù                | Provides methods to combine results from multiple futures |
| **Exception Handling** ‚ö†Ô∏è         | Robust exception handling mechanisms                      |
| **Completion Callbacks** üîî       | Supports callbacks when tasks complete                    |
| **Explicit Completion** ‚úÖ         | Can be completed explicitly for complex scenarios         |

#### Common CompletableFuture Methods

**1. get() ‚Äì Wait and Retrieve the Result (Throws Checked Exception)**

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");

try {
    String result = future.get(); // Blocks until result is available
    System.out.println(result);   // Prints "Hello"
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}
```

**2. join() ‚Äì Wait and Retrieve the Result (Throws Unchecked Exception)**

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "World");
String result = future.join(); // Blocks until result is available
System.out.println(result);    // Prints "World"
```

**Note:** Not recommended unless you know exceptions won't occur, as it throws unchecked exceptions.

**3. complete(value) ‚Äì Manually Complete a Future**

```java
CompletableFuture<String> future = new CompletableFuture<>();
future.complete("Manual Result");
System.out.println(future.join()); // Prints "Manual Result"
```

**Use When:**

* You want to complete a future manually (e.g., timeout fallback, mock).
* If the future is already completed, `complete()` will return false.

**4. isDone() ‚Äì Checks if the Future is Completed**

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Done");

while (!future.isDone()) {
    System.out.println("Waiting...");
}

System.out.println("Result: " + future.join());
```

**Use When:** You want to poll or check status without blocking.

**Returns:** `true` if the computation is complete, otherwise `false`.

#### Method Comparison Table

| Method       | Blocking | Exception Type                                     | Use Case                                       |
| ------------ | -------- | -------------------------------------------------- | ---------------------------------------------- |
| `get()`      | ‚úÖ Yes    | Checked (InterruptedException, ExecutionException) | When you need to handle checked exceptions     |
| `join()`     | ‚úÖ Yes    | Unchecked (CompletionException)                    | When you want simpler syntax without try-catch |
| `complete()` | ‚ùå No     | None                                               | Manually completing a future                   |
| `isDone()`   | ‚ùå No     | None                                               | Checking completion status                     |

### CompletableFuture Code Examples

#### 1. Creating CompletableFuture

```java
import java.util.concurrent.*;

public class CompletableFutureCreation {
    public static void main(String[] args) {
        // Create a completed future with a pre-defined result
        CompletableFuture<String> completed = CompletableFuture.completedFuture("Result");
        System.out.println("Completed future result: " + completed.join());
        
        // Create and run a task asynchronously
        CompletableFuture<String> async = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000); // Simulate work
                return "Async result";
            } catch (InterruptedException e) {
                return "Interrupted";
            }
        });
        
        // Non-blocking check and then blocking get
        System.out.println("Is async done? " + async.isDone());
        System.out.println("Async result: " + async.join());
    }
}
```

**Output:**

```
Completed future result: Result
Is async done? false
Async result: Async result
```

#### 2. Transforming Results

**thenApply** runs in the same thread, while **thenApplyAsync** uses a different thread from the ForkJoinPool.

```java
import java.util.concurrent.CompletableFuture;

public class CompletableFutureThreadUsageExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("supplyAsync running in: " + 
                              Thread.currentThread().getName());
            return "Hello";
        })
        .thenApply(s -> {
            // Runs in the same thread as supplyAsync if available
            System.out.println("thenApply running in: " + 
                              Thread.currentThread().getName());
            return s + " World";
        })
        .thenApplyAsync(s -> {
            // Uses a different thread from the ForkJoinPool
            System.out.println("thenApplyAsync running in: " + 
                              Thread.currentThread().getName());
            return s + "! CompletableFuture is awesome.";
        });
        
        System.out.println("Final result: " + future.join());
    }
}
```

**Output:**

```
supplyAsync running in: ForkJoinPool.commonPool-worker-1
thenApply running in: ForkJoinPool.commonPool-worker-1
thenApplyAsync running in: ForkJoinPool.commonPool-worker-2
Final result: Hello World! CompletableFuture is awesome.
```

**When to Use Each:**

* **thenApply:** Good when the transformation is trivial and you're not concerned about the current thread's workload.
* **thenApplyAsync:** Useful when you want to offload work to prevent a potentially busy thread from doing heavy computation.

#### 3. Combining CompletableFutures

```java
import java.util.concurrent.*;

public class CompletableFutureCombination {
    public static void main(String[] args) {
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
                return "Future 1";
            } catch (InterruptedException e) {
                return "Interrupted";
            }
        });
        
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(2000);
                return "Future 2";
            } catch (InterruptedException e) {
                return "Interrupted";
            }
        });
        
        // Combine results of two futures
        CompletableFuture<String> combined = future1.thenCombine(future2,
            (result1, result2) -> result1 + " + " + result2);
        System.out.println("Combined result: " + combined.join());
        
        // Wait for all futures to complete
        CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2);
        allOf.thenRun(() -> System.out.println("Both futures completed!"));
        
        // Wait for any one future to complete
        CompletableFuture<Object> anyOf = CompletableFuture.anyOf(future1, future2);
        System.out.println("First completed: " + anyOf.join());
    }
}
```

**Output:**

```
Combined result: Future 1 + Future 2
Both futures completed!
First completed: Future 1
```

#### Combination Methods Table

| Method          | Description                          | Use Case                               |
| --------------- | ------------------------------------ | -------------------------------------- |
| `thenCombine()` | Combines two futures with a function | When you need both results             |
| `allOf()`       | Waits for all futures to complete    | Parallel execution, all results needed |
| `anyOf()`       | Waits for any future to complete     | Race condition, first result wins      |
| `thenCompose()` | Chains dependent futures             | Sequential async operations            |

#### 4. Exception Handling ‚ö†Ô∏è

```java
import java.util.concurrent.*;

public class CompletableFutureExceptionHandling {
    public static void main(String[] args) {
        // Using exceptionally
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Something went wrong!");
            }
            return "Success";
        })
        .exceptionally(ex -> {
            System.out.println("Exception caught: " + ex.getMessage());
            return "Recovery value";
        });
        
        System.out.println("Result: " + future.join());
        
        // Using handle (handles both success and failure)
        CompletableFuture<String> handled = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Error occurred");
            }
            return "Success path";
        })
        .handle((result, ex) -> {
            if (ex != null) {
                return "Handled error: " + ex.getMessage();
            }
            return "Handled success: " + result;
        });
        
        System.out.println(handled.join());
    }
}
```

**Output 1 (If Exception Occurs):**

```
Exception caught: Something went wrong!
Result: Recovery value
Handled error: Error occurred
```

**Output 2 (If No Exception Occurs):**

```
Result: Success
Handled success: Success path
```

#### Exception Handling Methods

| Method            | When to Use                                      | Returns                  |
| ----------------- | ------------------------------------------------ | ------------------------ |
| `exceptionally()` | Recover from exceptions only                     | Recovery value           |
| `handle()`        | Handle both success and failure                  | Result or recovery value |
| `whenComplete()`  | Perform action on completion (doesn't transform) | Original result          |

#### 5. Timeouts and Cancellation üïí

```java
import java.util.concurrent.*;

public class CompletableFutureTimeout {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(3000); // Simulate a long-running task
                return "Task completed";
            } catch (InterruptedException e) {
                return "Task interrupted";
            }
        });
        
        // Apply timeout - throws TimeoutException if not completed in time
        CompletableFuture<String> withTimeout = future.orTimeout(2, TimeUnit.SECONDS);
        
        try {
            System.out.println(withTimeout.join());
        } catch (CompletionException e) {
            System.out.println("Timeout occurred: " + 
                              e.getCause().getClass().getSimpleName());
        }
        
        // Provide a default value on timeout
        CompletableFuture<String> withDefault = 
            future.completeOnTimeout("Default value", 2, TimeUnit.SECONDS);
        System.out.println("With default: " + withDefault.join());
    }
}
```

**Output:**

```
Timeout occurred: TimeoutException
With default: Default value
```

#### Timeout Methods Comparison

| Method                                    | Behavior on Timeout          | Exception        |
| ----------------------------------------- | ---------------------------- | ---------------- |
| `orTimeout(timeout, unit)`                | Completes exceptionally      | TimeoutException |
| `completeOnTimeout(value, timeout, unit)` | Completes with default value | None             |

**Key Points:**

* `orTimeout()` adds a timeout that throws an exception
* `completeOnTimeout()` provides a fallback value
* Original future continues running in the background after timeout

### CompletableFuture vs Future: Complete Comparison

| Feature                     | Future                      | CompletableFuture                         |
| --------------------------- | --------------------------- | ----------------------------------------- |
| **Java Version**            | Java 5                      | Java 8                                    |
| **Blocking**                | ‚úÖ Always (get())            | ‚ö†Ô∏è Optional (can use callbacks)           |
| **Chaining**                | ‚ùå No                        | ‚úÖ Yes (thenApply, thenCompose)            |
| **Combining**               | ‚ùå No                        | ‚úÖ Yes (thenCombine, allOf, anyOf)         |
| **Exception Handling**      | ‚ùå Manual                    | ‚úÖ Built-in (exceptionally, handle)        |
| **Completion Callbacks**    | ‚ùå No                        | ‚úÖ Yes (thenAccept, thenRun)               |
| **Timeout Support**         | ‚ö†Ô∏è Basic (get with timeout) | ‚úÖ Advanced (orTimeout, completeOnTimeout) |
| **Manual Completion**       | ‚ùå No                        | ‚úÖ Yes (complete, completeExceptionally)   |
| **Async Execution**         | ‚ö†Ô∏è Via ExecutorService      | ‚úÖ Built-in (supplyAsync, runAsync)        |
| **Composition**             | ‚ùå No                        | ‚úÖ Yes                                     |
| **Non-blocking Operations** | ‚ùå No                        | ‚úÖ Yes                                     |
| **Thread Control**          | ‚ö†Ô∏è Limited                  | ‚úÖ Extensive                               |
| **Use Case**                | Simple async tasks          | Complex async workflows                   |

### Common CompletableFuture Patterns

#### Pattern 1: Sequential Async Operations

```java
CompletableFuture.supplyAsync(() -> fetchUserId())
    .thenApply(id -> fetchUserDetails(id))
    .thenApply(details -> enrichUserData(details))
    .thenAccept(result -> saveToDatabase(result));
```

#### Pattern 2: Parallel Async Operations

```java
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> service1());
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> service2());
CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> service3());

CompletableFuture.allOf(future1, future2, future3)
    .thenRun(() -> System.out.println("All services completed"));
```

#### Pattern 3: Fallback on Failure

```java
CompletableFuture.supplyAsync(() -> primaryService())
    .exceptionally(ex -> fallbackService())
    .thenAccept(result -> processResult(result));
```

#### Pattern 4: Timeout with Default

```java
CompletableFuture.supplyAsync(() -> slowOperation())
    .completeOnTimeout(defaultValue, 5, TimeUnit.SECONDS)
    .thenAccept(result -> handleResult(result));
```

### Best Practices üëç

#### 1. Always Handle Exceptions

```java
// ‚úÖ Good
CompletableFuture.supplyAsync(() -> riskyOperation())
    .exceptionally(ex -> handleError(ex));

// ‚ùå Bad
CompletableFuture.supplyAsync(() -> riskyOperation()); // Exceptions swallowed
```

#### 2. Use Async Variants Wisely

```java
// Use thenApplyAsync for CPU-intensive operations
future.thenApplyAsync(result -> heavyComputation(result));

// Use thenApply for lightweight transformations
future.thenApply(result -> result.toUpperCase());
```

#### 3. Avoid Blocking in Callbacks

```java
// ‚ùå Bad - blocks the callback thread
future.thenAccept(result -> {
    anotherFuture.join(); // Blocking!
});

// ‚úÖ Good - chain asynchronously
future.thenCompose(result -> anotherFuture);
```

#### 4. Specify Custom Executors for Control

```java
ExecutorService customExecutor = Executors.newFixedThreadPool(10);

CompletableFuture.supplyAsync(() -> task(), customExecutor)
    .thenApplyAsync(result -> transform(result), customExecutor);
```

#### 5. Use allOf for Multiple Futures

```java
List<CompletableFuture<String>> futures = Arrays.asList(
    CompletableFuture.supplyAsync(() -> "A"),
    CompletableFuture.supplyAsync(() -> "B"),
    CompletableFuture.supplyAsync(() -> "C")
);

CompletableFuture<Void> allFutures = CompletableFuture.allOf(
    futures.toArray(new CompletableFuture[0])
);

allFutures.thenRun(() -> {
    List<String> results = futures.stream()
        .map(CompletableFuture::join)
        .collect(Collectors.toList());
});
```

### Conclusion üéØ

CompletableFuture represents a significant advancement in Java's asynchronous programming capabilities. While the basic Future interface laid the groundwork for handling asynchronous results, CompletableFuture's composition, combination, and exception handling features make it a far more powerful tool for modern Java applications.

### Key Takeaways

* Future provides basic asynchronous result handling with blocking operations
* CompletableFuture extends Future with non-blocking, composable operations
* Use `get()` for checked exceptions, `join()` for unchecked exceptions
* `thenApply()` transforms results synchronously, `thenApplyAsync()` asynchronously
* `thenCombine()` combines two futures, `allOf()` waits for all, `anyOf()` for any one
* Exception handling is built-in with `exceptionally()` and `handle()` methods
* Timeouts can be added with `orTimeout()` or `completeOnTimeout()`
* Always handle exceptions in asynchronous operations
* Use async variants for CPU-intensive operations
* Avoid blocking operations in callbacks
* CompletableFuture enables complex async workflows with method chaining
* Manual completion is possible with `complete()` and `completeExceptionally()`
* Custom executors provide fine-grained control over thread execution
