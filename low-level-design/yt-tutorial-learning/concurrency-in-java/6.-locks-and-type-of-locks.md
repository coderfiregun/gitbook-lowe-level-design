# 6. Locks and Type of Locks

## Locks and Types of Locks

**Source:** [Original Article](https://codewitharyan.com/tech-blogs/locks-and-types-of-locks)

***

### Locks and Types of Locks in Java: Mastering Concurrency Control

Lock mechanisms are essential tools for controlling access to shared resources in concurrent Java applications. While the `synchronized` keyword provides basic locking functionality, the `java.util.concurrent.locks` package offers more sophisticated and flexible lock implementations. This article explores the various types of locks available in Java and their appropriate use cases for effective concurrency control.

### Why Use Explicit Locks?

The `synchronized` keyword has been part of Java since its inception, so why use explicit locks? Explicit locks offer several advantages:

| Feature                            | Description                                             |
| ---------------------------------- | ------------------------------------------------------- |
| **Greater flexibility**            | Fine-grained control over lock acquisition and release  |
| **Non-block-structured locking**   | Acquire and release locks in different scopes           |
| **Timed lock attempts**            | Try to acquire a lock for a specified duration ‚è≥        |
| **Interruptible lock acquisition** | Allow threads to be interrupted while waiting for locks |
| **Non-ownership releases**         | Release locks from different threads (with caution) üë•  |
| **Multiple condition variables**   | Associate multiple conditions with a single lock üìã     |
| **Fairness policies**              | Optional first-come-first-served lock acquisition üéØ    |

### The Lock Interface Hierarchy üèõÔ∏è

The `java.util.concurrent.locks` package provides a rich set of interfaces and implementations:

```
Lock (Interface)
‚îú‚îÄ‚îÄ ReentrantLock
‚îî‚îÄ‚îÄ ReadWriteLock (Interface)
    ‚îî‚îÄ‚îÄ ReentrantReadWriteLock
        ‚îú‚îÄ‚îÄ ReadLock
        ‚îî‚îÄ‚îÄ WriteLock
```

### 1. Lock & ReentrantLock üîÅ

Locks in Java (via the `Lock` interface) offer more flexible and fine-grained control over synchronization than the built-in `synchronized` keyword. One of the most popular implementations is **ReentrantLock**, which is called "reentrant" because the thread that holds the lock can re-acquire it without causing deadlock üîÅ.

#### Key Features

It provides additional capabilities such as:

* ‚ö†Ô∏è **Interruptible Lock Acquisition:** Using `lockInterruptibly()`
* ‚è≥ **Try-Lock Methods:** With or without timeouts
* ‚öñÔ∏è **Fairness Policies:** To ensure threads acquire locks in the order requested

#### When to Use

It is used when you need advanced control over locking üß† (e.g., trying to acquire a lock and/or setting up fairness) or when a portion of a critical section is complex and may require more nuanced lock handling üß©.

#### Example: ReentrantLock with ExecutorService

```java
import java.util.concurrent.*;

public class ReentrantLockExecutorExample {
  private int counter = 0;
  
  // Create a ReentrantLock instance.
  private final ReentrantLock lock = new ReentrantLock();
  
  // Method to increment the counter using the lock.
  public void increment() {
    lock.lock();
    try {
      System.out.println(Thread.currentThread().getName() + " acquired the lock.");
      counter++;
      System.out.println(Thread.currentThread().getName() + 
                        " incremented counter to: " + counter);
    } finally {
      System.out.println(Thread.currentThread().getName() + " released the lock.");
      lock.unlock();
    }
  }
  
  public int getCounter() {
    return counter;
  }
  
  public static void main(String[] args) {
    ReentrantLockExecutorExample example = new ReentrantLockExecutorExample();
    // Create an ExecutorService with a fixed thread pool of 5 threads.
    ExecutorService executorService = Executors.newFixedThreadPool(5);
    
    // Submit 5 tasks to the executor service.
    for (int i = 0; i < 5; i++) {
      executorService.submit(() -> { example.increment(); });
    }
    
    // Shutdown the executor service gracefully.
    executorService.shutdown();
    try {
      // Wait for all tasks to finish; if not completed within 5 seconds, then exit.
      if (executorService.awaitTermination(5, TimeUnit.SECONDS)) {
        System.out.println("Final counter value: " + example.getCounter());
      } else {
        System.out.println("Timeout: Not all tasks finished.");
      }
    } catch (InterruptedException e) {
      System.err.println("Interrupted while waiting for tasks to finish.");
      Thread.currentThread().interrupt();
    }
  }
}
```

**OUTPUT:** (Ordering May Vary)

```
pool-1-thread-1 acquired the lock.
pool-1-thread-1 incremented counter to: 1
pool-1-thread-1 released the lock.

pool-1-thread-3 acquired the lock.
pool-1-thread-3 incremented counter to: 2
pool-1-thread-3 released the lock.

pool-1-thread-2 acquired the lock.
pool-1-thread-2 incremented counter to: 3
pool-1-thread-2 released the lock.

pool-1-thread-4 acquired the lock.
pool-1-thread-4 incremented counter to: 4
pool-1-thread-4 released the lock.

pool-1-thread-5 acquired the lock.
pool-1-thread-5 incremented counter to: 5
pool-1-thread-5 released the lock.

Final counter value: 5
```

### 2. ReentrantReadWriteLock (Read-Write Lock) üìö

`ReentrantReadWriteLock` (found in the `java.util.concurrent.locks` package) divides the lock into two parts‚Äîa **read lock** and a **write lock**. It is useful when:

* **Multiple Threads Need to Read:** üë• They can do so concurrently if there's no writing.
* **Exclusive Writing:** ‚úçÔ∏è When a thread is updating data, no other thread (reader or writer) is allowed to access the resource.

#### When to Use

It is used to improve performance in scenarios with many more read operations than writes.

#### Lock Access Rules

| Operation         | Read Lock Held     | Write Lock Held |
| ----------------- | ------------------ | --------------- |
| **Read Request**  | ‚úÖ Allowed (shared) | ‚ùå Blocked       |
| **Write Request** | ‚ùå Blocked          | ‚ùå Blocked       |

#### Example: ReadWriteLock in Action

```java
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

public class ReadWriteLogExample {
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private int logValue = 0;
    
    // Simulate processing work using a dummy computation loop.
    private void simulateWork() {
        long sum = 0;
        for (int i = 0; i < 500000; i++) {
            sum += i;
        }
        // (The computed sum is discarded; its purpose is solely to consume CPU time.)
    }
    
    // Write operation: exclusively updates the shared logValue.
    public void writeValue(String taskName, int newValue) {
        rwLock.writeLock().lock();
        try {
            System.out.println(taskName + " (write): Acquired write lock.");
            simulateWork();
            logValue = newValue;
            System.out.println(taskName + " (write): Updated logValue to " + logValue);
        } finally {
            System.out.println(taskName + " (write): Released write lock.");
            rwLock.writeLock().unlock();
        }
    }
    
    // Read operation: reads the shared logValue.
    public void readValue(String taskName) {
        rwLock.readLock().lock();
        try {
            System.out.println(taskName + " (read): Acquired read lock. Reading logValue: " + 
                              logValue);
            simulateWork();
            System.out.println(taskName + " (read): Finished reading.");
        } finally {
            System.out.println(taskName + " (read): Released read lock.");
            rwLock.readLock().unlock();
        }
    }
    
    public static void main(String[] args) {
        ReadWriteLogExample logExample = new ReadWriteLogExample();
        // Create an ExecutorService with a fixed pool of 4 threads.
        ExecutorService executor = Executors.newFixedThreadPool(4);
        
        /*
         * Schedule tasks to simulate the following sequence:
         * 1. Start with three reader tasks concurrently.
         * 2. Then, a writer task updates the log.
         * 3. Next, two readers read the updated value.
         * 4. Then, a second writer task updates the log.
         * 5. Finally, one more reader reads the new value.
         */
        
        // Submit three concurrent reader tasks.
        executor.submit(() -> logExample.readValue("Reader-1"));
        executor.submit(() -> logExample.readValue("Reader-2"));
        executor.submit(() -> logExample.readValue("Reader-3"));
        
        // Submit a writer task.
        executor.submit(() -> logExample.writeValue("Writer-1", 100));
        
        // Submit two additional reader tasks.
        executor.submit(() -> logExample.readValue("Reader-4"));
        executor.submit(() -> logExample.readValue("Reader-5"));
        
        // Submit a second writer task.
        executor.submit(() -> logExample.writeValue("Writer-2", 200));
        
        // Submit a final reader task.
        executor.submit(() -> logExample.readValue("Reader-6"));
        
        // Shut down the executor.
        executor.shutdown();
        try {
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                System.out.println("Timeout waiting for tasks to finish.");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

**Output:** (Ordering May Vary)

```
Reader-1 (read): Acquired read lock. Reading logValue: 0
Reader-2 (read): Acquired read lock. Reading logValue: 0
Reader-3 (read): Acquired read lock. Reading logValue: 0
Reader-1 (read): Finished reading.
Reader-1 (read): Released read lock.
Reader-2 (read): Finished reading.
Reader-2 (read): Released read lock.
Reader-3 (read): Finished reading.
Reader-3 (read): Released read lock.

Writer-1 (write): Acquired write lock.
Writer-1 (write): Updated logValue to 100
Writer-1 (write): Released write lock.

Reader-4 (read): Acquired read lock. Reading logValue: 100
Reader-5 (read): Acquired read lock. Reading logValue: 100
Reader-4 (read): Finished reading.
Reader-4 (read): Released read lock.
Reader-5 (read): Finished reading.
Reader-5 (read): Released read lock.

Writer-2 (write): Acquired write lock.
Writer-2 (write): Updated logValue to 200
Writer-2 (write): Released write lock.

Reader-6 (read): Acquired read lock. Reading logValue: 200
Reader-6 (read): Finished reading.
Reader-6 (read): Released read lock.
```

### synchronized vs ReentrantLock

#### 1. Acquisition and Flexibility üö¶

**synchronized:**

* The `synchronized` keyword is built into the language; it automatically acquires and releases the intrinsic lock (monitor) of an object.
* It is simple to use but offers only blocking behavior‚Äîit always waits indefinitely to acquire the lock. ‚è≥
* You cannot try to acquire a synchronized lock with a timeout or check if the lock is available (i.e., no non-blocking acquisition). ‚ùå

**ReentrantLock:**

* Part of the `java.util.concurrent.locks` package, ReentrantLock provides explicit lock management.
* It gives you extra flexibility‚Äîfor instance, with methods such as `tryLock()` (with or without a timeout) you can attempt to acquire the lock in a non-blocking manner.
* It also supports interruptible lock acquisition (`lockInterruptibly()`) and fairness policies. ‚öñÔ∏è

#### 2. Automatic vs. Manual Release üÜö

**synchronized:**

* The lock is automatically released when the synchronized block or method exits (even if an exception occurs).

**ReentrantLock:**

* You must explicitly call `unlock()` (usually in a `finally` block) to ensure that the lock is released. This gives you additional control but also adds responsibility.

#### Comparison Table

| Feature                 | synchronized | ReentrantLock                      |
| ----------------------- | ------------ | ---------------------------------- |
| **Lock Acquisition**    | Automatic    | Explicit (`lock()`)                |
| **Lock Release**        | Automatic    | Manual (`unlock()` in finally)     |
| **Try Lock**            | ‚ùå No         | ‚úÖ Yes (`tryLock()`)                |
| **Timed Lock**          | ‚ùå No         | ‚úÖ Yes (`tryLock(timeout)`)         |
| **Interruptible**       | ‚ùå No         | ‚úÖ Yes (`lockInterruptibly()`)      |
| **Fairness Policy**     | ‚ùå No         | ‚úÖ Yes (optional)                   |
| **Condition Variables** | 1 (implicit) | Multiple (explicit)                |
| **Ease of Use**         | ‚úÖ Simple     | ‚ö†Ô∏è More complex                    |
| **Performance**         | Good         | Slightly better in high contention |

### Example: tryLock() with Timeout

```java
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

public class ReentrantLockTryLockExample {
    private final ReentrantLock lock = new ReentrantLock();
    
    // Task that holds the lock for an extended period.
    public void longTask(String taskName) {
        lock.lock();
        try {
            System.out.println(taskName + 
                              " acquired the lock and is performing a long task.");
            // Simulate a long operation (e.g., by sleeping or doing busy work)
            // Here, we sleep to emulate that long operation.
            Thread.sleep(5000);
            System.out.println(taskName + 
                              " finished the task and is releasing the lock.");
        } catch (InterruptedException e) {
            System.out.println(taskName + " was interrupted.");
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
        }
    }
    
    // Task that attempts to acquire the lock using tryLock with a timeout.
    public void tryLockTask(String taskName) {
        try {
            // Try to acquire the lock for 2 seconds.
            if (lock.tryLock(2, TimeUnit.SECONDS)) {
                try {
                    System.out.println(taskName + 
                                      " acquired the lock using tryLock and is performing its task.");
                } finally {
                    lock.unlock();
                }
            } else {
                System.out.println(taskName + 
                                  " could not acquire the lock using tryLock within 2 seconds.");
            }
        } catch (InterruptedException e) {
            System.out.println(taskName + " was interrupted while waiting for the lock.");
            Thread.currentThread().interrupt();
        }
    }
    
    public static void main(String[] args) {
        ReentrantLockTryLockExample example = new ReentrantLockTryLockExample();
        // Use ExecutorService to manage threads.
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // Submit Task-A to acquire the lock and hold it for a long time.
        executor.submit(() -> example.longTask("Task-A"));
        
        // Short delay to ensure Task-A acquires the lock first.
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Submit Task-B that attempts to acquire the lock using tryLock.
        executor.submit(() -> example.tryLockTask("Task-B"));
        
        // Shutdown the executor.
        executor.shutdown();
    }
}
```

**Output:**

```
Task-A acquired the lock and is performing a long task.
Task-B could not acquire the lock using tryLock within 2 seconds.
Task-A finished the task and is releasing the lock.
```

#### Key Takeaways

**synchronized:**

* Would force Task-B to wait indefinitely until Task-A releases the lock. ‚è≥
* Lacks the non-blocking or timed acquisition option. ‚ùå

**ReentrantLock:**

* With `tryLock(long time, TimeUnit unit)`, Task-B can attempt to acquire the lock but proceed (or take alternate action) if it's not available within a specified timeout.
* Offers greater flexibility and control over lock acquisition and release. üéõÔ∏è

### Lock Types Summary

| Lock Type                  | Concurrency                    | Use Case                         | Performance         |
| -------------------------- | ------------------------------ | -------------------------------- | ------------------- |
| **ReentrantLock**          | Exclusive                      | General-purpose mutual exclusion | Good                |
| **ReentrantReadWriteLock** | Shared reads, exclusive writes | Read-heavy workloads             | Excellent for reads |
| **synchronized**           | Exclusive                      | Simple mutual exclusion          | Good, simpler       |
| **StampedLock**            | Optimistic reads               | Very read-heavy, rare writes     | Best for reads      |

### Best Practices üëç

#### 1. Always Use try-finally with ReentrantLock

```java
// ‚úÖ Correct
lock.lock();
try {
    // Critical section
} finally {
    lock.unlock();
}

// ‚ùå Wrong - lock might not be released
lock.lock();
// Critical section
lock.unlock();
```

#### 2. Use tryLock() for Deadlock Prevention

```java
if (lock.tryLock(timeout, TimeUnit.SECONDS)) {
    try {
        // Critical section
    } finally {
        lock.unlock();
    }
} else {
    // Handle failure to acquire lock
}
```

#### 3. Prefer ReadWriteLock for Read-Heavy Scenarios

When you have many more reads than writes, use `ReentrantReadWriteLock` to allow concurrent reads.

#### 4. Use Fair Locks Cautiously

```java
// Fair lock - threads acquire in FIFO order
ReentrantLock fairLock = new ReentrantLock(true);
```

**Note:** Fair locks have lower throughput but prevent starvation.

#### 5. Choose synchronized for Simplicity

If you don't need the advanced features of explicit locks, stick with `synchronized` for cleaner, less error-prone code.

### Common Lock Methods

#### ReentrantLock Methods

| Method                | Description                               | Blocking |
| --------------------- | ----------------------------------------- | -------- |
| `lock()`              | Acquires the lock, waits if necessary     | Yes      |
| `unlock()`            | Releases the lock                         | No       |
| `tryLock()`           | Tries to acquire lock immediately         | No       |
| `tryLock(timeout)`    | Tries to acquire lock with timeout        | Timed    |
| `lockInterruptibly()` | Acquires lock, can be interrupted         | Yes      |
| `isLocked()`          | Checks if lock is held                    | No       |
| `getHoldCount()`      | Returns number of holds by current thread | No       |

#### ReadWriteLock Methods

| Method                 | Description         | Lock Type |
| ---------------------- | ------------------- | --------- |
| `readLock().lock()`    | Acquires read lock  | Shared    |
| `readLock().unlock()`  | Releases read lock  | -         |
| `writeLock().lock()`   | Acquires write lock | Exclusive |
| `writeLock().unlock()` | Releases write lock | -         |

### When to Use Each Lock Type

#### Use synchronized When:

* ‚úÖ Lock scope matches method/block structure
* ‚úÖ Simple mutual exclusion is sufficient
* ‚úÖ No need for tryLock or timeout
* ‚úÖ Code simplicity is priority

#### Use ReentrantLock When:

* ‚úÖ Need timed lock acquisition
* ‚úÖ Need interruptible locking
* ‚úÖ Need fairness guarantees
* ‚úÖ Lock scope spans multiple methods
* ‚úÖ Need try-lock functionality

#### Use ReadWriteLock When:

* ‚úÖ Many readers, few writers
* ‚úÖ Read operations are time-consuming
* ‚úÖ Shared data is read more than written
* ‚úÖ Want to maximize read concurrency

### Visual Comparison: Lock Behavior

```
synchronized Block:
Thread 1: [Waiting...] [Lock] [Execute] [Auto-Unlock]
Thread 2:             [Waiting..................] [Lock]
Result: Thread 2 must wait, no timeout option

ReentrantLock with tryLock:
Thread 1: [Lock] [Execute] [Unlock]
Thread 2: [tryLock(2s)] [Timeout] [Continue with alternate logic]
Result: Thread 2 can timeout and proceed

ReadWriteLock:
Reader 1: [Read Lock] [Execute] [Unlock]
Reader 2: [Read Lock] [Execute] [Unlock]  ‚Üê Concurrent!
Reader 3: [Read Lock] [Execute] [Unlock]  ‚Üê Concurrent!
Writer:   [Waiting...........................] [Write Lock]
Result: Multiple concurrent reads, exclusive write
```

### Conclusion üéØ

Locks are fundamental tools for managing concurrent access to shared resources in Java applications. While the `synchronized` keyword provides basic locking functionality, the `java.util.concurrent.locks` package offers more sophisticated and flexible options to address complex concurrency challenges.

By understanding the different types of locks and their appropriate use cases, developers can create more efficient, scalable, and robust concurrent applications.

As concurrent programming becomes increasingly important in modern software development, mastering these lock mechanisms becomes essential for writing high-performance, thread-safe applications.

### Key Takeaways

* Explicit locks provide more flexibility than the synchronized keyword
* ReentrantLock supports timed lock attempts, interruptible locking, and fairness policies
* ReadWriteLock allows multiple concurrent readers but exclusive writers
* Always use try-finally blocks when using explicit locks to ensure proper release
* `tryLock()` enables non-blocking and timed lock acquisition for deadlock prevention
* Fair locks prevent starvation but have lower throughput than non-fair locks
* Use synchronized for simplicity when advanced features aren't needed
* ReadWriteLock is ideal for read-heavy workloads with infrequent writes
* ReentrantLock allows lock acquisition across multiple methods or scopes
* Choose the appropriate lock type based on your specific concurrency requirements
