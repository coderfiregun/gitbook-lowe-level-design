# 4. Thread Synchronization

## Thread Synchronization

**Source:** [Original Article](https://codewitharyan.com/tech-blogs/thread-synchronization)

***

### Thread Synchronization in Java

Thread synchronization is a critical concept in multithreaded programming that ensures multiple threads access shared resources in a controlled manner. Proper synchronization prevents data corruption, race conditions, and ensures thread safety in a concurrent environment.

### Methods of Thread Synchronization

The `synchronized` keyword is used to control access to critical sections of code so that only one thread can execute the synchronized code at a time. This ensures that shared mutable data is not corrupted by concurrent modifications.

There are two common ways to achieve this:

#### 1. Synchronized Method ðŸ”’

When you declare an entire method as synchronized, the lock is acquired on the object instance (or on the Class object for static methods) before the method is executed and released after it finishes.

This is useful when the whole method represents a critical section where no concurrent execution is desired. It is straightforward and reduces the chance of forgetting to protect part of the code.

**Example:**

```java
public class CounterSyncMethod {
    private int count = 0;
    
    // The entire method is synchronized.
    public synchronized void increment() {
        System.out.println("Synchronized Method - Start increment: " + 
                          Thread.currentThread().getName());
        // Critical section: updating the shared counter
        count++;
        System.out.println("Synchronized Method - Counter value after increment: " + count);
        System.out.println("Synchronized Method - End increment: " + 
                          Thread.currentThread().getName());
    }
    
    public int getCount() {
        return count;
    }
    
    // Main method to test the synchronized method
    public static void main(String[] args) {
        CounterSyncMethod counter = new CounterSyncMethod();
        int numberOfThreads = 5;
        Thread[] threads = new Thread[numberOfThreads];
        
        // Create and start threads that call the synchronized increment method.
        for (int i = 0; i < numberOfThreads; i++) {
            threads[i] = new Thread(new Runnable() {
                public void run() {
                    counter.increment();
                }
            }, "Thread-" + (i + 1));
            
            threads[i].start();
        }
        
        // Wait for all threads to complete.
        for (int i = 0; i < numberOfThreads; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        // Display the final counter value.
        System.out.println("Final counter value: " + counter.getCount());
    }
}
```

**Output:** The output order may vary due to thread scheduling, but it will be similar to:

```
Synchronized Method - Start increment: Thread-1
Synchronized Method - Counter value after increment: 1
Synchronized Method - End increment: Thread-1
Synchronized Method - Start increment: Thread-2
Synchronized Method - Counter value after increment: 2
Synchronized Method - End increment: Thread-2
Synchronized Method - Start increment: Thread-3
Synchronized Method - Counter value after increment: 3
Synchronized Method - End increment: Thread-3
Synchronized Method - Start increment: Thread-4
Synchronized Method - Counter value after increment: 4
Synchronized Method - End increment: Thread-4
Synchronized Method - Start increment: Thread-5
Synchronized Method - Counter value after increment: 5
Synchronized Method - End increment: Thread-5
Final counter value: 5
```

#### 2. Synchronized Block ðŸ§±

A synchronized block allows you to specify a particular block of code to be synchronized, along with the object on which to acquire the lock (often called a monitor ðŸ§­). This is more fine-grained compared to a synchronized method.

**Advantages:**

âœ… You can perform non-critical work outside the block, while only protecting the portion of code that truly requires exclusive access ðŸš«ðŸ‘¥.

âš¡ This can improve performance if only a subset of the method's operations need synchronization.

**Key Benefit:** The primary reason to choose a synchronized block over a synchronized method is when you have additional work in the method that doesn't need to be synchronized. This allows concurrent threads to execute the non-critical sections without waiting for the lock â³âž¡ï¸ðŸ’¨.

**Example:**

```java
public class CounterSyncBlock {
    private int count = 0;
    // Explicit lock object for finer control.
    private final Object lock = new Object();
    
    public void increment() {
        // Non-critical part: runs without locking.
        System.out.println("Non-Synchronized part (pre-processing): " + 
                          Thread.currentThread().getName());
        
        // Critical section: only this part is synchronized.
        synchronized (lock) {
            System.out.println("Synchronized Block - Start increment: " + 
                              Thread.currentThread().getName());
            count++;
            System.out.println("Synchronized Block - Counter value after increment: " + count);
            System.out.println("Synchronized Block - End increment: " + 
                              Thread.currentThread().getName());
        }
        
        // Non-critical part: runs after the synchronized block.
        System.out.println("Non-Synchronized part (post-processing): " + 
                          Thread.currentThread().getName());
    }
    
    public int getCount() {
        return count;
    }
    
    // Main method to test the synchronized block functionality.
    public static void main(String[] args) {
        CounterSyncBlock counter = new CounterSyncBlock();
        int numberOfThreads = 5;
        Thread[] threads = new Thread[numberOfThreads];
        
        // Create and start threads that execute the increment method.
        for (int i = 0; i < numberOfThreads; i++) {
            threads[i] = new Thread(new Runnable() {
                public void run() {
                    counter.increment();
                }
            }, "Thread-" + (i + 1));
            threads[i].start();
        }
        
        // Wait for all threads to finish.
        for (int i = 0; i < numberOfThreads; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        // Display the final value of the counter.
        System.out.println("Final counter value: " + counter.getCount());
    }
}
```

**Output:** The output order may vary due to thread scheduling, but it will be similar to:

```
Non-Synchronized part (pre-processing): Thread-1
Non-Synchronized part (pre-processing): Thread-2
Synchronized Block - Start increment: Thread-2
Synchronized Block - Counter value after increment: 1
Synchronized Block - End increment: Thread-2
Non-Synchronized part (post-processing): Thread-2
Non-Synchronized part (pre-processing): Thread-3
Synchronized Block - Start increment: Thread-1
Synchronized Block - Counter value after increment: 2
Synchronized Block - End increment: Thread-1
Non-Synchronized part (post-processing): Thread-1
Non-Synchronized part (pre-processing): Thread-4
Synchronized Block - Start increment: Thread-3
Synchronized Block - Counter value after increment: 3
Synchronized Block - End increment: Thread-3
Non-Synchronized part (post-processing): Thread-3
Non-Synchronized part (pre-processing): Thread-5
Synchronized Block - Start increment: Thread-4
Synchronized Block - Counter value after increment: 4
Synchronized Block - End increment: Thread-4
Non-Synchronized part (post-processing): Thread-4
Synchronized Block - Start increment: Thread-5
Synchronized Block - Counter value after increment: 5
Synchronized Block - End increment: Thread-5
Non-Synchronized part (post-processing): Thread-5
Final counter value: 5
```

#### Synchronized Method vs Synchronized Block

| Aspect          | Synchronized Method          | Synchronized Block              |
| --------------- | ---------------------------- | ------------------------------- |
| **Lock Scope**  | Entire method                | Specific code block             |
| **Lock Object** | `this` (or Class for static) | Can specify any object          |
| **Granularity** | Coarse-grained               | Fine-grained                    |
| **Performance** | May hold lock longer         | Can hold lock for minimal time  |
| **Flexibility** | Less flexible                | More flexible                   |
| **Use Case**    | Entire method is critical    | Only part of method is critical |

### Volatile Keyword in Java ðŸ”

The `volatile` keyword in Java is used to indicate that a variable's value will be modified by multiple threads. Declaring a variable as volatile ensures two key things:

#### 1. Visibility ðŸ‘€

When a variable is declared volatile, its value is always read from and written to the main memory ðŸ§  instead of a thread's local cache.

âœ… This means changes made by one thread are immediately visible to others.

âŒ Without volatile, updates in one thread might not be seen (or might be delayed) by others due to caching.

#### 2. Ordering ðŸ“

volatile establishes a happens-before relationship.

* Operations on a volatile variable cannot be re-ordered relative to each other.
* ðŸ“This is especially helpful when using flags or controlling execution flow to ensure instructions are executed in the intended order.

#### When to Use volatile ðŸ§ 

**1. Flags and Status Variables ðŸš©**

Used to signal threads (e.g., a shutdown flag or status switch).

**2. Singleton Patterns (with double-checked locking)**

In lazy initialization patterns, volatile ensures that the constructed instance is visible to all threads correctly.

**3. Lightweight Synchronization**

If you only need visibility guarantees (not atomicity for compound actions like `x++`), volatile is lighter and faster than using synchronized.

#### Example

```java
public class VolatileExample {
    // Declaring the flag as volatile ensures that changes to 'running'
    // in one thread are immediately visible to other threads.
    private volatile boolean running = true;
    
    // Method executed by the worker thread.
    public void runTask() {
        System.out.println("WorkerThread: Starting execution...");
        int counter = 0;
        
        // Continuously increment counter until 'running' becomes false.
        while (running) {
            counter++;
        }
        
        System.out.println("WorkerThread: Detected stop signal. Final counter value: " + 
                          counter);
    }
    
    // Called by the main thread to stop the worker thread.
    public void stopTask() {
        running = false;
    }
    
    // Main method to run the example.
    public static void main(String[] args) {
        VolatileExample example = new VolatileExample();
        
        // Create and start the worker thread.
        Thread workerThread = new Thread(new Runnable() {
            public void run() {
                example.runTask();
            }
        }, "WorkerThread");
        workerThread.start();
        
        // Let the worker thread run for a while.
        try {
            Thread.sleep(2000);  // Main thread sleeps for 2 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("MainThread: Stopping the worker thread.");
        example.stopTask(); // Signal the worker thread to stop
        
        // Wait for the worker thread to finish execution.
        try {
            workerThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("MainThread: Execution finished.");
    }
}
```

**Output:** The output should be similar to the following (note that the actual counter value will be a large number and can vary by run):

```
WorkerThread: Starting execution...
MainThread: Stopping the worker thread.
WorkerThread: Detected stop signal. Final counter value: 123456789
MainThread: Execution finished.
```

### Atomic Variables âš›ï¸

Atomic variables in Javaâ€”found in the `java.util.concurrent.atomic` packageâ€”are designed to support lock-free ðŸ”“, thread-safe operations on single variables.

You should use atomic variables when you need to perform simple operations âž•âž–ðŸ” (like incrementing, decrementing, or updating) on shared variables in a multithreaded environment. They are especially useful when the overhead of locking is undesirable ðŸ¢ and when the logic remains limited to single-step atomic operations ðŸŽ¯.

#### Common Atomic Classes

| Class               | Description                  | Common Methods                                           |
| ------------------- | ---------------------------- | -------------------------------------------------------- |
| **AtomicInteger**   | Thread-safe integer          | `get()`, `set()`, `incrementAndGet()`, `compareAndSet()` |
| **AtomicLong**      | Thread-safe long             | `get()`, `set()`, `incrementAndGet()`, `compareAndSet()` |
| **AtomicBoolean**   | Thread-safe boolean          | `get()`, `set()`, `compareAndSet()`                      |
| **AtomicReference** | Thread-safe object reference | `get()`, `set()`, `compareAndSet()`                      |

#### Example

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCounterExample {
    // The AtomicInteger counter provides atomic methods for thread-safe operations.
    private AtomicInteger counter = new AtomicInteger(0);
    
    // This method atomically increments the counter and prints the updated value.
    public void increment() {
        int newValue = counter.incrementAndGet(); // Atomically increments the value.
        System.out.println(Thread.currentThread().getName() + 
                          " incremented counter to " + newValue);
    }
    
    // Retrieves the current counter value.
    public int getCounter() {
        return counter.get();
    }
    
    // Main method to run the AtomicCounterExample.
    public static void main(String[] args) {
        final AtomicCounterExample example = new AtomicCounterExample();
        int numberOfThreads = 10;
        // Each thread will perform 100 increments.
        int incrementsPerThread = 100;
        Thread[] threads = new Thread[numberOfThreads];
        
        // Create and start threads that perform increments on the atomic counter.
        for (int i = 0; i < numberOfThreads; i++) {
            threads[i] = new Thread(new Runnable() {
                public void run() {
                    for (int j = 0; j < incrementsPerThread; j++) {
                        example.increment();
                    }
                }
            }, "Thread-" + (i + 1));
            threads[i].start();
        }
        
        // Wait for all threads to complete execution.
        for (int i = 0; i < numberOfThreads; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        // Display the final counter value.
        System.out.println("Final counter value: " + example.getCounter());
    }
}
```

**Output:** The exact interleaving of thread prints may vary on every run, but the final counter value will consistently reflect the total number of increments performed.

```
Final counter value: 1000
```

### Synchronization Techniques Comparison

| Technique               | Use Case                   | Performance         | Complexity | Thread Safety                  |
| ----------------------- | -------------------------- | ------------------- | ---------- | ------------------------------ |
| **Synchronized Method** | Entire method is critical  | Lower (coarse lock) | Low        | Strong                         |
| **Synchronized Block**  | Part of method is critical | Higher (fine lock)  | Medium     | Strong                         |
| **Volatile**            | Simple visibility, flags   | Highest (no lock)   | Low        | Weak (visibility only)         |
| **Atomic Variables**    | Simple atomic operations   | High (lock-free)    | Low        | Strong (for single operations) |
| **ReentrantLock**       | Advanced locking needs     | Medium              | High       | Strong                         |
| **ReadWriteLock**       | Many reads, few writes     | High (for reads)    | High       | Strong                         |

### When to Use Each Technique

#### Use Synchronized Method When:

* âœ… The entire method needs to be thread-safe
* âœ… Code simplicity is more important than performance
* âœ… Method is short and simple

#### Use Synchronized Block When:

* âœ… Only part of the method needs synchronization
* âœ… Want to minimize lock holding time
* âœ… Need to synchronize on a specific object

#### Use Volatile When:

* âœ… Variable is accessed by multiple threads
* âœ… Only need visibility guarantees
* âœ… No compound operations (like `i++`)
* âœ… Using as a flag or status indicator

#### Use Atomic Variables When:

* âœ… Need thread-safe operations on single variables
* âœ… Performing simple operations (increment, decrement, compare-and-set)
* âœ… Want lock-free thread safety
* âœ… Performance is critical

### Best Practices ðŸ‘

#### 1. Keep Synchronized Blocks Small ðŸ“

Only synchronize the critical section to minimize lock contention.

#### 2. Avoid Nested Locks ðŸš«

Nested locks can lead to deadlocks. If unavoidable, always acquire locks in a consistent order.

#### 3. Use Immutable Objects When Possible ðŸ”’

Immutable objects are inherently thread-safe and don't require synchronization.

#### 4. Prefer java.util.concurrent Utilities ðŸ› ï¸

Use higher-level concurrency utilities from `java.util.concurrent` package when appropriate.

#### 5. Document Synchronization Strategy ðŸ“

Clearly document which locks protect which data.

#### 6. Test Concurrent Code Thoroughly ðŸ§ª

Concurrency bugs are hard to reproduce. Use stress testing and tools like ThreadSanitizer.

#### 7. Avoid Synchronization on Strings and Boxed Types âš ï¸

These are often pooled and can lead to unexpected sharing.

### Common Pitfalls to Avoid

#### 1. Race Conditions ðŸƒ

**Problem:** Multiple threads accessing shared data without proper synchronization.

**Solution:** Use appropriate synchronization mechanisms.

#### 2. Deadlocks ðŸ”’ðŸ”’

**Problem:** Two or more threads waiting for each other to release locks.

**Solution:** Acquire locks in consistent order, use timeout-based locks.

#### 3. Starvation ðŸ˜¢

**Problem:** A thread never gets access to shared resources.

**Solution:** Use fair locks, avoid long-running synchronized blocks.

#### 4. Livelock ðŸ”„

**Problem:** Threads continuously change state in response to each other without making progress.

**Solution:** Introduce randomness or backoff strategies.

#### 5. Over-synchronization ðŸ¢

**Problem:** Too much synchronization reduces performance.

**Solution:** Minimize synchronized regions, use concurrent collections.

### Visual Comparison: Synchronization Flow

```
Without Synchronization:
Thread 1: Read value (10) â†’ Increment (11) â†’ Write (11)
Thread 2: Read value (10) â†’ Increment (11) â†’ Write (11)
Result: 11 (Expected: 12) âŒ

With Synchronization:
Thread 1: [Lock] â†’ Read (10) â†’ Increment (11) â†’ Write (11) â†’ [Unlock]
Thread 2:          [Waiting...........................] [Lock] â†’ Read (11) â†’ Increment (12) â†’ Write (12) â†’ [Unlock]
Result: 12 âœ…
```

### Conclusion ðŸŽ¯

Thread synchronization is essential for building reliable concurrent applications. By using the appropriate synchronization mechanismsâ€”from basic synchronized blocks to advanced utilities in the `java.util.concurrent` packageâ€”developers can ensure data integrity and prevent concurrency issues. ðŸ”§

Understanding the trade-offs between different synchronization techniques enables you to write high-performance multithreaded code that is both correct and scalable. Remember that while excessive synchronization can lead to contention and reduced performance, insufficient synchronization can lead to subtle and hard-to-reproduce bugs. Finding the right balance is key to successful concurrent programming. âš–ï¸

### Key Takeaways

* Thread synchronization prevents data corruption and race conditions in concurrent environments
* Synchronized methods lock the entire method, while synchronized blocks provide fine-grained control
* Volatile keyword ensures visibility of changes across threads but doesn't provide atomicity
* Atomic variables provide lock-free thread-safe operations for simple atomic operations
* Choose synchronization technique based on specific requirements: visibility, atomicity, performance
* Synchronized blocks are preferred when only part of a method needs protection
* Volatile is lightweight but only suitable for simple visibility requirements
* Atomic variables are ideal for counters and simple state management without locks
* Avoid nested locks and over-synchronization to prevent deadlocks and performance issues
* Always test concurrent code thoroughly as concurrency bugs are hard to reproduce
