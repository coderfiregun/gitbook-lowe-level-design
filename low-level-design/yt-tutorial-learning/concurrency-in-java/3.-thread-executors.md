# 3. Thread Executors

## Thread Executors

**Source:** [Original Article](https://codewitharyan.com/tech-blogs/thread-executors)

***

### Thread Executors in Java: The Power of Structured Concurrency

Thread Executors are a high-level concurrency framework in Java that provide a powerful abstraction over thread management. They simplify the complex task of creating, scheduling, and controlling threads, allowing developers to focus on business logic rather than thread lifecycle management. This article explores Thread Executors and their most critical methods for effective concurrent programming.

### Why Thread Executors?

While raw threads and thread pools offer control over concurrent operations, Thread Executors provide structured, task-based concurrency with several key advantages:

#### 1. Separation of Task Submission from Execution Details

```java
ExecutorService executor = Executors.newFixedThreadPool(3);
executor.submit(() -> {
    System.out.println("Task executed by: " + Thread.currentThread().getName());
});
```

**Explanation:** You just submit a task without worrying about creating or starting a thread‚ÄîExecutor handles it behind the scenes.

#### 2. Built-in Thread Pooling and Resource Management

```java
ExecutorService pool = Executors.newFixedThreadPool(5);
for (int i = 0; i < 10; i++) {
    pool.execute(() -> {
        System.out.println("Running: " + Thread.currentThread().getName());
    });
}
```

**Explanation:** The executor reuses the same 5 threads to run 10 tasks, preventing overhead from creating a new thread for each task.

#### 3. Task Queuing, Scheduling, and Execution Policies

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.schedule(() -> {
    System.out.println("Executed after 3 seconds!");
}, 3, TimeUnit.SECONDS);
```

**Explanation:** You can delay task execution or schedule it periodically‚Äîuseful for cron-like jobs or time-based tasks.

#### 4. Lifecycle Control and Graceful Shutdown Capabilities üõë

```java
ExecutorService executor = Executors.newCachedThreadPool();
executor.submit(() -> System.out.println("Working..."));
executor.shutdown(); // Initiates an orderly shutdown
```

**Explanation:** You can shut down the executor gracefully, allowing current tasks to complete without abruptly killing threads.

#### 5. Monitoring and Management Facilities üìä

```java
ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);

executor.submit(() -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException ignored) {
    }
});

System.out.println("Active Threads: " + executor.getActiveCount());
System.out.println("Queued Tasks: " + executor.getQueue().size());
```

**Explanation:** You get insights like active thread count and queue size to help with performance tuning and debugging.

### Core Executor Interfaces and Classes üß©

The Java concurrency framework provides several key interfaces and classes for working with Thread Executors:

#### 1. Executor: The Base Interface

The simplest interface defining task execution.

**Syntax:**

```java
Executor executor = command -> new Thread(command).start();
```

**Example:**

```java
Executor executor = command -> new Thread(command).start();
executor.execute(() -> System.out.println("Simple task executed"));
```

**Explanation:** Executor is the simplest form‚Äîjust defines an `execute(Runnable)` method. You provide a task, and it decides how to run it (in this case, a new thread).

#### 2. ExecutorService: Extended Lifecycle Management

Extends Executor with lifecycle management capabilities.

**Syntax:**

```java
ExecutorService executorService = Executors.newFixedThreadPool(int nThreads);
```

**Example:**

```java
ExecutorService executorService = Executors.newFixedThreadPool(2);
Future<String> future = executorService.submit(() -> "Hello ExecutorService");
System.out.println(future.get()); // Output: Hello ExecutorService
executorService.shutdown();
```

**Explanation:** ExecutorService allows advanced task handling with `submit()`, `invokeAll()`, `shutdown()`, and Future results for return values and tracking task completion.

#### 3. ScheduledExecutorService: Task Scheduling

Adds task scheduling capabilities.

**Syntax:**

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(int corePoolSize);
ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, 
                                       long period, TimeUnit unit);
```

**Example:**

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleAtFixedRate(() -> {
    System.out.println("Running every 2 seconds");
}, 0, 2, TimeUnit.SECONDS);
```

**Explanation:** Allows you to schedule tasks to run after a delay or at a fixed rate‚Äîideal for repeated jobs like health checks or polling.

#### 4. ThreadPoolExecutor: Primary Implementation

Primary implementation of ExecutorService.

**Syntax:**

```java
ThreadPoolExecutor customPool = new ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue
);
```

**Example:**

```java
ThreadPoolExecutor customPool = new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>()
);
customPool.execute(() -> System.out.println("Task in custom pool"));
```

**Explanation:** Gives full control‚Äîcore/max threads, queue type, keep-alive time, rejection policy. Great for performance-tuned, production-grade thread pool management.

#### 5. ScheduledThreadPoolExecutor: Scheduled Implementation

Implementation of ScheduledExecutorService.

**Syntax:**

```java
ScheduledThreadPoolExecutor scheduledPool = new ScheduledThreadPoolExecutor(int corePoolSize);
ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);
```

**Example:**

```java
ScheduledThreadPoolExecutor scheduledPool = new ScheduledThreadPoolExecutor(1);
scheduledPool.schedule(() -> System.out.println("Scheduled once"), 5, TimeUnit.SECONDS);
```

**Explanation:** A concrete subclass of ScheduledExecutorService, enabling delayed and repeated task scheduling with all thread pool tuning options.

#### 6. Executors: Factory Class

Factory class for creating executor instances.

**Syntax:**

```java
ExecutorService newFixedThreadPool(int nThreads);
ScheduledExecutorService newScheduledThreadPool(int corePoolSize);
```

**Example:**

```java
ExecutorService fixedPool = Executors.newFixedThreadPool(3);
ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(1);
```

**Explanation:** Utility class with factory methods (`newFixedThreadPool`, `newCachedThreadPool`, `newSingleThreadExecutor`, etc.) to easily spin up ready-to-use executors without complex configuration.

### Essential Methods of ExecutorService

#### Task Submission Methods üì•

**1. void execute(Runnable command)**

**Syntax:**

```java
void execute(Runnable command);
```

**Example:**

```java
// Submit a Runnable task with no result
ExecutorService executor = Executors.newFixedThreadPool(1);
executor.execute(() -> System.out.println("Task executed"));
```

**‚úÖ Success:**

* Task runs asynchronously. No result is expected or tracked.

**‚ö†Ô∏è Failure Scenarios:**

* If the task throws an exception, it's lost unless the thread is wrapped with error logging.
* You won't know if it failed, retried, or completed ‚Äî no result tracking.
* If the machine crashes or process exits, task is lost.

**2. Future\<?> submit()**

**Syntax:**

```java
// Submit a Runnable or a Callable task with a Future result
Future<?> submit(Runnable task)
Future<T> submit(Callable<T> task)
```

**Example:**

```java
// Submit a Callable task with a Future result
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<String> future = executor.submit(() -> "Hello from Callable");
```

**‚úÖ Success:**

* Returns a Future. You can block and get the result using `future.get()`.

**‚ö†Ô∏è Failure Scenarios:**

* If the task fails (e.g., throws an exception), `future.get()` will throw `ExecutionException`.
* You can still check `future.isCancelled()` or `future.isDone()`.
* If machine crashes or JVM exits ‚Äî in-flight tasks are lost.

**3. invokeAll(Collection\<? extends Callable\<T>> tasks)**

**Syntax:**

```java
List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);
List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, 
                          long timeout, TimeUnit unit);
```

**Example:**

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

// invokeAll Example
Collection<Callable<String>> allTasks = Arrays.asList(
    () -> "Task 1", 
    () -> "Task 2"
);

try {
    // Process results
    List<Future<String>> results = executor.invokeAll(allTasks);
    
    // Process with timeout
    List<Future<String>> timeoutResults = 
        executor.invokeAll(allTasks, 1, TimeUnit.SECONDS);
        
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
```

**‚úÖ Success:**

* Runs all tasks in parallel. Waits until all finish. You get a list of Futures.

**‚ö†Ô∏è Failure Scenarios:**

* If one task fails, its Future will throw an exception on `get()`, but others keep running.
* If the executor shuts down in the middle, only the remaining tasks are interrupted.
* Machine crash = all tasks in memory are lost.

#### Lifecycle Management Methods üîÑ

```java
// Initiate an orderly shutdown
void shutdown()

// Attempt to stop all actively executing tasks
List<Runnable> shutdownNow()
```

> **Note:** For the above methods implementation refer to the Previous Article of **Thread Pool and Thread Lifecycle**

#### Scheduled Executor Service Methods ‚è∞

**1. schedule(Runnable command, long delay, TimeUnit unit)**

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.schedule(() -> System.out.println("Run once later"), 2, TimeUnit.SECONDS);
```

**‚úÖ Success:**

* Schedules a task to run once after a delay.

**‚ö†Ô∏è Failure Scenarios:**

* If the task throws an exception, it won't run again.
* Lost completely if the system crashes before the delay elapses.
* No built-in retry logic.

**2. scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)**

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
// Schedule a task to run periodically at a fixed rate
scheduler.scheduleAtFixedRate(() -> System.out.println("Repeats"), 
                              1, 3, TimeUnit.SECONDS);
```

**‚úÖ Success:**

* Runs repeatedly with a fixed rate between task starts (not finishes).

**‚ö†Ô∏è Failure Scenarios:**

* If a task throws an exception, it stops future executions.
* If a task takes longer than the rate interval, it may overlap (depending on thread pool size).
* Crashes = all schedules lost unless you persist them externally.

### Creating Executors with the Executors Factory üè≠

```java
// Fixed thread pool with a specified number of threads
ExecutorService fixedPool = Executors.newFixedThreadPool(nThreads);

// Single-threaded executor
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();

// Cached thread pool that creates new threads as needed
ExecutorService cachedPool = Executors.newCachedThreadPool();

// Scheduled executor with a specified pool size
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(corePoolSize);
```

#### Common Executor Types

| Type                     | Best For              | Characteristics                                 |
| ------------------------ | --------------------- | ----------------------------------------------- |
| **FixedThreadPool**      | Predictable workloads | Fixed number of threads, bounded resource usage |
| **CachedThreadPool**     | Short-lived tasks     | Creates threads as needed, reuses idle threads  |
| **SingleThreadExecutor** | Sequential execution  | Guarantees order, single thread                 |
| **ScheduledThreadPool**  | Periodic tasks        | Supports delayed and repeated execution         |

### ThreadPoolExecutor Configuration Parameters

When more control is needed, the ThreadPoolExecutor class can be directly instantiated with specific parameters:

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize,      // Minimum number of threads to keep alive
    maximumPoolSize,   // Maximum number of threads allowed
    keepAliveTime,     // Time to keep non-core threads alive when idle
    timeUnit,          // Unit for keepAliveTime
    workQueue,         // Queue for holding tasks before execution
    threadFactory,     // Factory for creating new threads
    rejectionHandler   // Handler for rejected tasks
);
```

#### Configuration Parameters Explained

| Parameter            | Description                         | Typical Values                          |
| -------------------- | ----------------------------------- | --------------------------------------- |
| **corePoolSize**     | Minimum threads kept alive          | Number of CPU cores                     |
| **maximumPoolSize**  | Maximum threads allowed             | 2x CPU cores for I/O tasks              |
| **keepAliveTime**    | Idle time before thread termination | 60 seconds                              |
| **workQueue**        | Queue for pending tasks             | LinkedBlockingQueue, ArrayBlockingQueue |
| **threadFactory**    | Custom thread creation              | For naming, daemon status               |
| **rejectionHandler** | Policy when queue is full           | AbortPolicy, CallerRunsPolicy           |

### Interview Questions üéØ

#### 1. What's the difference between execute() and submit() methods?

**Answer:** `execute()` accepts only Runnable tasks and doesn't return any result. `submit()` accepts both Runnable and Callable tasks and returns a Future object that can be used to retrieve results or check completion status.

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

executor.execute(() -> System.out.println("Runnable executed"));

Future<Integer> future = executor.submit(() -> 42);
System.out.println("Callable result: " + future.get());

executor.shutdown();
```

**Output:**

```
Runnable executed
Callable result: 42
```

#### 2. How does ThreadPoolExecutor decide whether to create a new thread or queue a task?

**Answer:** It follows this sequence:

1. If fewer than `corePoolSize` threads are running, create a new thread.
2. If `corePoolSize` or more threads are running, add the task to the queue.
3. If the queue is full and fewer than `maximumPoolSize` threads are running, create a new thread.
4. If the queue is full and `maximumPoolSize` threads are running, reject the task.

**Syntax:**

```java
ThreadPoolExecutor customPool = new ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue
);
```

**Example:**

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 1, TimeUnit.SECONDS, new LinkedBlockingQueue<>(2)
);
```

#### 3. What happens if you don't explicitly shut down an ExecutorService?

**Answer:** The executor's threads will continue running, preventing the JVM from shutting down normally (unless they're daemon threads). This can cause memory leaks and resource exhaustion. Always call `shutdown()` or `shutdownNow()` when done with an executor. üõë

#### 4. What is the difference between scheduleAtFixedRate and scheduleWithFixedDelay methods?

**Answer:**

* **`scheduleAtFixedRate`** attempts to execute tasks at a consistent rate regardless of how long each task takes (tasks might overlap if execution takes longer than the period).
* **`scheduleWithFixedDelay`** waits for the specified delay time after each task completes before starting the next execution.

**Syntax:**

```java
ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, 
                                       long period, TimeUnit unit);
ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, 
                                          long delay, TimeUnit unit);
```

**Example:**

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

scheduler.scheduleAtFixedRate(() -> System.out.println("Fixed Rate Task"), 
                              0, 2, TimeUnit.SECONDS);

scheduler.scheduleWithFixedDelay(() -> System.out.println("Fixed Delay Task"), 
                                 0, 2, TimeUnit.SECONDS);
```

**Visual Comparison:**

```
scheduleAtFixedRate:
Time: 0s    2s    4s    6s    8s
Task: |-----|-----|-----|-----|
      Start Start Start Start Start
      (regardless of completion time)

scheduleWithFixedDelay:
Time: 0s    2s      4s      6s      8s
Task: |-----|       |-----|       |-----|
      Start Wait2s  Start Wait2s  Start
      (waits after completion)
```

#### 5. How can you handle exceptions thrown by tasks submitted to an ExecutorService?

**Answer:** For `submit()` methods, exceptions are stored in the returned Future and thrown when calling `get()`.

**Option 1: Catch via Future.get()**

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(() -> {
    throw new RuntimeException("Boom!");
});

try {
    future.get(); // Will throw ExecutionException wrapping the original
} catch (ExecutionException e) {
    System.out.println("Caught: " + e.getCause()); // prints: Boom!
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
```

**Why:** `submit()` captures exceptions in the returned Future. Calling `get()` will throw an `ExecutionException`.

**Option 2: Try-catch inside the task**

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(() -> {
    try {
        throw new RuntimeException("Handled inside task");
    } catch (Exception e) {
        System.out.println("Caught in task: " + e.getMessage());
    }
});
```

**Why:** Always the safest fallback. Catch exceptions inside the task to log or recover locally.

### Method Comparison Summary

| Method                       | Return Type     | Accepts               | Exception Handling          | Use Case                     |
| ---------------------------- | --------------- | --------------------- | --------------------------- | ---------------------------- |
| **execute()**                | void            | Runnable              | Lost unless caught          | Fire and forget tasks        |
| **submit()**                 | Future          | Runnable/Callable     | Via Future.get()            | Tasks with results           |
| **invokeAll()**              | List\<Future>   | Collection\<Callable> | Via individual Future.get() | Parallel batch processing    |
| **schedule()**               | ScheduledFuture | Runnable/Callable     | Via Future.get()            | Delayed execution            |
| **scheduleAtFixedRate()**    | ScheduledFuture | Runnable              | Stops on exception          | Periodic tasks (fixed rate)  |
| **scheduleWithFixedDelay()** | ScheduledFuture | Runnable              | Stops on exception          | Periodic tasks (fixed delay) |

### Best Practices üëç

1. **Always Shutdown Executors:** Use `shutdown()` or `shutdownNow()` to prevent resource leaks
2. **Choose the Right Pool Type:** Match pool type to workload characteristics
3. **Handle Exceptions Properly:** Don't let exceptions be silently swallowed
4. **Set Appropriate Pool Sizes:** Core pool size ‚âà CPU cores, max pool size for bursts
5. **Configure Rejection Policies:** Handle cases when the pool is saturated
6. **Monitor Pool Metrics:** Track active threads, queue size, and task completion
7. **Use Timeouts:** Prevent indefinite blocking with timeout versions of methods
8. **Name Your Threads:** Use custom ThreadFactory for easier debugging

### Conclusion üéØ

Thread Executors represent a significant advancement in Java concurrency programming, abstracting away the complexities of direct thread manipulation while providing powerful tools for task management and execution control. By understanding the core interfaces, essential methods, and best practices outlined in this article, developers can create robust, efficient concurrent applications that fully leverage modern hardware capabilities while maintaining predictable behavior and resource usage.

As applications grow in complexity and scale, mastering Thread Executors becomes increasingly important for delivering responsive, resilient software systems. Whether handling asynchronous operations, scheduling recurring tasks, or processing parallel workloads, Thread Executors provide the structured approach needed for successful concurrent programming in Java.

### Key Takeaways

* Thread Executors provide high-level abstraction over thread management
* ExecutorService is the primary interface for task submission and lifecycle management
* `submit()` returns Future for result tracking, `execute()` is fire-and-forget
* ScheduledExecutorService enables delayed and periodic task execution
* Always shutdown executors to prevent resource leaks and JVM hanging
* Choose pool type based on workload: Fixed for CPU-bound, Cached for I/O-bound
* `scheduleAtFixedRate` vs `scheduleWithFixedDelay` differ in timing calculation
* Exception handling requires using Future.get() or try-catch within tasks
* ThreadPoolExecutor provides fine-grained control over pool behavior
* Factory methods in Executors class simplify common executor creation patterns
