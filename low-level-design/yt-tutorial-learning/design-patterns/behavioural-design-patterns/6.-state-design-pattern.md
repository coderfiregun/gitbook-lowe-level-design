# 6. State Design Pattern

## State Design Pattern

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/state-design-pattern)

### Unlocking the Power of the State Design Pattern in Java

#### Introduction to the State Design Pattern

Imagine walking into a theater where the lights change seamlessly from red to green to yellow, guiding your actions without you even thinking about it. Each color signals a different behavior, ensuring everything runs smoothly.

In the world of software development, this seamless transition and behavior change based on internal states is beautifully handled by the **State Design Pattern**. It's like giving your objects their own set of "moods" that dictate how they behave in different situations, making your code more organized, flexible, and easier to maintain.

***

### Why Is It Named the State Design Pattern?

The **State Design Pattern** gets its name from its core functionality: managing the **state** of an object. Just like a traffic light has different states (red, green, yellow) that determine its behavior, the State Pattern allows an object to alter its behavior when its internal state changes.

**Key Concept:** This pattern encapsulates state-specific behaviors into separate classes, promoting cleaner code and better organization.

**Real-World Analogy:**

* Traffic light states (red, green, yellow)
* Media player states (playing, paused, stopped)
* Document states (draft, review, published)

***

### A Real-World Scenario: Traffic Light System

Let's dive into a practical example to see the State Design Pattern in action. Consider a **traffic light system**. A traffic light can be in one of three states:

* **Red** üî¥: Cars must stop
* **Green** üü¢: Cars can go
* **Yellow** üü°: Cars should slow down and prepare to stop

Each state dictates different behaviors and transitions. Managing these states efficiently in code ensures that our traffic light system remains scalable and easy to maintain.

***

### Solving the Scenario Traditionally

Before introducing the State Design Pattern, let's see how we'd handle this using a traditional approach with conditional statements.

#### Traditional Approach Without State Pattern

Here's a simple Java implementation of a traffic light system without using the State Design Pattern:

```java
public class TrafficLight {
    private String color;
    
    public TrafficLight() {
        this.color = "RED"; // start with red
    }
    
    public void next() {
        if (color.equals("RED")) {
            color = "GREEN";
            System.out.println("Light changed from RED to GREEN. Cars go!");
        } else if (color.equals("GREEN")) {
            color = "YELLOW";
            System.out.println("Light changed from GREEN to YELLOW. Slow down!");
        } else if (color.equals("YELLOW")) {
            color = "RED";
            System.out.println("Light changed from YELLOW to RED. Stop!");
        }
    }
    
    public String getColor() {
        return color;
    }
}

public class TrafficLightTest {
    public static void main(String[] args) {
        TrafficLight trafficLight = new TrafficLight();
        trafficLight.next(); // from RED to GREEN
        trafficLight.next(); // from GREEN to YELLOW
        trafficLight.next(); // from YELLOW to RED
    }
}
```

**Output:**

```
Light changed from RED to GREEN. Cars go!
Light changed from GREEN to YELLOW. Slow down!
Light changed from YELLOW to RED. Stop!
```

**In this setup:**

* The `TrafficLight` class manages its state using a simple color string
* The `next()` method uses if-else statements to transition between states

***

### Interviewer's Follow-Up Questions

Imagine you're in a job interview discussing this implementation. The interviewer might ask:

#### Question 1: What if we add a new state like BLINKING or MAINTENANCE mode?

Would you need to modify the existing `next()` method?

#### Question 2: How would you handle more complex transitions based on time or external events?

How would you keep the code maintainable?

#### Question 3: Can you easily extend this system without modifying the existing TrafficLight class?

Does it follow the Open/Closed Principle?

These questions highlight potential issues with the traditional approach, especially as the system grows in complexity.

***

### The Ugly Code When It Grows

Let's say we decide to add two more states: **BLINKING** (for night mode) and **MAINTENANCE** (when the light is under repair). Our `TrafficLight` class starts to get messy with more if-else conditions.

```java
public class TrafficLight {
    private String color;
    
    public TrafficLight() {
        this.color = "RED";
    }
    
    public void next() {
        if (color.equals("RED")) {
            color = "GREEN";
            System.out.println("Change to GREEN. Cars go!");
        } else if (color.equals("GREEN")) {
            color = "YELLOW";
            System.out.println("Change to YELLOW. Slow down!");
        } else if (color.equals("YELLOW")) {
            color = "RED";
            System.out.println("Change to RED. Stop!");
        } else if (color.equals("BLINKING")) {
            color = "MAINTENANCE";
            System.out.println("Switching to MAINTENANCE mode...");
        } else if (color.equals("MAINTENANCE")) {
            color = "RED";
            System.out.println("Maintenance done, back to RED!");
        }
        // Potentially more states and conditions...
    }
    
    public String getColor() {
        return color;
    }
}
```

***

### Issues with the Traditional Approach

#### 1. Tight Coupling

The `TrafficLight` class is tightly coupled with all possible states.

#### 2. Scalability Problems

Adding new states requires modifying the `next()` method, leading to a bloated method.

#### 3. Maintenance Nightmare

Each new state adds more complexity, making the code hard to read and maintain.

#### 4. Violation of Open/Closed Principle

The class isn't closed for modification; every change requires altering existing code.

**Problems Summary:**

| Issue                   | Impact                                           |
| ----------------------- | ------------------------------------------------ |
| **Long if-else chains** | Method becomes bloated and hard to read          |
| **State explosion**     | Adding states increases complexity exponentially |
| **Tight coupling**      | All states in one class                          |
| **Hard to test**        | Testing all state transitions difficult          |
| **Violates SRP**        | Class has multiple responsibilities              |
| **Violates OCP**        | Must modify for each new state                   |

***

### Introducing Our Savior: The State Design Pattern ü¶∏‚ôÇÔ∏è

To combat the chaos of the traditional approach, we introduce the **State Design Pattern**. This pattern allows an object to alter its behavior when its internal state changes by delegating state-specific behaviors to separate classes.

**Benefits:**

* Promotes cleaner code
* Easier maintenance
* Better scalability

***

### Solving the Problem Using the State Design Pattern

Let's refactor our traffic light system using the State Design Pattern. We'll create separate state classes for each color, each handling its own transition logic.

***

### Step-by-Step Code Implementation

#### 1. State Interface

First, define a `State` interface that outlines the behavior for each state.

```java
// State Interface
interface TrafficLightState {
    void next(TrafficLightContext context);
    String getColor();
}
```

**Explanation:**

* Defines common interface for all states
* `next()` method handles state transitions
* `getColor()` returns current state identifier

***

#### 2. Concrete States üåà

Next, implement concrete state classes for each traffic light color: `RedState`, `GreenState`, and `YellowState`.

**RedState**

```java
// Concrete State: Red
class RedState implements TrafficLightState {
    @Override
    public void next(TrafficLightContext context) {
        System.out.println("Switching from RED to GREEN. Cars go!");
        context.setState(new GreenState());
    }
    
    @Override
    public String getColor() {
        return "RED";
    }
}
```

**GreenState**

```java
// Concrete State: Green
class GreenState implements TrafficLightState {
    @Override
    public void next(TrafficLightContext context) {
        System.out.println("Switching from GREEN to YELLOW. Slow down!");
        context.setState(new YellowState());
    }
    
    @Override
    public String getColor() {
        return "GREEN";
    }
}
```

**YellowState**

```java
// Concrete State: Yellow
class YellowState implements TrafficLightState {
    @Override
    public void next(TrafficLightContext context) {
        System.out.println("Switching from YELLOW to RED. Stop!");
        context.setState(new RedState());
    }
    
    @Override
    public String getColor() {
        return "YELLOW";
    }
}
```

**Key Points:**

* Each state class implements `TrafficLightState` interface
* Each state's `next()` method defines the transition to the next state
* Encapsulates state-specific behavior and transitions

***

#### 3. Context Class üé≠

Create a `Context` class that maintains a reference to the current state and delegates state-specific behavior to the current state.

```java
// Context Class
class TrafficLightContext {
    private TrafficLightState currentState;
    
    public TrafficLightContext() {
        currentState = new RedState(); // Start with RED
    }
    
    public void setState(TrafficLightState state) {
        this.currentState = state;
    }
    
    public void next() {
        currentState.next(this);
    }
    
    public String getColor() {
        return currentState.getColor();
    }
}
```

**Explanation:**

* Holds a reference to the current state
* Delegates the `next()` call to the current state
* Provides a method to change the current state (`setState`)

***

#### 4. Driver Code üèÅ

Finally, set up the traffic light system and simulate state transitions.

```java
// Driver Class
public class TrafficLightTest {
    public static void main(String[] args) {
        TrafficLightContext trafficLight = new TrafficLightContext();
        trafficLight.next(); // RED -> GREEN
        trafficLight.next(); // GREEN -> YELLOW
        trafficLight.next(); // YELLOW -> RED
        trafficLight.next(); // RED -> GREEN
        // Adding new states like BLINKING or MAINTENANCE is easy now
    }
}
```

**Output:**

```
Switching from RED to GREEN. Cars go!
Switching from GREEN to YELLOW. Slow down!
Switching from YELLOW to RED. Stop!
Switching from RED to GREEN. Cars go!
```

***

### Breaking Down the State Pattern Implementation

#### State Interface (TrafficLightState)

* Defines the `next()` method to transition to the next state
* `getColor()` returns the current state's color

#### Concrete States (RedState, GreenState, YellowState)

* Each state implements the `TrafficLightState` interface
* Each state's `next()` method defines the transition to the next state
* Encapsulates state-specific behavior and transitions

#### Context Class (TrafficLightContext)

* Holds a reference to the current state
* Delegates the `next()` call to the current state
* Provides a method to change the current state (`setState`)

#### Driver Class (TrafficLightTest)

* Initializes the traffic light context
* Simulates state transitions by calling `next()`

***

### Relationships Illustrated

#### Component Relationships

| Component           | Role                                | Example                                 |
| ------------------- | ----------------------------------- | --------------------------------------- |
| **State Interface** | Defines state behavior              | `TrafficLightState`                     |
| **Concrete States** | Implement specific state behavior   | `RedState`, `GreenState`, `YellowState` |
| **Context**         | Maintains current state             | `TrafficLightContext`                   |
| **Client**          | Uses context to trigger transitions | `TrafficLightTest`                      |

#### Structure

```
Client (TrafficLightTest)
    ‚Üì uses
Context (TrafficLightContext)
    ‚Üì maintains
State (TrafficLightState)
    ‚Üë implements
ConcreteStates (RedState, GreenState, YellowState)
```

**Relationships:**

* **Inheritance:** `RedState`, `GreenState`, and `YellowState` implement the `TrafficLightState` interface
* **Association:** `TrafficLightContext` has a `TrafficLightState`

***

### Handling Interview Follow-Up Questions with the State Pattern üó£Ô∏è

Revisiting those interviewer's questions, let's see how the State Design Pattern addresses them:

#### Question 1: What if we add a new state like BLINKING or MAINTENANCE?

**State Pattern Solution:** Simply create a new class (e.g., `BlinkingState`) that implements the `TrafficLightState` interface and define its transition logic. No changes needed in existing classes.

```java
// Concrete State: Blinking
class BlinkingState implements TrafficLightState {
    @Override
    public void next(TrafficLightContext context) {
        System.out.println("Switching from BLINKING to MAINTENANCE mode...");
        context.setState(new MaintenanceState());
    }
    
    @Override
    public String getColor() {
        return "BLINKING";
    }
}

// Concrete State: Maintenance
class MaintenanceState implements TrafficLightState {
    @Override
    public void next(TrafficLightContext context) {
        System.out.println("Maintenance done, back to RED!");
        context.setState(new RedState());
    }
    
    @Override
    public String getColor() {
        return "MAINTENANCE";
    }
}
```

**Result:** New states added without modifying existing code!

***

#### Question 2: How would you handle more complex transitions based on time or external events?

**State Pattern Solution:** Each state class can incorporate its own logic to handle time-based transitions or respond to external events. This keeps the transition logic localized within each state.

```java
// Example: Adding time-based behavior in GreenState
class GreenState implements TrafficLightState {
    @Override
    public void next(TrafficLightContext context) {
        // Imagine some timer logic here
        System.out.println("Switching from GREEN to YELLOW after timer.");
        context.setState(new YellowState());
    }
    
    @Override
    public String getColor() {
        return "GREEN";
    }
}
```

**Advanced Example with Timer:**

```java
class GreenState implements TrafficLightState {
    private long startTime;
    
    public GreenState() {
        this.startTime = System.currentTimeMillis();
    }
    
    @Override
    public void next(TrafficLightContext context) {
        long elapsed = System.currentTimeMillis() - startTime;
        if (elapsed >= 30000) { // 30 seconds
            System.out.println("GREEN timer expired, switching to YELLOW.");
            context.setState(new YellowState());
        } else {
            System.out.println("GREEN light still active.");
        }
    }
    
    @Override
    public String getColor() {
        return "GREEN";
    }
}
```

***

#### Question 3: Can you easily extend this system without modifying the existing TrafficLight class?

**State Pattern Solution:** Yes! The `TrafficLight` class (context) remains unchanged. Adding new states involves creating new state classes without touching the existing ones, adhering to the **Open/Closed Principle**.

**Example:**

```java
// Just add new state class - no changes to existing code!
class FlashingRedState implements TrafficLightState {
    @Override
    public void next(TrafficLightContext context) {
        System.out.println("Emergency! Switching to all-way stop.");
        context.setState(new RedState());
    }
    
    @Override
    public String getColor() {
        return "FLASHING_RED";
    }
}
```

***

### Comparison: Before and After State Pattern

| Aspect                | Traditional Approach         | State Pattern                        |
| --------------------- | ---------------------------- | ------------------------------------ |
| **Adding State**      | Modify `next()` method       | Create new state class               |
| **Code Organization** | All logic in one place       | Distributed across state classes     |
| **Complexity**        | Grows linearly with states   | Remains constant per state           |
| **Maintainability**   | Difficult - one large method | Easy - small focused classes         |
| **Testing**           | Hard - test entire method    | Easy - test each state independently |
| **Open/Closed**       | Violated - modify existing   | Followed - extend without modifying  |
| **Readability**       | Poor - long if-else chains   | Excellent - clear state classes      |

***

### Day-to-Day Use Cases and Examples üåç

The State Design Pattern is versatile and widely applicable. Here are some everyday examples:

#### 1. Media Players üéµ

Handling different states like **Playing**, **Paused**, **Stopped**, and **Fast Forwarding**. Each state dictates how the player responds to user inputs.

**Example:**

```java
interface PlayerState {
    void play(MediaPlayer player);
    void pause(MediaPlayer player);
    void stop(MediaPlayer player);
}

class PlayingState implements PlayerState {
    public void play(MediaPlayer player) {
        System.out.println("Already playing");
    }
    public void pause(MediaPlayer player) {
        System.out.println("Pausing playback");
        player.setState(new PausedState());
    }
    public void stop(MediaPlayer player) {
        System.out.println("Stopping playback");
        player.setState(new StoppedState());
    }
}
```

***

#### 2. Vending Machines ü•§

Managing states like **NoCoin**, **HasCoin**, **Dispensing**, and **SoldOut**. Each state determines the machine's response to user actions.

**Example:**

```java
interface VendingMachineState {
    void insertCoin(VendingMachine machine);
    void ejectCoin(VendingMachine machine);
    void selectProduct(VendingMachine machine);
}

class NoCoinState implements VendingMachineState {
    public void insertCoin(VendingMachine machine) {
        System.out.println("Coin inserted");
        machine.setState(new HasCoinState());
    }
    // ... other methods
}
```

***

#### 3. Document Workflows üìÑ

Handling states like **Draft**, **Review**, **Published**, and **Archived**. Each state controls what actions can be performed on the document.

**Example:**

```java
interface DocumentState {
    void edit(Document doc);
    void publish(Document doc);
    void archive(Document doc);
}

class DraftState implements DocumentState {
    public void edit(Document doc) {
        System.out.println("Editing draft");
    }
    public void publish(Document doc) {
        System.out.println("Publishing document");
        doc.setState(new PublishedState());
    }
    // ... other methods
}
```

***

#### 4. Game Characters üéÆ

Managing states like **Idle**, **Running**, **Jumping**, and **Attacking**. Each state defines the character's behavior and possible transitions.

**Example:**

```java
interface CharacterState {
    void move(Character character);
    void jump(Character character);
    void attack(Character character);
}

class IdleState implements CharacterState {
    public void move(Character character) {
        System.out.println("Starting to run");
        character.setState(new RunningState());
    }
    public void jump(Character character) {
        System.out.println("Jumping from idle");
        character.setState(new JumpingState());
    }
    // ... other methods
}
```

***

#### 5. TCP Connection States

Managing connection states like **Closed**, **Listen**, **Established**, and **CloseWait**.

**Example:**

```java
interface TCPState {
    void open(TCPConnection connection);
    void close(TCPConnection connection);
    void acknowledge(TCPConnection connection);
}
```

***

### When to Use State Pattern

#### Use State When:

1. **Object behavior depends on state** - Behavior changes based on internal state
2. **Many conditional statements** - Lots of if-else or switch based on state
3. **State transitions are complex** - Multiple states with complex transition logic
4. **State-specific operations** - Different states require different implementations
5. **Open/Closed compliance needed** - Want to add states without modifying existing code

#### Don't Use State When:

1. **Simple state transitions** - Only 2-3 simple states
2. **No state-specific behavior** - States don't affect behavior significantly
3. **Overkill** - Pattern adds unnecessary complexity
4. **Performance critical** - Object creation overhead is problematic

***

### Advantages of Using the State Design Pattern üåà

#### 1. Cleaner Code

Eliminates complex if-else or switch statements by encapsulating state-specific behaviors.

**Before:** 50-line method with nested if-else\
**After:** Multiple 10-line state classes

***

#### 2. Enhanced Maintainability

Adding new states or modifying existing ones is straightforward without altering the core logic.

**Impact:** Changes isolated to specific state classes

***

#### 3. Promotes Single Responsibility Principle

Each state class handles its own behavior, making classes easier to understand and manage.

**Result:** Small, focused classes with clear purpose

***

#### 4. Improved Scalability

Easily extend the system with new states without increasing the complexity of existing classes.

**Growth:** Linear complexity instead of exponential

***

#### 5. Encapsulation of State-Specific Logic

Each state class contains only the logic relevant to that state, promoting better organization.

**Benefit:** Clear separation of concerns

***

### Key Components Summary

#### State Interface

Declares methods that all concrete states must implement.

#### Concrete State

Implements behavior associated with a specific state.

#### Context

Maintains reference to current state and delegates requests to it.

#### Client

Interacts with context to trigger state transitions.

***

### Best Practices

1. **Keep states focused** - Each state handles only its own behavior
2. **Use enums for state types** - When state identification is needed
3. **Consider state transitions** - Document valid transitions
4. **Handle invalid transitions** - Gracefully handle unexpected state changes
5. **Thread safety** - Consider synchronization in multithreaded environments
6. **State persistence** - Consider how to save/restore state
7. **Avoid God State** - Don't let one state know too much about others

**Invalid Transition Example:**

```java
class PausedState implements PlayerState {
    public void pause(MediaPlayer player) {
        System.out.println("Already paused!");
        // Stay in current state
    }
}
```

***

### State vs. Strategy Pattern

| Aspect          | State                                   | Strategy                               |
| --------------- | --------------------------------------- | -------------------------------------- |
| **Purpose**     | Change behavior based on internal state | Change algorithm/strategy              |
| **Transitions** | States transition between each other    | Strategies are independent             |
| **Awareness**   | States know about transitions           | Strategies don't know about each other |
| **Control**     | Context or states control transitions   | Client chooses strategy                |
| **Use Case**    | Traffic lights, workflows               | Sorting algorithms, payment methods    |

***

### Summary

The State Design Pattern is a powerful tool in your software design arsenal, enabling you to manage an object's behavior based on its internal state seamlessly.

#### Key Takeaways

**Core Concept:**

* Allow object to alter behavior when state changes
* Encapsulate state-specific behaviors in separate classes
* Context delegates to current state object

**Benefits:**

* **Cleaner Code** - No complex conditionals
* **Enhanced Maintainability** - Easy to modify states
* **SRP Compliance** - Each state has single responsibility
* **Improved Scalability** - Easy to add new states
* **Better Organization** - State logic encapsulated

**Structure:**

1. State Interface - Defines state behavior
2. Concrete States - Implement specific state behavior
3. Context - Maintains current state reference
4. Client - Triggers state transitions

**Real-World Uses:**

* Traffic light systems
* Media players
* Vending machines
* Document workflows
* Game character states
* Network protocols

***

### Conclusion

The State Design Pattern is a powerful tool in your software design arsenal, enabling you to manage an object's behavior based on its internal state seamlessly. By encapsulating state-specific behaviors into separate classes, you not only keep your code clean and organized but also make it highly adaptable to change.

Whether you're building:

* Traffic systems üö¶
* Media players üéµ
* Complex workflows üìÑ
* Game mechanics üéÆ

The State Pattern ensures your code remains maintainable and scalable.

**Remember:** Next time you find yourself tangled in a web of conditional statements, remember the State Design Pattern‚Äîyour friendly neighborhood hero ready to bring order and clarity to your code!

By mastering the State Pattern, you gain the ability to:

* Handle complex state machines elegantly
* Write maintainable and extensible code
* Follow SOLID principles naturally
* Create systems that are easy to understand and modify

Happy coding! üòÑüéâ

***

### Next Steps

Continue your learning journey by exploring:

* Strategy Pattern (related but different purpose)
* Chain of Responsibility (passes requests along)
* Command Pattern (encapsulates requests)
* State machines and finite automata theory
* State pattern in game development
* Advanced state transition validation
