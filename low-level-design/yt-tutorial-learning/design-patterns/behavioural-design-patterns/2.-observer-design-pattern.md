# 2. Observer Design Pattern

## Observer Design Pattern

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/observer-design-pattern)

### Observer Design Pattern: How to Stay Updated Without Constantly Checking

Imagine you're watching your favorite YouTube channel. Every time they upload a new video, you get a notification. You don't have to keep checking the channel to see if there's something new. Instead, you get notified automatically when they post.

**This is exactly how the Observer Design Pattern works in software.**

In programming, the **Observer Pattern** allows one object (the subject) to notify other objects (the observers) whenever there is a change in its state. This is great for systems where certain parts of your application need to stay updated in real-time but shouldn't be tightly coupled to each other.

***

### Why Is It Called the Observer Pattern?

The name **Observer** comes from the fact that some parts of the program (observers) are **"watching"** another part (subject) for changes. When something changes in the subject (for example, a new video is posted on YouTube), all the observers are notified.

**Key Concept:** This keeps everything in sync without directly linking the two parts. So, the observers observe the subject for changes and react accordingly.

**Real-World Analogy:**

* Subject = YouTube Channel
* Observers = Subscribers
* Notification = Update when new video is posted

***

### Solving the Problem Using the Traditional Method

Let's imagine a scenario where you have a YouTube channel, and you want to notify your subscribers every time a new video is uploaded. The traditional way to solve this problem could involve manually checking for updates each time.

Let's write some code for this traditional approach. Here, the `YouTubeChannel` is the subject, and `YouTubeSubscriber` is the observer.

```java
import java.util.ArrayList;
import java.util.List;

class YouTubeChannel {
    private List<String> subscribers = new ArrayList<>();
    private String video;

    // Method to add a new subscriber
    public void addSubscriber(String subscriber) {
        subscribers.add(subscriber);
    }

    // Method to upload a new video
    public void uploadNewVideo(String video) {
        this.video = video;
        notifySubscribers(); // Notify all subscribers about the new video
    }

    // Notify all subscribers
    public void notifySubscribers() {
        for (String subscriber : subscribers) {
            System.out.println("Notifying " + subscriber + " about new video: " + video);
        }
    }
}

class YouTubeSubscriber {
    private String name;
    
    public YouTubeSubscriber(String name) {
        this.name = name;
    }
    
    public void subscribe(YouTubeChannel channel) {
        channel.addSubscriber(name);
    }
    
    public void watchVideo(YouTubeChannel channel) {
        System.out.println(name + " is watching the video: " + channel.video);
    }
}
```

**Output:**

```
Notifying Alice about new video: Java Tutorial
Notifying Bob about new video: Java Tutorial
```

***

### Why Is This Approach Not Ideal? üòï

#### 1. Manual Checking

In this approach, we manually notify each subscriber every time a new video is uploaded. If there are hundreds of subscribers, this becomes cumbersome.

#### 2. Not Scalable

Adding a new notification method (e.g., email, SMS) requires modifying the `YouTubeChannel` class, which leads to tight coupling and difficult maintenance.

#### 3. Hard to Extend

If we wanted to add more observers (for example, send notifications through an app), we would have to touch the `YouTubeChannel` class, breaking the **open/closed principle**.

**Problems Summary:**

| Issue                    | Impact                                           |
| ------------------------ | ------------------------------------------------ |
| **Manual Notification**  | Cumbersome with many subscribers                 |
| **Tight Coupling**       | Channel knows about all notification types       |
| **Hard to Extend**       | Must modify channel for new notification methods |
| **Not Scalable**         | Grows linearly with notification types           |
| **Violates Open/Closed** | Must modify existing code to extend              |

***

### Interviewer's Questions: What's Wrong with This?

Now, an interviewer might ask:

#### Question 1: What happens if you have a lot of subscribers?

The code could get messy and slow down because you are doing everything manually.

#### Question 2: What if we need to add a new feature like sending notifications by email?

You would need to modify the `YouTubeChannel` class and update the logic everywhere, which increases complexity.

***

### The Ugly Code: When Things Start to Break Down

As you can see, this approach doesn't scale well. With each new feature, we would need to keep adding new lines of code in the `notifySubscribers()` method. Here's how the ugly code might look when we add email notifications:

```java
public void notifySubscribers() {
    for (String subscriber : subscribers) {
        System.out.println("Notifying " + subscriber + " about new video: " + video);
        // Add new feature: send an email notification
        sendEmail(subscriber);
    }
}

public void sendEmail(String subscriber) {
    System.out.println("Sending email to " + subscriber);
}
```

**Problems:**

#### Code Duplication

Every time we add a new feature, like email notifications, we're repeating logic in the `YouTubeChannel` class.

#### Hard to Maintain

As we add more notification types (SMS, Push notifications), this class will get bloated and hard to maintain.

**What if we add more notification types?**

```java
public void notifySubscribers() {
    for (String subscriber : subscribers) {
        System.out.println("Notifying " + subscriber);
        sendEmail(subscriber);
        sendSMS(subscriber);
        sendPushNotification(subscriber);
        // More and more methods...
    }
}
```

This becomes a nightmare! üò±

***

### The Observer Design Pattern Explained in Detail

Now that we've introduced the Observer Design Pattern, let's break it down step by step to understand how it works, how it improves our solution, and how to use it with multiple users (observers) watching the same subject (YouTube channel).

We will take you through interfaces, classes, and the driver code in simple terms, just like we are explaining to a friend!

***

### 1. The Observer Interface

In the Observer Design Pattern, the **Observer** is the one that reacts to the changes (like a subscriber reacting to a new video). To make this pattern work, we create an interface called `Subscriber`.

The job of this interface is to define what methods a subscriber (observer) should have. In our case, the `update()` method is the one we use to notify a subscriber when something happens (like a new video).

```java
public interface Subscriber {
    void update(String video); // This is the method the observer will use to get updated with the new video
}
```

**Key Point:** `update(String video)` - This method is called when the `YouTubeChannel` uploads a new video. Each observer (subscriber) will implement this method to decide how they should react to the update (e.g., watching the video).

***

### 2. Concrete Observer Class

Now, let's create a class for the `YouTubeSubscriber`, which implements the `Subscriber` interface. When a new video is uploaded, this class will print a message saying that the subscriber is watching the new video.

```java
public class YouTubeSubscriber implements Subscriber {
    private String name; // Name of the subscriber

    public YouTubeSubscriber(String name) {
        this.name = name; // Initialize the subscriber with their name
    }

    @Override
    public void update(String video) {
        // When notified, this method will execute, and the subscriber watches the new video
        System.out.println(name + " is watching the video: " + video);
    }
}
```

**Here, the `YouTubeSubscriber` class:**

* Takes the name of the subscriber when created
* Implements the `update()` method to react when a new video is uploaded

***

### Solving the Problem in the Ugly Code - Observer Classes

Instead of having all logic inside the `notifySubscribers()` method, we define **separate observer classes** for each notification type:

#### Email Subscriber

```java
public class EmailSubscriber implements Subscriber {
    private String email;
    
    public EmailSubscriber(String email) {
        this.email = email;
    }

    @Override
    public void update(String video) {
        System.out.println("Sending email to " + email + ": New video uploaded: " + video);
    }
}
```

#### Push Notification Subscriber

```java
public class PushNotificationSubscriber implements Subscriber {
    private String userDevice;
    
    public PushNotificationSubscriber(String userDevice) {
        this.userDevice = userDevice;
    }

    @Override
    public void update(String video) {
        System.out.println("Sending push notification to " + userDevice
                + ": New video uploaded: " + video);
    }
}
```

**Benefits:** Here, we have two different observers: one for email notifications and another for push notifications. Each observer is responsible for notifying the user in a way that suits them.

***

### 3. The Subject Interface üó£Ô∏è

The **Subject** is the one that changes. In our case, it's the `YouTubeChannel` (the channel posting videos). The `YouTubeChannel` needs to keep track of all its subscribers and notify them when something changes (like uploading a new video).

We create a `YouTubeChannel` interface to define the methods required for any channel:

```java
public interface YouTubeChannel {
    void addSubscriber(Subscriber subscriber);    // Method to add a new subscriber
    void removeSubscriber(Subscriber subscriber); // Method to remove a subscriber
    void notifySubscribers();                     // Method to notify all subscribers
}
```

**Methods:**

* `addSubscriber(Subscriber subscriber)`: Adds a new subscriber to the channel
* `removeSubscriber(Subscriber subscriber)`: Removes a subscriber from the channel
* `notifySubscribers()`: Notifies all the subscribed users about the new video

***

### 4. Concrete Subject Class

Now, we create the concrete class for the subject, which is the actual `YouTubeChannel` that manages the subscribers and uploads the videos. This class will keep track of all the subscribers and notify them when a new video is uploaded.

```java
import java.util.ArrayList;
import java.util.List;

public class YouTubeChannelImpl implements YouTubeChannel {
    private List<Subscriber> subscribers = new ArrayList<>(); // List of subscribers
    private String video; // The video that will be uploaded

    @Override
    public void addSubscriber(Subscriber subscriber) {
        subscribers.add(subscriber); // Add a subscriber to the channel
    }

    @Override
    public void removeSubscriber(Subscriber subscriber) {
        subscribers.remove(subscriber); // Remove a subscriber from the channel
    }

    @Override
    public void notifySubscribers() {
        // Notify all subscribers about the new video
        for (Subscriber subscriber : subscribers) {
            subscriber.update(video); // Call update() for each subscriber
        }
    }

    public void uploadNewVideo(String video) {
        this.video = video; // Set the video that is being uploaded
        notifySubscribers(); // Notify all subscribers about the new video
    }
}
```

**In this class:**

* We use a `List<Subscriber>` to store all subscribers who are interested in receiving updates
* The `uploadNewVideo()` method is used to set the new video and call `notifySubscribers()` to alert all the observers about the new video

***

### 5. Driver Code: Putting It All Together

Now, let's use all the classes we've created and run the program. We will have a `YouTubeChannel`, a couple of subscribers, and upload a new video. The subscribers will get updated and react to the new video.

```java
public class Main {
    public static void main(String[] args) {
        // Create a YouTube channel
        YouTubeChannelImpl channel = new YouTubeChannelImpl();

        // Create subscribers
        YouTubeSubscriber alice = new YouTubeSubscriber("Alice");
        YouTubeSubscriber bob = new YouTubeSubscriber("Bob");

        // Subscribe to the channel
        channel.addSubscriber(alice);
        channel.addSubscriber(bob);

        // Upload a new video and notify subscribers
        channel.uploadNewVideo("Java Design Patterns Tutorial");
        
        // Output:
        // Alice is watching the video: Java Design Patterns Tutorial
        // Bob is watching the video: Java Design Patterns Tutorial

        // You can also remove a subscriber and upload another video
        channel.removeSubscriber(bob);
        channel.uploadNewVideo("Observer Pattern in Action");
        
        // Output:
        // Alice is watching the video: Observer Pattern in Action
    }
}
```

**Output:**

```
Alice is watching the video: Java Design Patterns Tutorial
Bob is watching the video: Java Design Patterns Tutorial
Alice is watching the video: Observer Pattern in Action
```

***

### Here's What Happens in the Code

#### 1. Creating the Channel and Subscribers

We create the `YouTubeChannelImpl` and `YouTubeSubscriber` objects.

#### 2. Subscribing to the Channel

Both Alice and Bob subscribe to the `YouTubeChannelImpl`.

#### 3. Uploading a Video

When a new video is uploaded via `uploadNewVideo()`, both subscribers are notified and will "watch" the video by executing their `update()` method.

#### 4. Unsubscribing a Subscriber

Bob unsubscribes, and when a new video is uploaded, only Alice is notified.

***

### Complete Example with Multiple Observer Types

Let's see how easy it is to add different types of notifications:

```java
public class Main {
    public static void main(String[] args) {
        // Create a YouTube channel
        YouTubeChannelImpl channel = new YouTubeChannelImpl();

        // Create different types of subscribers
        YouTubeSubscriber alice = new YouTubeSubscriber("Alice");
        EmailSubscriber emailSub = new EmailSubscriber("bob@example.com");
        PushNotificationSubscriber pushSub = new PushNotificationSubscriber("iPhone12");

        // Subscribe to the channel
        channel.addSubscriber(alice);
        channel.addSubscriber(emailSub);
        channel.addSubscriber(pushSub);

        // Upload a new video - all observers notified
        channel.uploadNewVideo("Observer Pattern Explained");
    }
}
```

**Output:**

```
Alice is watching the video: Observer Pattern Explained
Sending email to bob@example.com: New video uploaded: Observer Pattern Explained
Sending push notification to iPhone12: New video uploaded: Observer Pattern Explained
```

**Notice:** We added new notification types without modifying the `YouTubeChannelImpl` class!

***

### Structure Explanation

#### 1. Main Class

* Acts as the driver code
* Creates the `YouTubeChannelImpl` and `YouTubeSubscriber` instances
* Adds/removes subscribers and triggers video uploads

#### 2. Subscriber Interface

* Represents the **Observer** in the pattern
* Defines the `update(video: String)` method that all subscribers must implement

#### 3. YouTubeSubscriber Class

* Implements the `Subscriber` interface
* Reacts to video updates by displaying a message

#### 4. YouTubeChannel Interface

* Represents the **Subject** in the pattern
* Defines methods to add, remove, and notify subscribers

#### 5. YouTubeChannelImpl Class

* Implements `YouTubeChannel`
* Manages a list of subscribers and notifies them when a new video is uploaded

#### 6. Relationships

* **Inheritance:** `YouTubeSubscriber` and `YouTubeChannelImpl` implement their respective interfaces
* **Aggregation:** `YouTubeChannelImpl` maintains a list of `Subscriber` objects
* **Usage:** The `Main` class interacts with the system to demonstrate the pattern

This demonstrates the Observer Pattern with a YouTube-like notification system.

***

### Advantages of the Observer Pattern

#### 1. Decoupling üéØ

The `YouTubeChannel` doesn't need to know what each observer does. It just notifies them about the update.

**Before:** Channel knows about email, SMS, push notifications\
**After:** Channel only knows about generic observers

***

#### 2. Scalability üìà

Adding new types of observers (e.g., email, SMS) is as simple as implementing the `Subscriber` interface.

**Before:** Modify channel for each new notification type\
**After:** Just create new observer class

***

#### 3. Flexibility

Observers can join or leave at any time without affecting the `YouTubeChannel`.

**Dynamic subscription management:**

* Add observers at runtime
* Remove observers at runtime
* No impact on subject

***

#### 4. Maintainability üîß

The `YouTubeChannel` stays clean and simple, while the observers handle their own logic.

**Separation of concerns:**

* Subject manages state and notifications
* Observers handle their own reactions

***

### Comparison: Before and After Observer Pattern

| Aspect                       | Traditional Approach            | Observer Pattern                     |
| ---------------------------- | ------------------------------- | ------------------------------------ |
| **Adding Notification Type** | Modify YouTubeChannel class     | Create new observer class            |
| **Coupling**                 | Tight - channel knows all types | Loose - channel knows interface only |
| **Scalability**              | Poor - linear growth in channel | Excellent - independent observers    |
| **Maintainability**          | Hard - one bloated class        | Easy - separate concerns             |
| **Flexibility**              | Limited - hardcoded logic       | High - dynamic subscription          |
| **Open/Closed Principle**    | Violated                        | Followed                             |
| **Testing**                  | Difficult - tightly coupled     | Easy - mock observers                |

***

### Real-Life Use Cases for the Observer Pattern üåç

#### 1. Social Media Notifications

When someone you follow posts something, you get a notification.

**Example:**

```java
SocialMediaPost post = new InstagramPost();
post.addFollower(new User("Alice"));
post.addFollower(new EmailNotifier("bob@example.com"));
post.publish("New photo!");
```

***

#### 2. Stock Market Alerts

When stock prices change, you are notified.

**Example:**

```java
Stock apple = new Stock("AAPL");
apple.addObserver(new MobileApp());
apple.addObserver(new EmailAlert());
apple.setPrice(150.00); // All observers notified
```

***

#### 3. Weather Apps

The app notifies you about weather changes.

**Example:**

```java
WeatherStation station = new WeatherStation();
station.addObserver(new PhoneDisplay());
station.addObserver(new WebDisplay());
station.setTemperature(25); // All displays updated
```

***

#### 4. Message Systems

When a new message arrives, all subscribers are notified.

**Example:**

```java
ChatRoom room = new ChatRoom();
room.addParticipant(new User("Alice"));
room.addParticipant(new User("Bob"));
room.sendMessage("Hello everyone!"); // All notified
```

***

#### 5. Event Handling Systems

GUI frameworks, event-driven architectures.

**Example:**

```java
Button button = new Button();
button.addClickListener(new SaveHandler());
button.addClickListener(new LogHandler());
button.click(); // All handlers execute
```

***

### When to Use Observer Pattern

#### Use Observer When:

1. **One-to-many dependency** - One object's change affects many others
2. **Loose coupling needed** - Objects shouldn't know about each other
3. **Dynamic subscription** - Observers can subscribe/unsubscribe at runtime
4. **Event systems** - Building event-driven architectures
5. **Broadcasting** - Need to broadcast changes to multiple listeners

#### Don't Use Observer When:

1. **Simple updates** - Just one or two objects need updating
2. **Performance critical** - Notifying many observers can be slow
3. **Complex dependencies** - Observer order matters (use Mediator instead)
4. **Memory leaks risk** - Must carefully manage observer lifecycle

***

### Key Components

| Component             | Role                                    | Example                                |
| --------------------- | --------------------------------------- | -------------------------------------- |
| **Subject**           | Maintains observers, notifies on change | `YouTubeChannelImpl`                   |
| **Observer**          | Receives updates from subject           | `Subscriber` interface                 |
| **Concrete Observer** | Implements observer behavior            | `YouTubeSubscriber`, `EmailSubscriber` |
| **ConcreteSubject**   | Stores state, triggers notifications    | `YouTubeChannelImpl`                   |

***

### Observer Pattern Variants

#### Push Model (Used in Our Example)

Subject pushes all data to observers:

```java
subscriber.update(video); // Push data to observer
```

**Pros:** Observers don't need to query\
**Cons:** May send unnecessary data

#### Pull Model

Observers pull data they need from subject:

```java
public interface Subscriber {
    void update(YouTubeChannel channel); // Pass subject reference
}

// Observer pulls what it needs
public void update(YouTubeChannel channel) {
    String video = channel.getLatestVideo();
    System.out.println("Watching: " + video);
}
```

**Pros:** Observers get only what they need\
**Cons:** Observers must know subject interface

***

### Best Practices

1. **Use interfaces** - Define Subject and Observer as interfaces
2. **Avoid memory leaks** - Unsubscribe when observers are no longer needed
3. **Consider weak references** - For automatic cleanup
4. **Document notification order** - If order matters
5. **Handle exceptions** - Don't let one observer's exception affect others
6. **Thread safety** - Synchronize if used in multithreading
7. **Avoid circular dependencies** - Observer shouldn't trigger subject updates

**Exception Handling Example:**

```java
public void notifySubscribers() {
    for (Subscriber subscriber : subscribers) {
        try {
            subscriber.update(video);
        } catch (Exception e) {
            // Log error but continue with other subscribers
            System.err.println("Error notifying subscriber: " + e.getMessage());
        }
    }
}
```

***

### Summary

The Observer Design Pattern is an excellent way to implement notification systems in software.

#### Key Takeaways

**Core Concept:**

* Define one-to-many dependency
* When subject changes, all observers notified automatically
* Observers and subject are loosely coupled

**Benefits:**

* **Decoupling** - Subject and observers independent
* **Scalability** - Easy to add new observers
* **Flexibility** - Dynamic subscription/unsubscription
* **Maintainability** - Clean separation of concerns

**Structure:**

1. Subject - Maintains observers list
2. Observer - Receives notifications
3. Concrete Subject - Implements subject behavior
4. Concrete Observers - Implement observer behavior

**Real-World Uses:**

* Event handling systems
* News feeds and notifications
* Stock market applications
* Weather monitoring
* Model-View-Controller (MVC)

***

### Conclusion: Observer Pattern in Action üèÜ

The Observer Design Pattern is an excellent way to implement notification systems in software. It helps keep things decoupled, modular, and scalable.

Whether it's:

* YouTube notifications üì∫
* Stock market updates üìà
* Weather changes üå§Ô∏è
* Social media feeds üì±
* Event systems üéØ

The Observer pattern is a simple and efficient way to keep your system's components updated without the headache of direct dependencies.

**Remember:** The Observer pattern is all about:

* One object (subject) notifying many objects (observers)
* Loose coupling between subject and observers
* Dynamic subscription management
* Following the Open/Closed Principle

By mastering the Observer Pattern, you gain a powerful tool for building flexible, maintainable event-driven systems.

***

### Next Steps

Continue your learning journey by exploring:

* Mediator Pattern (centralized communication)
* Publish-Subscribe Pattern (observer variant)
* Event-driven architecture
* Reactive programming (RxJava, ReactiveX)
* Observer pattern in GUI frameworks
* Memory management in observer systems
