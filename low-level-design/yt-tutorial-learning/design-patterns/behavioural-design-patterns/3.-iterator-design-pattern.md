# 3. Iterator Design Pattern

## Iterator Design Pattern

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/iterator-design-pattern)

### Introduction to the Iterator Design Pattern

The **Iterator Design Pattern** is a behavioral design pattern that allows us to traverse a collection of objects (like arrays or lists) without exposing the underlying implementation details.

**Real-World Analogy:** Think of it as a tour guide showing you around a museum: instead of telling you how the exhibits are arranged, the guide simply takes you through the rooms one by one, in an easy-to-follow order.

In software development, this pattern is extremely useful when we want to access elements in a collection (like a list or a set) sequentially without exposing the complexity of the collection itself. It decouples the way we access elements from the collection's underlying data structure, allowing us to write cleaner, more maintainable code.

***

### Real-Life Scenario: Playlist Iterator

Let's imagine you are building a **music streaming app**, and one of the features is a playlist. Users can add songs to their playlists, and they should be able to iterate through their playlist to listen to each song one by one.

Now, let's say we have different types of playlists, such as:

* A **simple playlist** where songs are added in a particular order
* A **random playlist** where songs are shuffled
* A **favorites playlist** showing only favorite songs

Instead of writing custom code for iterating over each type of playlist, the Iterator Design Pattern will allow us to abstract the iteration logic and provide a unified way to access elements.

***

### Why is it Named the Iterator Design Pattern?

The name **Iterator** comes from the fact that this pattern allows us to **iterate over elements** of a collection. The main purpose of the pattern is to provide a way to sequentially access each element in the collection, without exposing its underlying structure or implementation.

**Key Concept:**

* **Iterate** = Go through elements one by one
* **Design Pattern** = Reusable solution to a common problem
* **Result** = Clean, maintainable way to traverse collections

***

### Solving the Problem Using the Traditional Method

Let's say you have a simple playlist class, and you want to iterate over the songs using the traditional approach. Here's how you might do it:

```java
import java.util.ArrayList;

public class Playlist {
    private ArrayList<String> songs;
    
    public Playlist() {
        songs = new ArrayList<>();
    }
    
    public void addSong(String song) {
        songs.add(song);
    }
    
    public void playPlaylist() {
        for (int i = 0; i < songs.size(); i++) {
            System.out.println("Playing song: " + songs.get(i));
        }
    }
}
```

**In the above code:**

* We have a simple playlist with songs
* We loop through the list of songs using a `for` loop in the `playPlaylist()` method

**But here's the problem:** As we add more functionality (e.g., adding shuffle functionality or filtering songs), this code will quickly become hard to maintain. Every time we want to change how we iterate through the playlist, we'll need to modify the `playPlaylist()` method.

***

### Interviewer's Follow-Up Questions

An interviewer might ask:

#### Question 1: What if we add more types of playlists in the future?

Such as shuffle or repeat modes?

#### Question 2: How will the iteration change with different types of collections?

Such as a shuffled playlist or a playlist with a repeat function?

As you can see, the traditional approach quickly starts to break down as more features are added. We have a lot of duplicated logic in the `playPlaylist()` method and need to modify it each time we add a new feature.

***

### The Ugly Code: When Things Start to Break Down

Now, let's see how things get ugly when we start adding new features. Here's an example of what the code might look like when we add a shuffle feature:

```java
public class Playlist {
    private ArrayList<String> songs;
    
    public Playlist() {
        songs = new ArrayList<>();
    }
    
    public void addSong(String song) {
        songs.add(song);
    }
    
    public void playPlaylist(boolean shuffle) {
        if (shuffle) {
            // Shuffle the songs and then play
            System.out.println("Shuffling playlist...");
            // Shuffle logic here...
        } else {
            for (int i = 0; i < songs.size(); i++) {
                System.out.println("Playing song: " + songs.get(i));
            }
        }
    }
}
```

**Problems:**

Now, the `playPlaylist()` method has become cluttered with additional functionality for shuffling. If we want to add more features, like repeat functionality or filtering songs, the method will become even messier.

| Issue                | Impact                                   |
| -------------------- | ---------------------------------------- |
| **Method Bloat**     | One method doing too many things         |
| **Hard to Maintain** | Must modify method for each new feature  |
| **Code Duplication** | Similar iteration logic repeated         |
| **Violates SRP**     | Class responsible for multiple behaviors |
| **Not Extensible**   | Hard to add new iteration types          |

***

### Introducing Our Savior: The Iterator Design Pattern ü¶∏‚ôÇÔ∏è

Now, let's solve this problem using the **Iterator Design Pattern**! Instead of directly modifying the `playPlaylist()` method, we will define an iterator to abstract the iteration logic. This will allow us to easily add new functionality without modifying the core logic of the `Playlist` class.

***

### Solving the Problem Using the Iterator Design Pattern

Let's create multiple iterators to show how the Iterator Design Pattern can handle different types of playlists. We'll add a **Shuffled Playlist Iterator** and a **Favorites Playlist Iterator** in addition to the **Simple Playlist Iterator** and demonstrate how each iterator can be used to iterate over different types of playlists.

***

### 1. The Iterator Interface

This interface defines the basic methods that any iterator will need to implement. `hasNext()` checks if there are more songs, and `next()` returns the next song in the playlist.

```java
public interface PlaylistIterator {
    boolean hasNext();
    String next();
}
```

**Methods:**

* `hasNext()` - Returns `true` if there are more elements to iterate
* `next()` - Returns the next element and advances the iterator

***

### 2. Concrete Iterators

We'll create three different iterators for different playlist types: Simple Playlist, Shuffled Playlist, and Favorites Playlist.

***

#### 2.1. Simple Playlist Iterator

```java
public class SimplePlaylistIterator implements PlaylistIterator {
    private Playlist playlist;
    private int index;
    
    public SimplePlaylistIterator(Playlist playlist) {
        this.playlist = playlist;
        this.index = 0;
    }
    
    @Override
    public boolean hasNext() {
        return index < playlist.getSongs().size();
    }
    
    @Override
    public String next() {
        return playlist.getSongs().get(index++);
    }
}
```

**Purpose:** This iterator goes through the playlist in the order the songs were added.

**How it works:**

* Maintains an index to track current position
* Returns songs in sequential order
* Simple, straightforward iteration

***

#### 2.2. Shuffled Playlist Iterator üîÄ

```java
import java.util.Collections;
import java.util.ArrayList;

public class ShuffledPlaylistIterator implements PlaylistIterator {
    private Playlist playlist;
    private int index;
    private ArrayList<String> shuffledSongs;
    
    public ShuffledPlaylistIterator(Playlist playlist) {
        this.playlist = playlist;
        this.shuffledSongs = new ArrayList<>(playlist.getSongs());
        Collections.shuffle(shuffledSongs); // Shuffle the songs randomly
        this.index = 0;
    }
    
    @Override
    public boolean hasNext() {
        return index < shuffledSongs.size();
    }
    
    @Override
    public String next() {
        return shuffledSongs.get(index++);
    }
}
```

**Purpose:** This iterator shuffles the playlist and then iterates over the songs in a random order.

**How it works:**

* Creates a copy of the songs list
* Shuffles the copy using `Collections.shuffle()`
* Iterates through the shuffled list

***

#### 2.3. Favorites Playlist Iterator ‚ù§Ô∏è

```java
public class FavoritesPlaylistIterator implements PlaylistIterator {
    private Playlist playlist;
    private int index;
    
    public FavoritesPlaylistIterator(Playlist playlist) {
        this.playlist = playlist;
        this.index = 0;
    }
    
    @Override
    public boolean hasNext() {
        // Only return the next song if it's marked as a favorite
        while (index < playlist.getSongs().size()) {
            if (playlist.getSongs().get(index).contains("Fav")) { // Mark favorites with 'Fav' in name
                return true;
            }
            index++;
        }
        return false;
    }
    
    @Override
    public String next() {
        return playlist.getSongs().get(index++);
    }
}
```

**Purpose:** This iterator only iterates over songs that have been marked as favorites (we mark favorites with "Fav" in the song name for simplicity).

**How it works:**

* Skips non-favorite songs
* Only returns songs containing "Fav"
* Filters during iteration

***

### 3. The Playlist Class üé∂

Now, let's update the `Playlist` class to accommodate all the different iterators.

```java
import java.util.ArrayList;

public class Playlist {
    private ArrayList<String> songs;
    
    public Playlist() {
        songs = new ArrayList<>();
    }
    
    public void addSong(String song) {
        songs.add(song);
    }
    
    public PlaylistIterator iterator(String type) {
        switch (type) {
            case "simple":
                return new SimplePlaylistIterator(this);
            case "shuffled":
                return new ShuffledPlaylistIterator(this);
            case "favorites":
                return new FavoritesPlaylistIterator(this);
            default:
                return null;
        }
    }
    
    public ArrayList<String> getSongs() {
        return songs;
    }
}
```

**Key Point:** The `Playlist` class has been updated to support different types of iterators based on the type passed as a parameter ("simple", "shuffled", or "favorites").

***

### 4. Driver Code: Putting It All Together

Now, let's see how these iterators work with different types of playlists.

```java
public class Main {
    public static void main(String[] args) {
        // Create a playlist
        Playlist playlist = new Playlist();
        playlist.addSong("Song 1");
        playlist.addSong("Song 2 Fav");
        playlist.addSong("Song 3");
        playlist.addSong("Song 4 Fav");
        playlist.addSong("Song 5");

        // Simple Playlist Iterator
        System.out.println("Simple Playlist:");
        PlaylistIterator simpleIterator = playlist.iterator("simple");
        while (simpleIterator.hasNext()) {
            System.out.println("Playing: " + simpleIterator.next());
        }

        // Shuffled Playlist Iterator
        System.out.println("\nShuffled Playlist:");
        PlaylistIterator shuffledIterator = playlist.iterator("shuffled");
        while (shuffledIterator.hasNext()) {
            System.out.println("Playing: " + shuffledIterator.next());
        }

        // Favorites Playlist Iterator
        System.out.println("\nFavorites Playlist:");
        PlaylistIterator favoritesIterator = playlist.iterator("favorites");
        while (favoritesIterator.hasNext()) {
            System.out.println("Playing: " + favoritesIterator.next());
        }
    }
}
```

***

### Output

```
Simple Playlist:
Playing: Song 1
Playing: Song 2 Fav
Playing: Song 3
Playing: Song 4 Fav
Playing: Song 5

Shuffled Playlist:
Playing: Song 4 Fav
Playing: Song 1
Playing: Song 2 Fav
Playing: Song 5
Playing: Song 3

Favorites Playlist:
Playing: Song 2 Fav
Playing: Song 4 Fav
```

***

### Explanation

#### The PlaylistIterator Interface

The common interface that all iterators implement (`SimplePlaylistIterator`, `ShuffledPlaylistIterator`, and `FavoritesPlaylistIterator`).

#### The Playlist Class

Uses the `PlaylistIterator` to provide iteration behavior.

#### Each Concrete Iterator

(`SimplePlaylistIterator`, `ShuffledPlaylistIterator`, and `FavoritesPlaylistIterator`) implements the `PlaylistIterator` interface and provides its specific iteration logic.

#### The Playlist Class Contains

A list of songs (`songs`) and provides an `iterator` method to choose the appropriate iterator based on the type.

***

### Key Benefits of Using the Iterator Pattern

#### 1. Flexibility

We can now easily add new types of playlists (like shuffled or favorites) without changing the `Playlist` class itself. The iterators are responsible for the specific logic of how to iterate.

**Before:** Modify Playlist class for each iteration type\
**After:** Just create new iterator class

***

#### 2. Separation of Concerns

The logic for iterating over a playlist is separated from the playlist itself, which makes the code cleaner and easier to maintain.

**Separation:**

* Playlist = Data management
* Iterator = Traversal logic

***

#### 3. Scalability

Adding new playlist types (like a `RecentlyPlayedPlaylistIterator` or `TopRatedPlaylistIterator`) is easy and doesn't require any modifications to the existing playlist structure.

**Example - Adding New Iterator:**

```java
public class RecentlyPlayedIterator implements PlaylistIterator {
    // Only shows songs played in last 24 hours
    // Implementation...
}

// Usage - no changes to Playlist class needed!
PlaylistIterator recent = playlist.iterator("recent");
```

***

### Comparison: Before and After Iterator Pattern

| Aspect                    | Traditional Approach        | Iterator Pattern                    |
| ------------------------- | --------------------------- | ----------------------------------- |
| **Adding Iteration Type** | Modify Playlist class       | Create new iterator class           |
| **Code Organization**     | All logic in one place      | Separated concerns                  |
| **Maintainability**       | Hard - one bloated class    | Easy - focused classes              |
| **Extensibility**         | Poor - modify existing code | Excellent - add new iterators       |
| **Testing**               | Difficult - coupled logic   | Easy - test iterators independently |
| **Complexity**            | High - grows with features  | Low - distributed across iterators  |

***

### How Does Java Use the Iterator Design Pattern? ü§©

Java takes full advantage of the Iterator Design Pattern with its built-in `Iterator` interface. Whenever you work with collections like `ArrayList`, `HashSet`, or `HashMap`, Java automatically provides an iterator for you. This is the same Iterator Design Pattern you've heard of‚Äîmaking your life easier and your code cleaner.

**Here's how Java's built-in Iterator works with the Iterator Design Pattern:**

#### 1. hasNext()

This method checks if there are more elements to iterate over.

#### 2. next()

This method returns the next element in the collection and moves the cursor forward.

#### 3. remove()

If you want to remove the current element during iteration, this method does the trick.

With this simple interface, Java lets you loop through collections easily and efficiently without caring about the internal implementation of the collection (whether it's a linked list or array-based).

***

### A Real Example Using Java Iterators üçéüçåüçä

Let's look at a quick example of how the Iterator Design Pattern is used in Java. We'll iterate over a simple list of fruits:

```java
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorExample {
    public static void main(String[] args) {
        ArrayList<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");
        
        Iterator<String> iterator = fruits.iterator(); // Using Iterator to access the list
        
        while (iterator.hasNext()) {
            System.out.println(iterator.next()); // Access the next element in the collection
        }
    }
}
```

**Output:**

```
Apple
Banana
Orange
```

**In this example, we have:**

* `ArrayList` as our collection of fruits
* The `Iterator` allows us to traverse through the elements in the collection (fruit names) sequentially, one by one
* By calling `iterator.hasNext()` and `iterator.next()`, we can access each element without worrying about how the `ArrayList` is implemented

***

### Real-Life Use Cases of the Iterator Pattern

#### 1. Database Records

Iterating over a result set in a database query.

**Example:**

```java
ResultSet rs = statement.executeQuery("SELECT * FROM users");
while (rs.next()) { // Iterator pattern
    String name = rs.getString("name");
}
```

***

#### 2. Menu Items in Applications

Iterating through menu items in a GUI (e.g., navigating through options).

**Example:**

```java
Iterator<MenuItem> menuIterator = menu.iterator();
while (menuIterator.hasNext()) {
    MenuItem item = menuIterator.next();
    item.render();
}
```

***

#### 3. Game Object Iteration

Iterating over game objects (like characters or items) in a game loop.

**Example:**

```java
Iterator<GameObject> gameObjects = scene.getObjects();
while (gameObjects.hasNext()) {
    gameObjects.next().update();
}
```

***

#### 4. File System Traversal

Navigating through directories and files.

**Example:**

```java
DirectoryIterator iterator = new DirectoryIterator(rootFolder);
while (iterator.hasNext()) {
    File file = iterator.next();
    processFile(file);
}
```

***

#### 5. Pagination

Iterating through pages of data.

**Example:**

```java
PageIterator<User> pages = userService.getPaginatedUsers();
while (pages.hasNext()) {
    List<User> currentPage = pages.next();
    displayUsers(currentPage);
}
```

***

### When to Use Iterator Pattern

#### Use Iterator When:

1. **Collection traversal needed** - Need to access elements sequentially
2. **Hide implementation** - Don't want to expose internal structure
3. **Multiple traversal algorithms** - Different ways to iterate same collection
4. **Uniform interface** - Want consistent way to iterate different collections
5. **Complex data structures** - Trees, graphs, custom collections

#### Don't Use Iterator When:

1. **Simple arrays** - Basic loop is sufficient
2. **Single traversal method** - Only one way to iterate
3. **Direct access needed** - Need random access to elements
4. **Overhead not justified** - Pattern adds unnecessary complexity

***

### Key Components

| Component               | Role                          | Example                                              |
| ----------------------- | ----------------------------- | ---------------------------------------------------- |
| **Iterator Interface**  | Defines traversal interface   | `PlaylistIterator`                                   |
| **Concrete Iterator**   | Implements specific traversal | `SimplePlaylistIterator`, `ShuffledPlaylistIterator` |
| **Aggregate Interface** | Defines iterator creation     | `Playlist`                                           |
| **Concrete Aggregate**  | Creates concrete iterators    | `Playlist` implementation                            |

***

### Iterator Pattern Structure

```
Client
   ‚Üì
Aggregate (Playlist)
   ‚Üì
creates
   ‚Üì
Iterator (PlaylistIterator)
   ‚Üì
implements
   ‚Üì
ConcreteIterator (SimplePlaylistIterator, ShuffledPlaylistIterator)
```

***

### Best Practices

1. **Implement Iterator interface** - Use standard interface when possible
2. **Fail-fast behavior** - Detect concurrent modifications
3. **Don't expose internals** - Iterator shouldn't reveal collection structure
4. **Support remove() carefully** - If mutable iteration is needed
5. **Consider immutability** - Make iterators immutable when possible
6. **Document iteration order** - Clear documentation of traversal order
7. **Use enhanced for-loop** - When Java collections are used

**Fail-Fast Example:**

```java
public class SafeIterator implements PlaylistIterator {
    private int expectedModCount;
    
    public SafeIterator(Playlist playlist) {
        this.expectedModCount = playlist.getModCount();
    }
    
    @Override
    public String next() {
        if (expectedModCount != playlist.getModCount()) {
            throw new ConcurrentModificationException();
        }
        return playlist.getSongs().get(index++);
    }
}
```

***

### Advanced: External vs. Internal Iterators

#### External Iterator (Our Example)

Client controls iteration:

```java
PlaylistIterator iterator = playlist.iterator("simple");
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

**Pros:** More control, can pause/resume\
**Cons:** More verbose

#### Internal Iterator

Collection controls iteration:

```java
playlist.forEach(song -> System.out.println(song));
```

**Pros:** Simpler, more concise\
**Cons:** Less control

***

### Summary

The Iterator Design Pattern is an excellent way to make your code more clean, scalable, and flexible.

#### Key Takeaways

**Core Concept:**

* Provides way to access elements sequentially
* Hides underlying collection implementation
* Uniform interface for different collections

**Benefits:**

* **Flexibility** - Easy to add new iteration types
* **Separation of Concerns** - Iteration logic separate from collection
* **Scalability** - Add new iterators without modifying collection
* **Uniformity** - Same interface for different collections

**Structure:**

1. Iterator Interface - Defines traversal methods
2. Concrete Iterators - Implement specific traversal logic
3. Aggregate - Provides iterator
4. Client - Uses iterator to traverse

**Real-World Uses:**

* Java Collections Framework
* Database result sets
* File system traversal
* Menu navigation
* Game object iteration

***

### Conclusion

The Iterator Design Pattern is an excellent way to make your code more clean, scalable, and flexible. By using iterators, we can easily manage how we access elements in a collection, without cluttering the core logic with specific iteration strategies.

It helps keep your codebase modular and ready for growth, especially when you need to add new ways of accessing elements in your collections.

**Remember:** The Iterator pattern is about:

* Sequential access to collection elements
* Hiding collection implementation details
* Providing uniform traversal interface
* Supporting multiple traversal algorithms

By mastering the Iterator Pattern, you gain a powerful tool for creating flexible, maintainable collection traversal mechanisms.

***

### Next Steps

Continue your learning journey by exploring:

* Composite Pattern (tree structures)
* Visitor Pattern (operations on elements)
* Java Streams API (functional iteration)
* Custom iterators for complex data structures
* Iterator pattern in different programming languages
* Performance considerations for iterators
