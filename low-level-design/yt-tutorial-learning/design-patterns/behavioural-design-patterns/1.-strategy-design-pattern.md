# 1. Strategy Design Pattern

## Strategy Design Pattern

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/strategy-design-pattern)

### Strategy Design Pattern: A Real-Life Example in Software Engineering

When it comes to software development, **flexibility** and **scalability** are key factors in building systems that can evolve over time without becoming unmanageable. The Strategy Design Pattern is a powerful tool that enables software engineers to achieve just that by allowing different algorithms or behaviors to be selected dynamically at runtime.

***

### Introduction to the Strategy Pattern

In simple terms, the **Strategy Pattern** allows you to define a family of algorithms or behaviors, and choose the one to use during runtime. It is like having a **toolbox** ðŸ§° where you can pick the best tool (or strategy) for the task at hand.

This approach:

* Avoids hardcoding multiple behaviors into one class
* Promotes flexibility by separating behavior logic into different classes
* Makes code more maintainable and extensible

***

#### Why is it Called the Strategy Pattern?

The name **Strategy** comes from the idea of different strategies to solve the same problem (in this case, processing payments). Each strategy encapsulates a different way to process payments, and we can switch between them dynamically based on user input or system requirements.

**Real-World Analogy:**

* Just like a general chooses different battle strategies based on the situation
* Or a coach selects different game plans based on the opponent
* The Strategy pattern lets you choose the best approach for the current context

This makes the system more flexible and easier to extend.

***

### Real-Life Scenario: Payment Processing in E-commerce

Imagine you're developing an **e-commerce platform** where users can make purchases using various payment methods like:

* Credit Cards ðŸ’³
* PayPal
* Cryptocurrency ðŸª™

Each payment method has its own unique processing logic.

#### The Problem

Without the Strategy Pattern, you'd likely have a large, monolithic class with many `if-else` or `switch` statements, checking for the payment method and executing the specific logic for each one.

**But what happens when you need to add another payment method?**

* Like Apple Pay
* Or Stripe
* Or Google Pay

It becomes a nightmare to manage and extend! ðŸ˜±

***

### The Traditional Approach: Payment Processing

#### Step 1: The Problem â€“ Different Payment Methods

We start with a `PaymentProcessor` class. This class will check the payment method (Credit Card, PayPal, or Crypto) and handle the payment accordingly.

Now, we don't want to keep writing a bunch of different methods for each payment method, so we try using an `if-else` block to determine the payment method and process it. But we need to change this block every time we add a new payment method.

**Code Example: Traditional Payment Processor**

```java
public class PaymentProcessor {
    // This method will process payment based on payment method type
    public void processPayment(String paymentMethod) {
        if (paymentMethod.equals("CreditCard")) {
            // Process Credit Card payment
            System.out.println("Processing credit card payment...");
        } else if (paymentMethod.equals("PayPal")) {
            // Process PayPal payment
            System.out.println("Processing PayPal payment...");
        } else if (paymentMethod.equals("Crypto")) {
            // Process Crypto payment
            System.out.println("Processing crypto payment...");
        } else {
            // If an unsupported payment method is entered
            System.out.println("Payment method not supported.");
        }
    }
}
```

**Output:**

```
Processing credit card payment...
Processing PayPal payment...
Processing crypto payment...
```

***

#### How It Works

* We have a single method called `processPayment()`
* Inside the method, we check what type of payment method the user has selected using `if-else` statements
* For each payment method (Credit Card, PayPal, or Crypto), we print a message

***

#### What Happens When We Want to Add a New Payment Method?

Let's say you now want to add a new payment method, like **Stripe**.

If we were using the above approach, we'd have to modify the `processPayment()` method like this:

```java
public class PaymentProcessor {
    // This method will process payment based on payment method type
    public void processPayment(String paymentMethod) {
        if (paymentMethod.equals("CreditCard")) {
            // Process Credit Card payment
            System.out.println("Processing credit card payment...");
        } else if (paymentMethod.equals("PayPal")) {
            // Process PayPal payment
            System.out.println("Processing PayPal payment...");
        } else if (paymentMethod.equals("Crypto")) {
            // Process Crypto payment
            System.out.println("Processing crypto payment...");
        } else if (paymentMethod.equals("Stripe")) { // New method added
            // Process Stripe payment
            System.out.println("Processing Stripe payment...");
        } else {
            // If an unsupported payment method is entered
            System.out.println("Payment method not supported.");
        }
    }
}
```

***

#### What's Wrong with This?

Here's where the problem comes in:

**1. Adding New Payment Methods**

Every time you want to add a new payment method, you have to go into the `processPayment()` method and modify the code.

**2. Code Duplication**

We keep repeating similar blocks of code for each payment method, which can get messy when we add more and more methods.

**3. Scalability Issues**

As you keep adding new methods (Stripe, Google Pay, Apple Pay, etc.), this `if-else` block becomes harder to maintain and less flexible. Imagine what happens when you have 20 payment methods. The code gets huge and difficult to read.

**Problems Summary:**

| Issue                              | Impact                                     |
| ---------------------------------- | ------------------------------------------ |
| **Violates Open/Closed Principle** | Must modify code to extend                 |
| **Code Duplication**               | Similar logic repeated                     |
| **Hard to Maintain**               | One large method with many conditions      |
| **Poor Scalability**               | Grows linearly with each payment type      |
| **Tight Coupling**                 | Payment logic tightly coupled to processor |

***

### Step 2: Slight Improvement Using Interfaces

In Step 1, we had a monolithic method that handled every payment method type with an `if-else` block. The problem with that approach is that we had to modify the method each time we added a new payment method. This leads to code duplication and hard-to-maintain code.

In Step 2, we make a **slight improvement** by using interfaces. We will define a `PaymentMethod` interface that each payment method will implement. This is a good improvement, but we will still have to modify the `PaymentProcessor` class when we add a new payment method.

***

#### PaymentMethod Interface

Instead of hardcoding the payment methods inside the `PaymentProcessor` class, we can define an interface `PaymentMethod` with a method `processPayment()`. All payment methods will implement this interface and provide their own implementation of `processPayment()`.

```java
// PaymentMethod interface (defines the common method for all payment types)
public interface PaymentMethod {
    void processPayment(); // Abstract method for processing payments
}
```

Now, let's create separate classes for each payment method, and each class will implement the `PaymentMethod` interface:

***

#### Concrete Payment Method Classes

```java
public class CreditCardPayment implements PaymentMethod {
    public void processPayment() {
        System.out.println("Processing credit card payment...");
    }
}

public class PayPalPayment implements PaymentMethod {
    public void processPayment() {
        System.out.println("Processing PayPal payment...");
    }
}

public class CryptoPayment implements PaymentMethod {
    public void processPayment() {
        System.out.println("Processing crypto payment...");
    }
}

public class StripePayment implements PaymentMethod {
    public void processPayment() {
        System.out.println("Processing Stripe payment...");
    }
}
```

***

#### PaymentProcessor Class in Step 2

Now that we have modularized the payment methods into separate classes, the next step is to make the `PaymentProcessor` class work with these payment strategy classes. We can pass the payment method as a parameter to the `PaymentProcessor` class.

**However, here's the catch:** While this is better, we still need to modify the `PaymentProcessor` class every time a new payment method is added.

```java
public class PaymentProcessor {
    // This method processes payment based on the payment method type
    public void processPayment(String paymentMethod) {
        if (paymentMethod.equals("CreditCard")) {
            CreditCardPayment creditCard = new CreditCardPayment();
            creditCard.processPayment(); // Process Credit Card payment
        } else if (paymentMethod.equals("PayPal")) {
            PayPalPayment payPal = new PayPalPayment();
            payPal.processPayment(); // Process PayPal payment
        } else if (paymentMethod.equals("Crypto")) {
            CryptoPayment crypto = new CryptoPayment();
            crypto.processPayment(); // Process Crypto payment
        } else if (paymentMethod.equals("Stripe")) {
            StripePayment stripe = new StripePayment();
            stripe.processPayment(); // Process Stripe payment
        } else {
            System.out.println("Payment method not supported.");
        }
    }
}
```

***

#### What's the Issue Now? âš ï¸

Even though we've moved the payment logic to individual classes (for each payment method), we still have to **modify the `PaymentProcessor` class** every time we introduce a new payment method. This is because we are still checking the payment method inside the `processPayment()` method and manually creating instances of the corresponding class.

***

#### Example: Adding a New Payment Method (Apple Pay)

To add a new payment method, like **Apple Pay**, we would need to:

1. Create a new strategy class for Apple Pay
2. Modify the `PaymentProcessor` class and add a new `else if` block for Apple Pay

Here's how we would do it:

```java
public class PaymentProcessor {
    // This method processes payment based on the payment method type
    public void processPayment(String paymentMethod) {
        if (paymentMethod.equals("CreditCard")) {
            CreditCardPayment creditCard = new CreditCardPayment();
            creditCard.processPayment(); // Process Credit Card payment
        } else if (paymentMethod.equals("PayPal")) {
            PayPalPayment payPal = new PayPalPayment();
            payPal.processPayment(); // Process PayPal payment
        } else if (paymentMethod.equals("Crypto")) {
            CryptoPayment crypto = new CryptoPayment();
            crypto.processPayment(); // Process Crypto payment
        } else if (paymentMethod.equals("Stripe")) {
            StripePayment stripe = new StripePayment();
            stripe.processPayment(); // Process Stripe payment
        } else if (paymentMethod.equals("ApplePay")) { // New payment method added
            ApplePayPayment applePay = new ApplePayPayment();
            applePay.processPayment(); // Process Apple Pay payment
        } else {
            System.out.println("Payment method not supported.");
        }
    }
}
```

***

#### Why Is This Still a Problem? ðŸ”´

**1. Adding New Payment Methods**

Every time a new payment method is added, you need to go into the `PaymentProcessor` class and add a new `else if` block. This results in code duplication and poor maintainability.

**2. Scalability Issues**

As the number of payment methods increases (imagine 20+ methods), the `PaymentProcessor` class will become massive, making it hard to read and hard to modify.

**Still Problematic:**

| Issue                     | Description                        |
| ------------------------- | ---------------------------------- |
| **Violates Open/Closed**  | Still modifying existing code      |
| **Growing if-else chain** | Gets longer with each payment type |
| **Manual instantiation**  | Must create objects inside if-else |
| **Hard to test**          | Difficult to mock payment methods  |

***

### Step 3: The Strategy Pattern â€“ The Right Way ðŸ¦¸â™‚ï¸

Now that we've seen the limitations of the traditional approach, let's apply the **Strategy Design Pattern** to solve the problem more elegantly.

In the Strategy Pattern, we create a **family of algorithms** (in this case, payment methods), and we allow the client (in this case, `PaymentProcessor`) to choose the appropriate algorithm at runtime. The key benefit is that we can easily add new payment methods **without modifying the existing code**.

Let's break it down step-by-step and walk through the complete code.

***

#### 1: Define the Strategy Interface ðŸŽ¯

The first step is to define a common interface that all the payment methods will follow. This interface will have a method called `processPayment()`, which each payment method class will implement.

```java
// PaymentStrategy interface (defines the common method for all payment types)
public interface PaymentStrategy {
    void processPayment(); // Abstract method for processing payments
}
```

**Key Point:** Here, we've created a `PaymentStrategy` interface with a single method `processPayment()`. Each payment method will implement this interface and provide its own implementation of the `processPayment()` method.

***

#### 2: Implement Concrete Payment Strategies ðŸ’³

Now, we create the **concrete payment strategies**. These are the actual implementations for each payment method like Credit Card, PayPal, Crypto, etc.

```java
// Concrete strategy for credit card payment
public class CreditCardPayment implements PaymentStrategy {
    public void processPayment() {
        System.out.println("Processing credit card payment...");
    }
}

// Concrete strategy for PayPal payment
public class PayPalPayment implements PaymentStrategy {
    public void processPayment() {
        System.out.println("Processing PayPal payment...");
    }
}

// Concrete strategy for crypto payment
public class CryptoPayment implements PaymentStrategy {
    public void processPayment() {
        System.out.println("Processing crypto payment...");
    }
}

// Concrete strategy for Stripe payment
public class StripePayment implements PaymentStrategy {
    public void processPayment() {
        System.out.println("Processing Stripe payment...");
    }
}
```

**Explanation:** Each class (like `CreditCardPayment`, `PayPalPayment`, etc.) implements the `PaymentStrategy` interface. They each have their own version of `processPayment()` that contains the logic for processing that specific payment method.

***

#### 3: Modify the PaymentProcessor Class to Use the Strategy

The key idea in the Strategy Pattern is that we will **delegate** the payment processing to the appropriate strategy. So, we'll modify the `PaymentProcessor` class to hold a reference to a `PaymentStrategy` and delegate the call to `processPayment()`.

Here's how we do that:

```java
public class PaymentProcessor {
    private PaymentStrategy paymentStrategy; // Reference to a payment strategy

    // Constructor to set the payment strategy
    public PaymentProcessor(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    // Process payment using the current strategy
    public void processPayment() {
        paymentStrategy.processPayment(); // Delegate the payment processing to the strategy
    }

    // Dynamically change payment strategy at runtime
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }
}
```

**In this class:**

1. The `PaymentProcessor` class has a reference to a `PaymentStrategy` (i.e., one of the payment methods)
2. It uses this reference to call the `processPayment()` method
3. We can dynamically change the strategy at runtime using the `setPaymentStrategy()` method. This means that if the user wants to switch from CreditCard to PayPal, we can change the strategy without changing the rest of the code!

***

#### 4: Use the Strategy Pattern in Action

Now, let's use our `PaymentProcessor` class with different payment strategies.

Here's how it works:

```java
public class Main {
    public static void main(String[] args) {
        // Create strategy instances for each payment type
        PaymentStrategy creditCard = new CreditCardPayment();
        PaymentStrategy payPal = new PayPalPayment();
        PaymentStrategy crypto = new CryptoPayment();
        PaymentStrategy stripe = new StripePayment();

        // Use the Strategy Pattern to process payments
        PaymentProcessor processor = new PaymentProcessor(creditCard); // Initially using CreditCardPayment
        processor.processPayment(); // Processing credit card payment...

        // Dynamically change the payment strategy to PayPal
        processor.setPaymentStrategy(payPal);
        processor.processPayment(); // Processing PayPal payment...

        // Switch to Crypto
        processor.setPaymentStrategy(crypto);
        processor.processPayment(); // Processing crypto payment...

        // Switch to Stripe
        processor.setPaymentStrategy(stripe);
        processor.processPayment(); // Processing Stripe payment...
    }
}
```

**Output:**

```
Processing credit card payment...
Processing PayPal payment...
Processing crypto payment...
Processing Stripe payment...
```

***

#### Explanation of Code

**Create Strategy Instances**

We create different strategy objects like `CreditCardPayment`, `PayPalPayment`, etc.

**PaymentProcessor**

We instantiate `PaymentProcessor` and pass a specific payment strategy (e.g., `CreditCardPayment`) to it.

**Dynamically Change Strategies**

We can change the payment method dynamically using the `setPaymentStrategy()` method, and **no modification to the `PaymentProcessor` class is required**.

**Process Payment**

We call `processor.processPayment()` to process the payment using the current strategy.

***

### How to Add a New Payment Method

With the Strategy Pattern, adding a new payment method (like Apple Pay) is incredibly simple:

#### Step 1: Create New Strategy Class

```java
public class ApplePayPayment implements PaymentStrategy {
    public void processPayment() {
        System.out.println("Processing Apple Pay payment...");
    }
}
```

#### Step 2: Use It

```java
PaymentStrategy applePay = new ApplePayPayment();
processor.setPaymentStrategy(applePay);
processor.processPayment(); // Processing Apple Pay payment...
```

**That's it!** No modification to `PaymentProcessor` or any existing code!

***

### Advantages of the Strategy Pattern

#### 1. Flexibility

We can switch between different payment strategies at runtime without modifying the `PaymentProcessor` class.

**Before:** Modify if-else chain\
**After:** Just change strategy object

***

#### 2. Maintainability

New payment methods can be added by simply creating new strategy classes. We don't need to touch the existing code.

**Before:** Edit existing class\
**After:** Add new strategy class only

***

#### 3. Separation of Concerns

Each payment method has its own class, making the code easier to understand and maintain. ðŸ§¹

**Before:** All logic in one place\
**After:** Each strategy in its own class

***

#### 4. Extensibility

As new payment methods become available, we can simply add them by creating new strategy classes.

**Before:** Modify core class\
**After:** Extend with new classes

***

### Comparison: Before and After Strategy Pattern

| Aspect                    | Traditional Approach          | Strategy Pattern                     |
| ------------------------- | ----------------------------- | ------------------------------------ |
| **Adding Payment Method** | Modify PaymentProcessor class | Create new strategy class only       |
| **Code Changes**          | Edit existing if-else         | No changes to existing code          |
| **Maintainability**       | Hard - one large class        | Easy - separate classes              |
| **Testability**           | Difficult - tightly coupled   | Easy - can mock strategies           |
| **Scalability**           | Poor - linear growth          | Excellent - modular                  |
| **Open/Closed Principle** | Violated                      | Followed                             |
| **Runtime Flexibility**   | Limited                       | High - switch strategies dynamically |

***

### Real-Life Use Cases for the Strategy Pattern ðŸŒ

#### 1. Payment Methods ðŸ’³

Process payments via different methods like Credit Card, PayPal, Crypto, etc.

**Example:**

```java
PaymentStrategy method = getPaymentMethod(userChoice);
processor.setPaymentStrategy(method);
processor.processPayment();
```

***

#### 2. Sorting Algorithms ðŸ“Š

Use different sorting strategies (e.g., quick sort, merge sort) depending on the situation.

**Example:**

```java
SortStrategy strategy = (dataSize > 1000) ? new QuickSort() : new BubbleSort();
sorter.setStrategy(strategy);
sorter.sort(data);
```

***

#### 3. Shipping Costs ðŸ“¦

Calculate shipping costs based on various factors such as location, delivery speed, and package size.

**Example:**

```java
ShippingStrategy strategy = new ExpressShipping();
calculator.setStrategy(strategy);
double cost = calculator.calculate(package);
```

***

#### 4. Compression Algorithms

Different compression strategies for different file types.

**Example:**

```java
CompressionStrategy strategy = new ZipCompression();
compressor.setStrategy(strategy);
compressor.compress(file);
```

***

#### 5. Authentication Methods

Different authentication strategies (OAuth, JWT, Basic Auth).

**Example:**

```java
AuthStrategy strategy = new OAuthStrategy();
authenticator.setStrategy(strategy);
authenticator.authenticate(credentials);
```

***

### When to Use Strategy Pattern

#### Use Strategy When:

1. **Multiple algorithms** - Have different ways to perform the same operation
2. **Runtime selection** - Need to choose algorithm at runtime
3. **Conditional logic** - Lots of if-else or switch statements
4. **Behavioral variations** - Similar classes differ only in behavior
5. **Extensibility needed** - Want to add new behaviors easily

#### Don't Use Strategy When:

1. **Single algorithm** - Only one way to do something
2. **Simple conditional** - One or two if-else statements
3. **No variation** - Behavior never changes
4. **Overkill** - Pattern adds unnecessary complexity

***

### Key Components

| Component               | Role                          | Example                              |
| ----------------------- | ----------------------------- | ------------------------------------ |
| **Strategy Interface**  | Defines common interface      | `PaymentStrategy`                    |
| **Concrete Strategies** | Implement specific algorithms | `CreditCardPayment`, `PayPalPayment` |
| **Context**             | Uses a strategy               | `PaymentProcessor`                   |
| **Client**              | Selects appropriate strategy  | `Main` class                         |

***

### Best Practices

1. **Use interface for strategy** - Not abstract class (unless needed)
2. **Keep strategies independent** - They shouldn't depend on each other
3. **Pass context if needed** - Strategy may need access to context data
4. **Consider strategy factory** - For creating strategies dynamically
5. **Document strategy contract** - Clear expectations for implementations
6. **Test each strategy** - Independent unit tests for each
7. **Use dependency injection** - Inject strategies rather than creating them

***

### Summary

The Strategy Pattern is a powerful tool for making your code modular, flexible, and scalable.

#### Key Takeaways

**Core Concept:**

* Define family of algorithms
* Encapsulate each one
* Make them interchangeable
* Let client choose at runtime

**Benefits:**

* **Flexibility** - Switch algorithms at runtime
* **Maintainability** - Add strategies without modifying existing code
* **Separation of Concerns** - Each algorithm in its own class
* **Extensibility** - Easy to add new strategies
* **Testability** - Test strategies independently

**Structure:**

1. Strategy Interface - Common contract
2. Concrete Strategies - Specific implementations
3. Context - Uses strategies
4. Client - Selects strategy

**When to Use:**

* Multiple ways to perform operation
* Lots of conditional logic
* Need runtime flexibility
* Want to follow Open/Closed Principle

***

### Conclusion ðŸŽ¯

The Strategy Pattern is a powerful tool for making your code modular, flexible, and scalable. By encapsulating behaviors (like payment methods) into separate strategy classes, you can easily change or add new behaviors without modifying the existing code.

This results in a **cleaner, more maintainable codebase** that can adapt to future requirements without significant changes.

**Remember:** The Strategy Pattern is all about:

* Defining a family of algorithms
* Making them interchangeable
* Selecting the right one at runtime
* Following the Open/Closed Principle

By mastering the Strategy Pattern, you gain a powerful tool for creating flexible, maintainable systems that can easily adapt to changing requirements.

***

### Next Steps

Continue your learning journey by exploring:

* State Pattern (changes behavior based on state)
* Command Pattern (encapsulates requests as objects)
* Template Method Pattern (defines algorithm skeleton)
* Combining Strategy with Factory Pattern
* Strategy Pattern in popular frameworks
* Testing strategies for Strategy Pattern implementations
