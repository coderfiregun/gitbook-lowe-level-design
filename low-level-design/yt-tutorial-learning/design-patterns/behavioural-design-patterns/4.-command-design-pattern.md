# 4. Command Design Pattern

## Command Design Pattern

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/command-design-pattern)

### Understanding the Command Design Pattern

The **Command Design Pattern** is one of the behavioral design patterns in software development. At its core, it's about **encapsulating a request as an object**, which allows you to parameterize objects with operations, delay execution, and queue requests.

The idea is that **commands** (actions you want to perform) are wrapped as objects, and these command objects can then be passed around, stored, or executed when needed.

**Real-World Analogy:** It's kind of like giving someone a "to-do" list where each item represents an action to be performed.

***

### Why is it Named the Command Pattern?

The pattern is named the **Command pattern** because it revolves around the concept of **commanding an action**. Instead of executing a method directly, you create a command object that represents the action. This command object can then be executed at any point in time.

**Think of it like:** Giving an order (command) to be carried out when the time is right, which allows for more flexible and reusable code.

**Key Concept:**

* **Traditional approach:** Call methods directly
* **Command pattern:** Wrap actions in objects
* **Result:** More flexible, maintainable code

Now that we know what the Command Design Pattern is and why it's named the way it is, let's dive into a real-world scenario to understand how we can apply this pattern.

***

### Real-World Scenario: Remote Control System

Imagine you're building a **remote control system** for a device like a TV. Your TV remote needs to be able to perform a set of actions, like:

* Turning the TV on and off
* Changing channels
* Adjusting the volume

Let's start by solving this problem the traditional way without using the Command pattern.

***

### Solving the Problem the Traditional Way

Here's how you might approach it:

```java
public class TV {
    public void turnOn() {
        System.out.println("TV is ON");
    }
    
    public void turnOff() {
        System.out.println("TV is OFF");
    }
    
    public void changeChannel(int channel) {
        System.out.println("Channel changed to " + channel);
    }
    
    public void adjustVolume(int volume) {
        System.out.println("Volume set to " + volume);
    }
}

public class RemoteControl {
    private TV tv;
    
    public RemoteControl(TV tv) {
        this.tv = tv;
    }
    
    public void pressOnButton() {
        tv.turnOn();
    }
    
    public void pressOffButton() {
        tv.turnOff();
    }
    
    public void pressChannelButton(int channel) {
        tv.changeChannel(channel);
    }
    
    public void pressVolumeButton(int volume) {
        tv.adjustVolume(volume);
    }
}
```

**Output:**

```
TV is ON
TV is OFF
Channel changed to 5
Volume set to 20
```

***

### What's the Issue?

As you can see, we are **directly calling the methods** on the `TV` object inside the `RemoteControl` class. So, if we wanted to add new functionality or extend the remote with new features, we'd have to keep modifying the `RemoteControl` class, leading to:

* Code duplication
* Lack of flexibility
* Tight coupling

**Problems:**

| Issue                   | Impact                                     |
| ----------------------- | ------------------------------------------ |
| **Direct Method Calls** | RemoteControl tightly coupled to TV        |
| **Hard to Extend**      | Must modify RemoteControl for new features |
| **No Flexibility**      | Can't easily add/remove actions            |
| **Code Duplication**    | Similar logic repeated                     |
| **Not Scalable**        | Hard to add new devices                    |

***

### The Interviewer's Questions

Now imagine an interviewer asking:

#### Question 1: What if we want to add more functionalities to the remote?

Every new functionality would require modifying the `RemoteControl` class.

#### Question 2: What if we want to store a sequence of operations and execute them later?

Like turning the TV on, changing the channel, and adjusting the volume?

#### Question 3: How would you handle multiple remotes controlling different devices?

The current design doesn't scale well for multiple devices.

These are great questions that push us to rethink the design. The current approach requires modification each time we add a new feature, and the scalability isn't great.

***

### The Ugly Code

Let's take it a step further and see how things get ugly when we add more functionalities. If we decide to add more complex operations (like multiple actions in a sequence), the code starts to get messy and hard to maintain.

```java
public class RemoteControl {
    private TV tv;
    
    public RemoteControl(TV tv) {
        this.tv = tv;
    }
    
    public void pressOnButton() {
        tv.turnOn();
    }
    
    public void pressOffButton() {
        tv.turnOff();
    }
    
    public void pressChannelButton(int channel) {
        tv.changeChannel(channel);
    }
    
    public void pressVolumeButton(int volume) {
        tv.adjustVolume(volume);
    }
    
    // New methods are added each time we need more actions
    public void pressOnChangeVolumeAndChannelButton(int volume, int channel) {
        tv.turnOn();
        tv.changeChannel(channel);
        tv.adjustVolume(volume);
    }
}
```

***

### What's the Problem Here?

#### 1. Code Duplication

As we add more actions (like turning the TV on, changing the channel, and adjusting the volume), we need to keep modifying the `RemoteControl` class. This results in increased code duplication and the potential for bugs.

#### 2. Hard to Extend

If we want to add more devices (say a smart speaker or AC unit), we'd have to keep modifying the remote. The system is not flexible enough to easily scale.

**Growing Complexity:**

```java
// This approach leads to method explosion
public void pressOnChangeVolumeAndChannelButton(int volume, int channel) { }
public void pressOffChangeVolumeButton(int volume) { }
public void pressOnChangeChannelButton(int channel) { }
// And many more combinations...
```

***

### Our Savior: The Command Design Pattern

Now, let's introduce our savior: the **Command Design Pattern**. With this pattern, instead of directly invoking actions in the `RemoteControl`, we create **command objects** that encapsulate each action.

This will allow us to:

* Add more features without modifying existing code
* Store and execute commands at a later time
* Queue and schedule commands
* Implement undo/redo functionality

***

### How Does the Command Pattern Work? üßëüè´

We'll start by defining a `Command` interface that every command will implement. Each specific command (like turning the TV on or changing the channel) will be represented by a class that implements this interface. The `RemoteControl` class will only hold references to these command objects, and when a button is pressed, it will execute the corresponding command.

***

### Step 1: Define the Command Interface

```java
public interface Command {
    void execute(); // Executes the command
}
```

**Key Point:** This interface defines a single method `execute()` that all concrete commands must implement.

***

### Step 2: Implement the Concrete Command Classes üñãÔ∏è

#### TurnOnCommand

```java
public class TurnOnCommand implements Command {
    private TV tv;
    
    public TurnOnCommand(TV tv) {
        this.tv = tv;
    }
    
    @Override
    public void execute() {
        tv.turnOn();
    }
}
```

#### TurnOffCommand

```java
public class TurnOffCommand implements Command {
    private TV tv;
    
    public TurnOffCommand(TV tv) {
        this.tv = tv;
    }
    
    @Override
    public void execute() {
        tv.turnOff();
    }
}
```

#### ChangeChannelCommand

```java
public class ChangeChannelCommand implements Command {
    private TV tv;
    private int channel;
    
    public ChangeChannelCommand(TV tv, int channel) {
        this.tv = tv;
        this.channel = channel;
    }
    
    @Override
    public void execute() {
        tv.changeChannel(channel);
    }
}
```

#### AdjustVolumeCommand

```java
public class AdjustVolumeCommand implements Command {
    private TV tv;
    private int volume;
    
    public AdjustVolumeCommand(TV tv, int volume) {
        this.tv = tv;
        this.volume = volume;
    }
    
    @Override
    public void execute() {
        tv.adjustVolume(volume);
    }
}
```

**Explanation:** Each command class encapsulates a specific action and holds a reference to the receiver (TV). When `execute()` is called, it delegates to the appropriate method on the receiver.

***

### Step 3: The Invoker Class (RemoteControl) üéÆ

```java
public class RemoteControl {
    private Command onCommand;
    private Command offCommand;
    
    public void setOnCommand(Command onCommand) {
        this.onCommand = onCommand;
    }
    
    public void setOffCommand(Command offCommand) {
        this.offCommand = offCommand;
    }
    
    public void pressOnButton() {
        onCommand.execute();
    }
    
    public void pressOffButton() {
        offCommand.execute();
    }
}
```

**Key Point:** The `RemoteControl` (invoker) doesn't know the specifics of what the commands do. It just executes them when buttons are pressed.

***

### Step 4: The TV Class üì∫

```java
// The TV class with methods for the different operations
public class TV {
    public void turnOn() {
        System.out.println("TV is ON");
    }
    
    public void turnOff() {
        System.out.println("TV is OFF");
    }
    
    public void changeChannel(int channel) {
        System.out.println("Channel changed to " + channel);
    }
    
    public void adjustVolume(int volume) {
        System.out.println("Volume set to " + volume);
    }
}
```

**Role:** The TV class is the **receiver** that performs the actual actions.

***

### Step 5: Putting Everything Together

```java
public class Main {
    public static void main(String[] args) {
        TV tv = new TV();
        
        // Create commands
        Command turnOn = new TurnOnCommand(tv);
        Command turnOff = new TurnOffCommand(tv);
        Command changeChannel = new ChangeChannelCommand(tv, 5);
        Command adjustVolume = new AdjustVolumeCommand(tv, 20);
        
        // Create remote control
        RemoteControl remote = new RemoteControl();
        remote.setOnCommand(turnOn);
        remote.setOffCommand(turnOff);
        
        remote.pressOnButton();  // Turn on the TV
        remote.pressOffButton(); // Turn off the TV
        
        // Execute other commands
        changeChannel.execute(); // Change the channel
        adjustVolume.execute();  // Adjust the volume
    }
}
```

**Output:**

```
TV is ON
TV is OFF
Channel changed to 5
Volume set to 20
```

***

### Command Pattern Structure

#### Components

| Component           | Role                                        | Example                           |
| ------------------- | ------------------------------------------- | --------------------------------- |
| **Command**         | Declares interface for executing operations | `Command` interface               |
| **ConcreteCommand** | Implements execute by invoking receiver     | `TurnOnCommand`, `TurnOffCommand` |
| **Invoker**         | Asks command to execute request             | `RemoteControl`                   |
| **Receiver**        | Knows how to perform operations             | `TV`                              |
| **Client**          | Creates concrete command and sets receiver  | `Main` class                      |

#### Relationships

```
Client
  ‚Üì creates
ConcreteCommand ‚Üí implements ‚Üí Command
  ‚Üì references
Receiver
  ‚Üì stored in
Invoker ‚Üí executes ‚Üí Command
```

***

### Structure Explanation

#### 1. Command Interface

This defines the method `execute()`, which all concrete command classes must implement.

#### 2. Concrete Command Classes

These include `TurnOnCommand`, `TurnOffCommand`, `ChangeChannelCommand`, and `AdjustVolumeCommand`. Each class:

* Encapsulates a specific action
* Implements the `execute()` method
* Calls the appropriate method on the TV class (the receiver)

#### 3. RemoteControl (Invoker)

The `RemoteControl` class:

* Holds references to the commands
* Invokes them when needed (like when a user presses a button)
* Doesn't know the specifics of what the commands do
* Just executes them

#### 4. TV (Receiver)

The `TV` class is the receiver that performs the actual actions (turning on/off, changing channels, adjusting volume).

***

### Advantages of the Command Design Pattern

#### 1. No Modification of Existing Code

We don't need to modify the `RemoteControl` class every time we add a new feature. We simply create new command classes.

**Before:** Modify RemoteControl for each new feature\
**After:** Just add new command class

***

#### 2. Separation of Concerns üßπ

The logic for each command is encapsulated in its own class, making the code cleaner and easier to maintain.

**Benefits:**

* Each command class has single responsibility
* Easy to understand and modify
* Clear organization

***

#### 3. Flexibility

The `RemoteControl` doesn't need to know the specifics of what the commands do. It just invokes them. This makes it easy to add new commands or remove old ones without impacting the system.

**Example - Adding New Command:**

```java
public class MuteCommand implements Command {
    private TV tv;
    
    public MuteCommand(TV tv) {
        this.tv = tv;
    }
    
    @Override
    public void execute() {
        tv.mute();
    }
}

// Usage - no changes to RemoteControl needed!
Command mute = new MuteCommand(tv);
mute.execute();
```

***

#### 4. Support for Undo/Redo

Easy to implement undo functionality by storing executed commands.

```java
public interface Command {
    void execute();
    void undo(); // Add undo capability
}

public class TurnOnCommand implements Command {
    private TV tv;
    
    public TurnOnCommand(TV tv) {
        this.tv = tv;
    }
    
    @Override
    public void execute() {
        tv.turnOn();
    }
    
    @Override
    public void undo() {
        tv.turnOff(); // Reverse the action
    }
}
```

***

#### 5. Command Queuing

Commands can be queued and executed in sequence.

```java
public class CommandQueue {
    private Queue<Command> commands = new LinkedList<>();
    
    public void addCommand(Command command) {
        commands.add(command);
    }
    
    public void executeAll() {
        while (!commands.isEmpty()) {
            commands.poll().execute();
        }
    }
}
```

***

### Comparison: Before and After Command Pattern

| Aspect                | Traditional Approach                   | Command Pattern                                    |
| --------------------- | -------------------------------------- | -------------------------------------------------- |
| **Adding New Action** | Modify RemoteControl                   | Create new command class                           |
| **Coupling**          | Tight - RemoteControl knows TV details | Loose - RemoteControl knows only Command interface |
| **Extensibility**     | Poor - modify existing code            | Excellent - just add new commands                  |
| **Undo/Redo**         | Very difficult to implement            | Easy - store command history                       |
| **Queuing**           | Not possible                           | Easy - queue command objects                       |
| **Testing**           | Hard - tightly coupled                 | Easy - test commands independently                 |
| **Flexibility**       | Limited                                | High - swap commands dynamically                   |

***

### Everyday Use Cases of the Command Pattern üåé

#### 1. Undo/Redo Operations

In applications like text editors, each action (e.g., typing, deleting) can be wrapped in a command object, allowing for undo/redo functionality.

**Example:**

```java
public class TextEditor {
    private Stack<Command> undoStack = new Stack<>();
    private Stack<Command> redoStack = new Stack<>();
    
    public void executeCommand(Command command) {
        command.execute();
        undoStack.push(command);
        redoStack.clear();
    }
    
    public void undo() {
        if (!undoStack.isEmpty()) {
            Command command = undoStack.pop();
            command.undo();
            redoStack.push(command);
        }
    }
    
    public void redo() {
        if (!redoStack.isEmpty()) {
            Command command = redoStack.pop();
            command.execute();
            undoStack.push(command);
        }
    }
}
```

***

#### 2. GUI Buttons

Each button on a user interface can be linked to a specific command, making it easy to change the behavior of buttons without altering the UI code.

**Example:**

```java
public class Button {
    private Command command;
    
    public void setCommand(Command command) {
        this.command = command;
    }
    
    public void click() {
        command.execute();
    }
}

// Usage
Button saveButton = new Button();
saveButton.setCommand(new SaveCommand(document));
saveButton.click(); // Executes save command
```

***

#### 3. Task Scheduling

Command pattern can be used in job scheduling systems where tasks are represented as commands and can be executed at later times.

**Example:**

```java
public class TaskScheduler {
    private Queue<Command> scheduledTasks = new PriorityQueue<>();
    
    public void scheduleTask(Command task, long delay) {
        scheduledTasks.add(task);
        // Schedule for later execution
    }
    
    public void executeDueTasks() {
        while (!scheduledTasks.isEmpty()) {
            Command task = scheduledTasks.poll();
            task.execute();
        }
    }
}
```

***

#### 4. Transaction Systems

Database transactions can be modeled as commands.

**Example:**

```java
public class Transaction {
    private List<Command> commands = new ArrayList<>();
    
    public void addCommand(Command command) {
        commands.add(command);
    }
    
    public void commit() {
        for (Command command : commands) {
            command.execute();
        }
    }
    
    public void rollback() {
        for (int i = commands.size() - 1; i >= 0; i--) {
            commands.get(i).undo();
        }
    }
}
```

***

#### 5. Macro Recording

Record a sequence of commands and replay them.

**Example:**

```java
public class MacroCommand implements Command {
    private List<Command> commands = new ArrayList<>();
    
    public void addCommand(Command command) {
        commands.add(command);
    }
    
    @Override
    public void execute() {
        for (Command command : commands) {
            command.execute();
        }
    }
}
```

***

### When to Use Command Pattern

#### Use Command When:

1. **Parameterize objects** - Need to parameterize objects with operations
2. **Queue operations** - Need to queue, log, or schedule operations
3. **Undo/redo needed** - Implement undo/redo functionality
4. **Decouple sender/receiver** - Request sender shouldn't know about receiver
5. **Transaction support** - Need to support transactional operations

#### Don't Use Command When:

1. **Simple operations** - Direct method calls are sufficient
2. **No queuing needed** - Commands won't be queued or delayed
3. **No undo needed** - Don't need undo/redo functionality
4. **Unnecessary complexity** - Pattern adds overhead without benefits

***

### Key Components Summary

#### Command

Declares interface for executing an operation.

#### ConcreteCommand

* Defines binding between Receiver and action
* Implements `execute()` by invoking operations on Receiver

#### Client

Creates ConcreteCommand and sets its Receiver.

#### Invoker

Asks the command to carry out the request.

#### Receiver

Knows how to perform the operations.

***

### Best Practices

1. **Keep commands simple** - Each command should do one thing
2. **Support undo when needed** - Add `undo()` method to interface
3. **Use command history** - Store executed commands for undo/redo
4. **Consider macros** - Group related commands
5. **Handle exceptions** - Commands should handle their own errors
6. **Document side effects** - Clear documentation of command effects
7. **Thread safety** - Consider synchronization for concurrent access

**Exception Handling Example:**

```java
public class SafeCommand implements Command {
    private Command wrapped;
    
    public SafeCommand(Command wrapped) {
        this.wrapped = wrapped;
    }
    
    @Override
    public void execute() {
        try {
            wrapped.execute();
        } catch (Exception e) {
            System.err.println("Command failed: " + e.getMessage());
            // Handle or log error
        }
    }
}
```

***

### Advanced: Command Pattern with Undo

Complete implementation with undo support:

```java
public interface Command {
    void execute();
    void undo();
}

public class RemoteControl {
    private Command lastCommand;
    
    public void executeCommand(Command command) {
        command.execute();
        lastCommand = command;
    }
    
    public void undoLastCommand() {
        if (lastCommand != null) {
            lastCommand.undo();
        }
    }
}

public class TurnOnCommand implements Command {
    private TV tv;
    
    public TurnOnCommand(TV tv) {
        this.tv = tv;
    }
    
    @Override
    public void execute() {
        tv.turnOn();
    }
    
    @Override
    public void undo() {
        tv.turnOff();
    }
}
```

***

### Summary

The Command Design Pattern helps you decouple the request (action) from the object that performs it.

#### Key Takeaways

**Core Concept:**

* Encapsulate request as an object
* Parameterize objects with operations
* Queue, log, and support undo

**Benefits:**

* **Decoupling** - Invoker independent of receiver
* **Flexibility** - Easy to add new commands
* **Undo/Redo** - Simple to implement
* **Queuing** - Commands can be queued and scheduled
* **Extensibility** - Add new commands without modifying existing code

**Structure:**

1. Command Interface - Declares execute method
2. Concrete Commands - Implement specific actions
3. Invoker - Executes commands
4. Receiver - Performs actual work
5. Client - Creates and configures commands

**Real-World Uses:**

* Text editor undo/redo
* GUI button actions
* Task scheduling
* Transaction systems
* Macro recording

***

### Conclusion

The Command Design Pattern helps you decouple the request (action) from the object that performs it. This pattern allows for extensible, maintainable, and scalable solutions by encapsulating requests into objects and executing them on demand.

By applying this pattern, you can write more clean, flexible, and robust code.

**Remember:** The Command pattern is about:

* Encapsulating actions as objects
* Decoupling sender from receiver
* Supporting undo/redo operations
* Queuing and scheduling commands

Next time you face a scenario where you need to manage actions or commands (like a remote control or task scheduling), consider using the Command Pattern to make your code more organized and future-proof.

Happy coding! üë®‚Äçüíª

***

### Next Steps

Continue your learning journey by exploring:

* Memento Pattern (saving and restoring state)
* Strategy Pattern (encapsulating algorithms)
* Chain of Responsibility (passing requests along chain)
* Command Pattern with Spring Framework
* Event sourcing with Command Pattern
* CQRS (Command Query Responsibility Segregation)
