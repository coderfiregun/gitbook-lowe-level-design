# 5. Mediator Design Pattern

## Mediator Design Pattern

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/mediator-design-pattern)

### Introduction

Hey there, fellow coder!

Today, we're going to embark on a fun and interactive journey into the **Mediator Design Pattern** using Java.

#### Real-World Analogy

Imagine an **auction system** where multiple bidders are excitedly placing their bids. Instead of all bidders talking to each other directly‚Äîwhich would be chaotic and messy‚Äîwe introduce a central **auction house** that coordinates everything.

**This auction house is our mediator!**

It makes communication smooth and structured, reducing direct dependencies between bidders. Ready to dive in? Let's go!

***

### The Auction Mayhem: A Traditional Approach Gone Wild

Imagine our auction system without any mediator. Every bidder has to know about every other bidder to communicate a new bid. Let's see how that might look:

```java
class Bidder {
    String name;
    int bid;
    
    public Bidder(String name) {
        this.name = name;
    }
    
    // Direct communication with all other bidders (messy!)
    public void placeBid(int amount, Bidder[] bidders) {
        this.bid = amount;
        System.out.println(name + " placed a bid: " + amount);
        for (Bidder b : bidders) {
            if (b != this) {
                b.receiveBid(this, amount);
            }
        }
    }
    
    public void receiveBid(Bidder bidder, int amount) {
        System.out.println(name + " is notified: " + bidder.name +
                " placed a bid of " + amount);
    }
}

public class AuctionTraditionalDemo {
    public static void main(String[] args) {
        Bidder bidder1 = new Bidder("Alice");
        Bidder bidder2 = new Bidder("Bob");
        Bidder bidder3 = new Bidder("Charlie");
        Bidder[] bidders = {bidder1, bidder2, bidder3};
        
        // Each bidder directly communicates with others
        bidder1.placeBid(100, bidders);
        bidder2.placeBid(150, bidders);
        bidder3.placeBid(200, bidders);
    }
}
```

**Output:**

```
Alice placed a bid: 100
Bob is notified: Alice placed a bid of 100
Charlie is notified: Alice placed a bid of 100
Bob placed a bid: 150
Alice is notified: Bob placed a bid of 150
Charlie is notified: Bob placed a bid of 150
Charlie placed a bid: 200
Alice is notified: Charlie placed a bid of 200
Bob is notified: Charlie placed a bid of 200
```

***

### Explanation

* Every bidder directly notifies all other bidders when placing a bid
* As more bidders or features are added, this approach becomes tangled and hard to manage üòµ

**Problems:**

| Issue                  | Impact                                                |
| ---------------------- | ----------------------------------------------------- |
| **Tight Coupling**     | Each bidder knows about all other bidders             |
| **Scalability Issues** | Adding new bidders increases complexity exponentially |
| **Hard to Maintain**   | Changes affect multiple classes                       |
| **No Central Control** | No single point to manage interactions                |
| **Dependency Web**     | Complex network of dependencies                       |

***

### The Interviewer Questions: "This Looks Messy‚ÄîHow Can You Improve It?"

Imagine you're in an interview and the interviewer points out that the direct communication between bidders creates a lot of dependencies and clutter. They ask:

> **"How would you refactor this code to make it cleaner and more scalable?"**

Yikes! That's when you realize the need for a centralized mediator.

***

### The Ugly Truth: A Tangled Web of Direct Communication

Let's take a peek at an even more cluttered version, where every bidder not only places bids but also handles multiple extra responsibilities:

```java
// Messy version: Each bidder handles bidding, logging, and notifications directly
class Bidder {
    String name;
    int bid;
    
    public Bidder(String name) {
        this.name = name;
    }
    
    // A cluttered method that handles bidding and additional responsibilities
    public void placeBidWithExtras(int amount, Bidder[] bidders) {
        // Update bid and log the bid placement
        this.bid = amount;
        System.out.println("[" + name + "] placed a bid: " + amount);
        System.out.println("LOG: " + name + " bid " + amount + " at " +
                System.currentTimeMillis());
        
        // Directly notify every other bidder with additional responsibilities
        for (Bidder b : bidders) {
            if (b != this) {
                b.receiveBidWithExtras(this, amount);
            }
        }
    }
    
    // Cluttered notification method with extra tasks (like simulating an email notification)
    public void receiveBidWithExtras(Bidder bidder, int amount) {
        System.out.println("[" + name + "] is notified: " + bidder.name +
                " placed a bid of " + amount);
        System.out.println("EMAIL: Sending email to " + name +
                " about the bid from " + bidder.name);
    }
}

public class AuctionUglyDemo {
    public static void main(String[] args) {
        // Creating bidders without a central mediator
        Bidder bidder1 = new Bidder("Alice");
        Bidder bidder2 = new Bidder("Bob");
        Bidder bidder3 = new Bidder("Charlie");
        Bidder[] bidders = {bidder1, bidder2, bidder3};
        
        // Each bidder is responsible for handling the bid and all associated extras
        bidder1.placeBidWithExtras(100, bidders);
        bidder2.placeBidWithExtras(150, bidders);
        bidder3.placeBidWithExtras(200, bidders);
    }
}
```

***

### Explanation

* The code is tangled, difficult to extend, and every new feature forces you to modify each bidder
* It's a maintenance nightmare! üò¨üí•

**Additional Problems:**

| Issue                      | Impact                                          |
| -------------------------- | ----------------------------------------------- |
| **Mixed Responsibilities** | Bidding, logging, and notification in one place |
| **Code Duplication**       | Similar logic repeated in each bidder           |
| **Violates SRP**           | Single Responsibility Principle violated        |
| **Hard to Test**           | Tightly coupled code difficult to test          |
| **Feature Creep**          | Adding features makes code messier              |

***

### Enter the Auction House: Our Mediator to the Rescue! üòé

Now, let's bring in our savior‚Äîthe **Mediator Design Pattern**. In our auction system, we'll create an `AuctionMediator` that centralizes all communication between bidders.

**Benefits:**

* Each bidder doesn't need to know about every other bidder
* They simply communicate with the mediator
* The mediator takes care of the rest

***

### Step 1: Defining the Mediator Interface

Our mediator will have methods to register bidders and handle bid placements.

```java
interface AuctionMediator {
    void registerBidder(Bidder bidder);
    void placeBid(Bidder bidder, int amount);
}
```

**Explanation:**

* The mediator defines the contract for registering bidders and processing bids
* Simple, clean interface with two clear responsibilities

***

### Step 2: Building the Concrete Mediator ‚Äì The Auction House

The Auction House will manage all bidder interactions.

```java
import java.util.ArrayList;
import java.util.List;

class AuctionHouse implements AuctionMediator {
    private List<Bidder> bidders = new ArrayList<>();
    
    @Override
    public void registerBidder(Bidder bidder) {
        bidders.add(bidder);
    }
    
    @Override
    public void placeBid(Bidder bidder, int amount) {
        System.out.println(bidder.getName() + " placed a bid of " + amount);
        for (Bidder b : bidders) {
            if (b != bidder) {
                b.receiveBid(bidder, amount);
            }
        }
    }
}
```

**Explanation:**

* The `AuctionHouse` keeps a list of all registered bidders
* When a bid is placed, it notifies all other bidders via the mediator
* Centralized communication logic

***

### Step 3: Updating the Bidder Class to Work with the Mediator

Bidders now communicate only with the mediator.

```java
class Bidder {
    private String name;
    private AuctionMediator mediator;
    
    public Bidder(String name, AuctionMediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }
    
    public String getName() {
        return name;
    }
    
    public void placeBid(int amount) {
        mediator.placeBid(this, amount);
    }
    
    public void receiveBid(Bidder bidder, int amount) {
        System.out.println(name + " is notified: " + bidder.getName() +
                " placed a bid of " + amount);
    }
}
```

**Explanation:**

* Each bidder holds a reference to the mediator instead of knowing about other bidders
* This makes the code much cleaner and decoupled
* Bidders only talk to the mediator

***

### Step 4: Bringing It All Together ‚Äì The Clean Auction System

Now, let's see our auction system using the mediator in action.

```java
public class AuctionMediatorDemo {
    public static void main(String[] args) {
        AuctionMediator auctionHouse = new AuctionHouse();
        
        Bidder bidder1 = new Bidder("Alice", auctionHouse);
        Bidder bidder2 = new Bidder("Bob", auctionHouse);
        Bidder bidder3 = new Bidder("Charlie", auctionHouse);
        
        auctionHouse.registerBidder(bidder1);
        auctionHouse.registerBidder(bidder2);
        auctionHouse.registerBidder(bidder3);
        
        bidder1.placeBid(100);
        bidder2.placeBid(150);
        bidder3.placeBid(200);
    }
}
```

**Output:**

```
Alice placed a bid of 100
Bob is notified: Alice placed a bid of 100
Charlie is notified: Alice placed a bid of 100
Bob placed a bid of 150
Alice is notified: Bob placed a bid of 150
Charlie is notified: Bob placed a bid of 150
Charlie placed a bid of 200
Alice is notified: Charlie placed a bid of 200
Bob is notified: Charlie placed a bid of 200
```

**Explanation:**

* Bidders register with the `AuctionHouse`
* When a bidder places a bid, the `AuctionHouse` (mediator) notifies all other bidders
* The system is now organized, easy to extend, and much cleaner!

***

### Comparison: Before and After Mediator Pattern

| Aspect              | Traditional Approach                  | Mediator Pattern                   |
| ------------------- | ------------------------------------- | ---------------------------------- |
| **Coupling**        | Tight - every bidder knows all others | Loose - bidders know only mediator |
| **Communication**   | Direct bidder-to-bidder               | Through central mediator           |
| **Dependencies**    | N √ó (N-1) connections                 | N connections to mediator          |
| **Adding Bidder**   | Update all existing bidders           | Just register with mediator        |
| **Maintainability** | Difficult - changes everywhere        | Easy - changes in mediator         |
| **Scalability**     | Poor - exponential growth             | Good - linear growth               |
| **Testing**         | Hard - many dependencies              | Easy - mock mediator               |

***

### Follow-Up: Extending the Auction System üî•

Suppose the interviewer asks:

> **"What if you want to add a new feature like logging each bid or integrating a bidding timer?"**

With our mediator pattern, you can simply extend the mediator without touching the bidder classes.

For example, you could modify the `AuctionHouse` to log each bid or check bid times. The beauty is that the core communication mechanism remains untouched, and new features are added in one centralized place. How neat is that? üòé

***

### Extended Auction House with Logging and Timer

Here, we'll extend our existing `AuctionHouse` to create an `ExtendedAuctionHouse` that logs every bid and enforces a bidding timer. Bids submitted after the bidding period will be rejected.

```java
import java.util.ArrayList;
import java.util.List;

class ExtendedAuctionHouse extends AuctionHouse {
    private long biddingEndTime;  // Timestamp when bidding ends
    
    public ExtendedAuctionHouse(long biddingEndTime) {
        this.biddingEndTime = biddingEndTime;
    }
    
    @Override
    public void placeBid(Bidder bidder, int amount) {
        // Check if bidding time is still open
        if (System.currentTimeMillis() > biddingEndTime) {
            System.out.println("Bidding time is over. No more bids accepted.");
            return;
        }
        
        // Log the bid
        System.out.println("LOG: " + bidder.getName() + " is bidding " + amount);
        
        // Delegate to the original mediator logic to notify other bidders
        super.placeBid(bidder, amount);
    }
}

// Base AuctionHouse (from our previous implementation)
class AuctionHouse implements AuctionMediator {
    protected List<Bidder> bidders = new ArrayList<>();
    
    @Override
    public void registerBidder(Bidder bidder) {
        bidders.add(bidder);
    }
    
    @Override
    public void placeBid(Bidder bidder, int amount) {
        System.out.println(bidder.getName() + " placed a bid of " + amount);
        for (Bidder b : bidders) {
            if (b != bidder) {
                b.receiveBid(bidder, amount);
            }
        }
    }
}
```

***

### Using the Extended Mediator

And here's how you might use this extended mediator in your main program:

```java
public class ExtendedAuctionMediatorDemo {
    public static void main(String[] args) throws InterruptedException {
        // Set bidding end time to 5 seconds from now for demo purposes
        long biddingEndTime = System.currentTimeMillis() + 5000;
        AuctionMediator auctionHouse = new ExtendedAuctionHouse(biddingEndTime);
        
        Bidder bidder1 = new Bidder("Alice", auctionHouse);
        Bidder bidder2 = new Bidder("Bob", auctionHouse);
        Bidder bidder3 = new Bidder("Charlie", auctionHouse);
        
        auctionHouse.registerBidder(bidder1);
        auctionHouse.registerBidder(bidder2);
        auctionHouse.registerBidder(bidder3);
        
        bidder1.placeBid(100);
        Thread.sleep(2000);  // Wait 2 seconds
        bidder2.placeBid(150);
        Thread.sleep(4000);     // Wait additional 4 seconds (after bidding period)
        bidder3.placeBid(200);  // This bid should be rejected
    }
}
```

**Output:**

```
LOG: Alice is bidding 100
Alice placed a bid of 100
Bob is notified: Alice placed a bid of 100
Charlie is notified: Alice placed a bid of 100
LOG: Bob is bidding 150
Bob placed a bid of 150
Alice is notified: Bob placed a bid of 150
Charlie is notified: Bob placed a bid of 150
Bidding time is over. No more bids accepted.
```

***

### Explanation

#### ExtendedAuctionHouse

* Inherits from `AuctionHouse`
* Adds a `biddingEndTime` to define when the bidding period expires
* Overrides the `placeBid()` method to:
  * Check if the current time exceeds the bidding end time
  * Log each bid with a custom message
  * Delegate to the base class method to notify other bidders if the bid is accepted

#### Main Demo

* Sets a bidding period (5 seconds in this demo)
* Registers the bidders
* Demonstrates that bids placed after the bidding period are not accepted

This follow-up code illustrates how easily you can extend your mediator to add new functionality like logging and timing, all without modifying your `Bidder` classes. It showcases the power and flexibility of the Mediator Design Pattern in making your system more scalable and maintainable. üòéüëç

***

### Structure Explanation

#### AuctionMediator (Interface)

* Declares the methods for registering bidders and placing bids
* Defines the contract for all mediators

#### AuctionHouse (Concrete Mediator)

* Implements `AuctionMediator` and manages a list of bidders
* Notifies all registered bidders when a bid is placed
* Centralizes communication logic

#### ExtendedAuctionHouse (Extended Mediator)

* Inherits from `AuctionHouse` and adds additional functionality (like logging bids and enforcing a bidding timer)
* Demonstrates extensibility

#### Bidder

* Represents an auction participant
* Holds a reference to an `AuctionMediator` (decoupling it from direct communication with other bidders)
* Uses the mediator to place bids and receive notifications

***

### The Marvelous Benefits of the Mediator Pattern

#### 1. Reduced Coupling üîó

The mediator centralizes communication between objects, so individual components don't need to know about each other. This makes your code more modular and less dependent on tight interconnections.

**Before:** N √ó (N-1) direct connections\
**After:** N connections to mediator

***

#### 2. Simplified Communication üìû

With a single mediator managing all interactions, the communication logic becomes clearer and easier to manage‚Äîno more tangled webs of direct object-to-object calls!

**Benefits:**

* Single point of communication
* Clear message flow
* Easy to understand

***

#### 3. Enhanced Maintainability üîß

Since changes in communication are handled by the mediator, updates or modifications can be made in one place rather than throughout the entire system. This significantly improves maintainability.

**Impact:**

* Fewer files to change
* Reduced risk of bugs
* Easier refactoring

***

#### 4. Improved Scalability üìà

Adding new components is much easier because they only need to interact with the mediator. This promotes scalability and reduces the risk of integration issues as your system grows.

**Example:**

```java
// Adding a new bidder is simple
Bidder newBidder = new Bidder("David", auctionHouse);
auctionHouse.registerBidder(newBidder);
// No changes needed to existing bidders!
```

***

#### 5. Greater Reusability ‚ôªÔ∏è

Components remain self-contained and reusable in different contexts, since they don't have hard-coded dependencies on other parts of the system.

**Benefit:** Bidder class can be used in different auction systems with different mediators.

***

### Real-Life Auction Magic and Beyond üåç

The Mediator Pattern isn't just for auction systems. Here are some everyday use cases where it shines:

#### 1. Chat Rooms

A chat room server mediates communication between multiple clients without them needing to know each other.

**Example:**

```java
interface ChatMediator {
    void sendMessage(String message, User user);
    void addUser(User user);
}

class ChatRoom implements ChatMediator {
    private List<User> users = new ArrayList<>();
    
    public void addUser(User user) {
        users.add(user);
    }
    
    public void sendMessage(String message, User sender) {
        for (User user : users) {
            if (user != sender) {
                user.receive(message);
            }
        }
    }
}
```

***

#### 2. Air Traffic Control

An air traffic controller (mediator) manages communication between all airplanes.

**Example:**

```java
class AirTrafficControl {
    private List<Aircraft> aircraft = new ArrayList<>();
    
    public void requestLanding(Aircraft aircraft) {
        // Coordinate with other aircraft
        System.out.println("Cleared for landing: " + aircraft.getId());
    }
}
```

***

#### 3. Smart Home Systems

A central hub coordinates various smart devices (lights, thermostats, security cameras) for smooth operation.

**Example:**

```java
class SmartHomeHub {
    public void handleSensorEvent(Sensor sensor, String event) {
        if (event.equals("motion_detected")) {
            lights.turnOn();
            camera.startRecording();
        }
    }
}
```

***

#### 4. UI Components

Dialogs and widgets communicate through a mediator to keep the UI logic clean and modular.

**Example:**

```java
class DialogMediator {
    private Button okButton;
    private TextField textField;
    
    public void textFieldChanged() {
        okButton.setEnabled(!textField.isEmpty());
    }
}
```

***

### When to Use Mediator Pattern

#### Use Mediator When:

1. **Complex communication** - Many objects communicate in complex ways
2. **Tight coupling** - Objects are tightly coupled and hard to reuse
3. **Scattered logic** - Communication logic scattered across classes
4. **Hard to understand** - Object interactions difficult to understand
5. **Centralized control** - Need single point of control for interactions

#### Don't Use Mediator When:

1. **Simple interactions** - Only few objects with simple interactions
2. **Mediator becomes bloated** - Mediator would become too complex
3. **Performance critical** - Extra indirection causes issues
4. **Overkill** - Pattern adds unnecessary complexity

***

### Key Components

| Component            | Role                                | Example                                |
| -------------------- | ----------------------------------- | -------------------------------------- |
| **Mediator**         | Defines interface for communication | `AuctionMediator` interface            |
| **ConcreteMediator** | Implements coordination logic       | `AuctionHouse`, `ExtendedAuctionHouse` |
| **Colleague**        | Communicates through mediator       | `Bidder` class                         |
| **Client**           | Creates and configures components   | `Main` class                           |

***

### Best Practices

1. **Keep mediator focused** - Don't let it become a god object
2. **Use interfaces** - Define clear mediator contracts
3. **Consider events** - Use event-driven approach when appropriate
4. **Document interactions** - Clear documentation of message flow
5. **Test thoroughly** - Test mediator logic independently
6. **Avoid circular dependencies** - Mediator shouldn't depend on colleagues
7. **Consider alternatives** - Observer pattern for one-to-many scenarios

***

### Mediator vs. Observer Pattern

| Aspect        | Mediator                          | Observer                             |
| ------------- | --------------------------------- | ------------------------------------ |
| **Purpose**   | Centralize complex communications | One-to-many dependency               |
| **Direction** | Bidirectional                     | Unidirectional (subject ‚Üí observers) |
| **Coupling**  | Colleagues know mediator          | Observers know subject               |
| **Use Case**  | Complex interactions              | Simple notifications                 |
| **Example**   | Chat room                         | Newsletter subscription              |

***

### Summary

The Mediator Design Pattern is like having an organized auction house that manages all the communication between bidders.

#### Key Takeaways

**Core Concept:**

* Encapsulate how objects interact
* Objects communicate through mediator
* Reduces dependencies between communicating objects

**Benefits:**

* **Reduced Coupling** - Components independent of each other
* **Simplified Communication** - Central point manages interactions
* **Enhanced Maintainability** - Changes in one place
* **Improved Scalability** - Easy to add new components
* **Greater Reusability** - Self-contained components

**Structure:**

1. Mediator Interface - Defines communication protocol
2. Concrete Mediator - Implements coordination logic
3. Colleagues - Objects that communicate
4. Client - Sets up the system

**Real-World Uses:**

* Chat rooms and messaging systems
* Air traffic control
* Smart home automation
* UI component coordination
* Auction systems

***

### Conclusion

The Mediator Design Pattern is like having an organized auction house that manages all the communication between bidders. It prevents the chaos of direct communication and makes the system more flexible and maintainable.

By centralizing interactions, you keep your code:

* **Clean** - No tangled dependencies
* **Decoupled** - Components independent
* **Ready for extensions** - Easy to add features

Whether it's adding logging, timers, or more features, the mediator makes it simple!

I hope this fun and practical journey into the Mediator Pattern using an auction system has inspired you to try it in your own projects.

**Remember:** The Mediator pattern is about:

* Centralizing communication logic
* Reducing coupling between components
* Making systems easier to maintain and extend
* Providing single point of control

Keep coding, keep learning, and most importantly, have fun along the way! üòÑüëç

Happy coding!

***

### Next Steps

Continue your learning journey by exploring:

* Observer Pattern (related but different)
* Facade Pattern (simplifies complex subsystems)
* Chain of Responsibility (passes requests along chain)
* Event-driven architecture
* Message bus patterns
* Mediator pattern in GUI frameworks
