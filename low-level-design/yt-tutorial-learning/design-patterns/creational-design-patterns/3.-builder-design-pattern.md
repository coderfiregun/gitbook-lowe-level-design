# 3. Builder Design Pattern

## Builder Design Pattern

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/builder-design-pattern)

### 1. What is the Builder Design Pattern?

The **Builder Design Pattern** is a creational design pattern that helps in constructing complex objects step-by-step. This pattern is especially useful when an object has many attributes or optional fields, allowing you to create different configurations of the object easily and clearly.

Instead of using a constructor with many parameters (which can be cumbersome and error-prone), the Builder pattern allows you to separate the construction process from the final object. It allows you to build an object piece by piece, and the final product is assembled only when you call the `build()` method.

**In short:** It's a way to construct an object in a flexible, readable, and maintainable manner.

***

### 2. The Traditional Way: The Problems We Face with Constructors

Now, let's revisit the traditional approach where constructors are used to create objects. Consider we have a `Car` class with many attributes, some of which are optional.

#### Why Constructors?

Constructors were introduced to ensure that objects are created in a valid state right when they are instantiated. The constructor allows you to initialize an object with necessary values and guarantees that all required properties are set up right away.

```java
public class Car {
    private String engine;
    private int wheels;
    private int seats;
    private String color;
    private boolean sunroof;
    private boolean navigationSystem;
    
    public Car(String engine, int wheels, int seats, String color,
               boolean sunroof, boolean navigationSystem) {
        this.engine = engine;
        this.wheels = wheels;
        this.seats = seats;
        this.color = color;
        this.sunroof = sunroof;
        this.navigationSystem = navigationSystem;
    }
}
```

While this approach works, as we can see, there are several drawbacks:

***

#### Problem #1: Passing Unnecessary Values

When you need to set optional attributes, such as `sunroof` or `navigation system`, you have to pass values for all parameters, even if they aren't necessary.

```java
// The client needs to pass `false` for optional attributes
Car car = new Car("V8", 4, 5, "Red", false, false);
```

**Issue:** You must provide values for all parameters, even those you don't care about, making the code verbose and error-prone.

***

#### Problem #2: Constructor Overloading and Huge Combinations

If a car has many optional attributes, you end up with multiple constructors, each for different combinations of parameters. This results in code duplication and leads to messy and unmanageable code.

```java
public class Car {
    // Constructor with all parameters
    public Car(String engine, int wheels, int seats, String color,
               boolean sunroof, boolean navigationSystem) {
        // ...
    }
    
    // Constructor without navigation system
    public Car(String engine, int wheels, int seats, String color) {
        // ...
    }
    
    // Constructor with only basic features
    public Car(String engine, int wheels, int seats) {
        // ...
    }
}
```

**Issue:** The more attributes you add, the more combinations you have, leading to **constructor bloat**. Every time you add a new feature (like sports seats or a premium sound system), you need to add more constructors.

**Combinatorial Explosion Example:**

* 6 attributes with optional values = potentially 2^6 = 64 different constructor combinations!

***

#### Problem #3: Lack of Readability

The client code becomes hard to read because of unlabeled parameters in constructors. Here's a constructor that takes in multiple parameters, but it's hard to tell what each parameter represents:

```java
Car car = new Car("V8", 4, 5, "Red", true, false);
```

**Questions that arise:**

* What does `true` represent?
* What does `false` represent?
* What's the order of parameters?

This is difficult to understand at a glance. What do the `true` and `false` values represent? The client would have to refer to documentation to know which value represents the sunroof or navigation system, which isn't ideal.

***

### 3. Solving the Problem with Constructors: Follow-up Question by the Interviewer

An interviewer might ask:

* **What if you need to add more optional attributes?**
* **What if the object creation needs to be more flexible, especially when dealing with large objects or more parameters?**

The client realizes that as the number of attributes grows, constructors become harder to maintain. They quickly realize that constructor overloading doesn't scale well.

**Problems Summary:**

| Issue                       | Impact                                            |
| --------------------------- | ------------------------------------------------- |
| **Too many parameters**     | Hard to remember order, easy to make mistakes     |
| **Constructor overloading** | Exponential growth in number of constructors      |
| **Lack of clarity**         | Difficult to understand what each parameter means |
| **Maintenance nightmare**   | Every new attribute requires new constructors     |
| **No default values**       | Must pass values for all parameters               |

***

### 4. Shifting to the Builder Design Pattern

#### Why is it Named the "Builder" Pattern?

The Builder Design Pattern is so named because it allows you to **build an object step-by-step**. The builder is responsible for assembling an object, and you control the process by setting attributes one by one. Instead of passing all parameters in a constructor, you pass only the ones you care about, and the builder takes care of the rest.

**Think of it like building a house:**

* You don't construct a house all at once
* You build it step-by-step: foundation, walls, roof, interior
* Each step is clear and controlled
* The final product is assembled when you call `build()`

***

#### How Does It Work?

Let's see how we can implement the Builder Pattern to create a `Car` with flexibility and clarity.

```java
public class Car {
    private String engine;
    private int wheels;
    private int seats;
    private String color;
    private boolean sunroof;
    private boolean navigationSystem;
    
    // Car constructor should be private, ensuring it's only created through the builder
    private Car(CarBuilder builder) {
        this.engine = builder.engine;
        this.wheels = builder.wheels;
        this.seats = builder.seats;
        this.color = builder.color;
        this.sunroof = builder.sunroof;
        this.navigationSystem = builder.navigationSystem;
    }

    // Getter methods for the fields
    public String getEngine() {
        return engine;
    }
    
    public int getWheels() {
        return wheels;
    }
    
    public int getSeats() {
        return seats;
    }
    
    public String getColor() {
        return color;
    }
    
    public boolean hasSunroof() {
        return sunroof;
    }
    
    public boolean hasNavigationSystem() {
        return navigationSystem;
    }
    
    @Override
    public String toString() {
        return "Car [engine=" + engine + ", wheels=" + wheels + ", seats=" + seats
                + ", color=" + color + ", sunroof=" + sunroof
                + ", navigationSystem=" + navigationSystem + "]";
    }

    // CarBuilder nested class
    public static class CarBuilder {
        private String engine;
        private int wheels = 4;              // Default value
        private int seats = 5;               // Default value
        private String color = "Black";      // Default value
        private boolean sunroof = false;     // Default value
        private boolean navigationSystem = false; // Default value

        // Builder methods to set attributes
        public CarBuilder setEngine(String engine) {
            this.engine = engine;
            return this;
        }
        
        public CarBuilder setWheels(int wheels) {
            this.wheels = wheels;
            return this;
        }
        
        public CarBuilder setSeats(int seats) {
            this.seats = seats;
            return this;
        }
        
        public CarBuilder setColor(String color) {
            this.color = color;
            return this;
        }
        
        public CarBuilder setSunroof(boolean sunroof) {
            this.sunroof = sunroof;
            return this;
        }
        
        public CarBuilder setNavigationSystem(boolean navigationSystem) {
            this.navigationSystem = navigationSystem;
            return this;
        }

        // Build method to create a Car object
        public Car build() {
            return new Car(this); // Return a new Car created using the builder's values
        }
    }
}
```

***

#### Client Code

Here's how the client would use the `CarBuilder` to create `Car` objects:

```java
public class Main {
    public static void main(String[] args) {
        // Creating a car using the Builder pattern
        Car.CarBuilder builder = new Car.CarBuilder();
        Car car1 = builder.setEngine("V8")
                         .setColor("Red")
                         .setSeats(5)
                         .setSunroof(true)
                         .build(); // The build method returns the final product
        System.out.println(car1);

        // Creating another car with different specifications
        Car car2 = builder.setEngine("V6")
                         .setColor("Blue")
                         .setSeats(4)
                         .build(); // Sunroof and Navigation are default
        System.out.println(car2);
    }
}
```

**Output:**

```
Car [engine=V8, wheels=4, seats=5, color=Red, sunroof=true, navigationSystem=false]
Car [engine=V6, wheels=4, seats=4, color=Blue, sunroof=false, navigationSystem=false]
```

**Notice the improvement:**

* Clear, readable code
* Only set what you need
* Default values for unset attributes
* Method chaining for fluent API
* Self-documenting code

***

### Why is the CarBuilder Nested in the Car Class?

#### 1. Encapsulation

The `CarBuilder` is tightly related to the `Car` class, so it's grouped inside it. This makes it clear that the builder is for creating `Car` objects.

**Example:**

```java
Car.CarBuilder builder = new Car.CarBuilder(); // Clear that builder is for Car
```

***

#### 2. Access to Private Fields

The `CarBuilder` can directly access private fields of `Car` (like `engine`, `wheels`) without needing getters/setters.

**Benefit:** The constructor can remain private, ensuring objects are only created through the builder.

***

#### 3. Logical Grouping

By nesting, we keep the `CarBuilder` and `Car` together, making the code cleaner and easier to understand.

**Alternative (Not Recommended):**

```java
// Separate files - harder to maintain
Car.java
CarBuilder.java // In separate file - less cohesive
```

***

### Why is the CarBuilder Static?

#### 1. No Need for Car Instance

The `CarBuilder` doesn't need an instance of `Car` to create a new one, so it's made static. You can use the builder without creating a `Car` object first.

**Example:**

```java
// Can create builder directly without Car instance
Car.CarBuilder builder = new Car.CarBuilder();
```

***

#### 2. Efficiency

It avoids unnecessary object creation. You don't need to instantiate `Car` just to use the builder.

**What if it wasn't static?**

```java
// Would need to do this (inefficient):
Car tempCar = new Car(); // Create car just to get builder
Car.CarBuilder builder = tempCar.new CarBuilder();
```

***

#### 3. Simpler Usage

The static builder allows clients to create a `Car` object directly with `Car.CarBuilder()` without needing a separate builder instance.

**Clean API:**

```java
Car car = new Car.CarBuilder()
    .setEngine("V8")
    .setColor("Red")
    .build();
```

***

### Structure Explanation

#### Car Class

* Contains the attributes (`engine`, `wheels`, `seats`, `color`, `sunroof`, `navigationSystem`) and methods to retrieve them
* The `Car` constructor is **private**, ensuring it is created only through the `CarBuilder`

#### CarBuilder Class

* Has the same attributes as `Car`, but they are mutable, and it allows setting these attributes via builder methods
* The `build()` method is used to create a `Car` object by passing the builder as a parameter to the `Car` constructor

**Relationships:**

* The `CarBuilder` is used by `Car` to construct a `Car` object
* The `CarBuilder` class returns a `Car` instance using the `build()` method
* The `CarBuilder` class is nested inside the `Car` class

***

### 5. Solving the Interviewer's Follow-Up Questions with the Builder

#### Question 1: What if we only want to set some attributes?

With the Builder pattern, you can only set the attributes you care about, and the rest of the attributes will take default values.

**Example:**

```java
// Only setting engine and color, rest are defaults
Car simpleCar = new Car.CarBuilder()
    .setEngine("V6")
    .setColor("Silver")
    .build();
// wheels=4, seats=5, sunroof=false, navigationSystem=false (all defaults)
```

For example, if the client doesn't care about the sunroof or navigation system, they can skip those methods, and the car will be created with default values for those fields.

***

#### Question 2: What if I want to add new attributes in the future?

The Builder pattern makes this easy. You can simply add a new setter method to the builder class. No need to change the client code or the rest of the builder methods.

**Example - Adding Sport Seats:**

```java
public static class CarBuilder {
    // Existing attributes...
    private boolean sportSeats = false; // New attribute
    
    // New setter method
    public CarBuilder setSportSeats(boolean sportSeats) {
        this.sportSeats = sportSeats;
        return this;
    }
    
    // Existing methods remain unchanged...
}
```

**Impact on existing code:** ZERO! All existing client code continues to work.

For instance, you could add a "sportsSeats" feature later by adding one line in the `CarBuilder` class, and the client doesn't have to modify their existing code.

***

### Comparison: Constructor vs. Builder Pattern

| Aspect                  | Traditional Constructor        | Builder Pattern                |
| ----------------------- | ------------------------------ | ------------------------------ |
| **Readability**         | Poor - unclear parameter order | Excellent - self-documenting   |
| **Optional Parameters** | Must pass all parameters       | Only set what you need         |
| **Default Values**      | Requires multiple constructors | Built into builder             |
| **Scalability**         | Poor - combinatorial explosion | Excellent - add methods easily |
| **Maintainability**     | Difficult - many constructors  | Easy - one builder class       |
| **Error-Prone**         | High - easy to swap parameters | Low - named methods            |
| **Flexibility**         | Limited                        | High                           |
| **Code Length**         | Short for simple cases         | More code but clearer          |

***

### 6. Real-life Use Cases of the Builder Pattern

#### 1. Building Complex Meals

Imagine creating a custom meal order (e.g., selecting burger size, toppings, drinks). The Builder Pattern lets you choose only the options you care about, making the process cleaner.

**Example:**

```java
Meal meal = new MealBuilder()
    .setBurgerSize("Large")
    .addTopping("Cheese")
    .addTopping("Lettuce")
    .setDrink("Coke")
    .build();
```

**Use Case:** Restaurant ordering systems, food delivery apps

***

#### 2. Creating Documents

When creating complex documents (reports, articles), where sections might vary (like titles, images, or tables), the Builder Pattern helps assemble them step-by-step.

**Example:**

```java
Document report = new DocumentBuilder()
    .setTitle("Annual Report")
    .addSection("Introduction")
    .addTable(salesData)
    .addChart(growthChart)
    .setFooter("Confidential")
    .build();
```

**Use Case:** Report generators, PDF builders, email templates

***

#### 3. User Profile Creation

When building user profiles in apps, where there are multiple options (name, email, preferences), the Builder Pattern allows customization without cluttering the code.

**Example:**

```java
UserProfile profile = new UserProfileBuilder()
    .setUsername("john_doe")
    .setEmail("john@example.com")
    .setAge(25)
    .setNotifications(true)
    .setTheme("dark")
    .build();
```

**Use Case:** Social media apps, account creation forms

***

#### 4. Other Common Uses

* **HTTP Request Building** - `HttpRequest.Builder` in Java
* **String Building** - `StringBuilder` in Java
* **Database Query Building** - SQL query builders
* **Test Data Creation** - Creating test objects with specific configurations
* **Configuration Objects** - Application settings and preferences

***

### When to Use Builder Pattern

#### Use Builder Pattern When:

1. **Many parameters** - Object has 4+ constructor parameters
2. **Optional parameters** - Many attributes are optional
3. **Immutability desired** - Want to create immutable objects
4. **Complex construction** - Object creation requires multiple steps
5. **Readability important** - Code clarity is a priority
6. **Telescoping constructors** - Suffering from constructor explosion

#### Don't Use Builder Pattern When:

1. **Simple objects** - Object has 2-3 parameters
2. **No optional parameters** - All attributes are required
3. **Performance critical** - Extra object creation is unacceptable
4. **Overkill** - Pattern adds unnecessary complexity

***

### Best Practices

1. **Make constructor private** - Force use of builder
2. **Return 'this' in setters** - Enable method chaining
3. **Provide default values** - For optional parameters
4. **Validate in build()** - Ensure object is valid before creation
5. **Use descriptive names** - `setColor()` not `color()`
6. **Consider immutability** - Make final object immutable
7. **Nest builder in class** - Keep related code together

**Validation Example:**

```java
public Car build() {
    if (engine == null || engine.isEmpty()) {
        throw new IllegalStateException("Engine must be specified");
    }
    if (seats < 2 || seats > 8) {
        throw new IllegalArgumentException("Seats must be between 2 and 8");
    }
    return new Car(this);
}
```

***

### Summary

The Builder Design Pattern is an excellent solution for creating complex objects in a flexible, clear, and maintainable way.

#### Key Takeaways

**Core Concept:**

* Constructs complex objects step-by-step
* Separates construction from representation
* Provides fine control over construction process
* Returns fully constructed object with `build()` method

**Benefits:**

* **Readability** - Self-documenting code with named methods
* **Flexibility** - Set only the attributes you need
* **Maintainability** - Easy to add new attributes
* **Default Values** - Built-in support for optional parameters
* **Immutability** - Can create immutable objects easily
* **Type Safety** - Compile-time checking of parameters

**Key Components:**

1. **Product** - The complex object being built (`Car`)
2. **Builder** - Provides methods to configure the product (`CarBuilder`)
3. **Build Method** - Returns the final constructed product
4. **Private Constructor** - Ensures creation only through builder

**When to Use:**

* Objects with many parameters (4+)
* Many optional parameters
* Need for immutable objects
* Desire for readable, maintainable code

***

### Conclusion: Building Complex Objects the Smart Way

The Builder Design Pattern is an excellent solution for creating complex objects in a flexible, clear, and maintainable way. Unlike constructors, which can become messy and unmanageable with many parameters, the Builder pattern allows you to create objects step-by-step, setting only the attributes you care about.

It provides default values, allows easy extensibility, and keeps the client code clean and understandable.

This pattern is ideal when you need to handle complex object creation without sacrificing flexibility or readability. Whether you're building cars, meals, or user profiles, the Builder Pattern ensures that objects are constructed in an organized, step-by-step manner.

**Remember:** The Builder pattern shines when you have:

* Multiple optional parameters
* A need for immutable objects
* Desire for readable, self-documenting code
* Complex object construction logic

By mastering the Builder pattern, you gain a powerful tool for creating objects in a clean, flexible, and maintainable way.

***

### Next Steps

Continue your learning journey by exploring:

* Fluent Interface design
* Method chaining techniques
* Immutable object patterns
* Lombok's `@Builder` annotation
* Other creational patterns (Factory, Singleton, Prototype)
* Validation strategies in builders
