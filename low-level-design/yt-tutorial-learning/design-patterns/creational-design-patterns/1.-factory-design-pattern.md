# 1. Factory Design Pattern

## Factory Design Pattern

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/factory-design-pattern)

### Problem Statement: Creating Objects Dynamically

Imagine you're building a software system to manage vehicles for a transportation company. The system needs to create different types of vehicles such as Car, Truck, and Bike. These vehicles have different characteristics, but they all share a few common behaviors like `start()` and `stop()`.

Now, each time you need to create a vehicle, you have to decide which class to instantiate: Car, Truck, or Bike. If your application has many places where vehicles are created, maintaining all these object creation codes in different classes becomes messy.

**So, the problem is:** How can we create vehicles easily and cleanly without hard-coding the class names everywhere in the code?

***

### The Scenario

Imagine you're building a software system to manage vehicles for a transportation company. The system needs to create different types of vehicles such as:

* Car
* Truck
* Bike

Each of these vehicles has different characteristics, but they all share a few common behaviors:

* `start()`
* `stop()`

***

### The Problem

Each time you need to create a vehicle, you have to decide manually which class to instantiate:

* Car
* Truck
* Bike

If your application has many places where vehicles are created, maintaining all these object creation codes in different classes becomes messy!

> **Hard-coding class names everywhere = bad maintainability!**

***

### The Challenge

**How can we create vehicles easily and cleanly without hard-coding the class names everywhere in the code?**

Common issues with direct object creation:

* Code duplication across multiple locations
* Hard to add new vehicle types
* Difficult to change creation logic
* Tight coupling between client code and concrete classes
* Poor maintainability

***

### Solving it with Traditional Approach

Let's start by solving the problem in the traditional way, where each class creates its own objects!

```java
// Vehicle.java - Common interface
public interface Vehicle {
    void start();
    void stop();
}

// Car.java - Concrete class for Car
public class Car implements Vehicle {
    public void start() {
        System.out.println("Car is starting...");
    }
    
    public void stop() {
        System.out.println("Car is stopping...");
    }
}

// Truck.java - Concrete class for Truck
public class Truck implements Vehicle {
    public void start() {
        System.out.println("Truck is starting...");
    }
    
    public void stop() {
        System.out.println("Truck is stopping...");
    }
}

// Bike.java - Concrete class for Bike
public class Bike implements Vehicle {
    public void start() {
        System.out.println("Bike is starting...");
    }
    
    public void stop() {
        System.out.println("Bike is stopping...");
    }
}

// Main.java - Code to create vehicles
public class Main {
    public static void main(String[] args) {
        Vehicle vehicle1 = new Car();
        vehicle1.start();
        vehicle1.stop();
        
        Vehicle vehicle2 = new Truck();
        vehicle2.start();
        vehicle2.stop();
        
        Vehicle vehicle3 = new Bike();
        vehicle3.start();
        vehicle3.stop();
    }
}
```

**Output:**

```
Car is starting...
Car is stopping...
Truck is starting...
Truck is stopping...
Bike is starting...
Bike is stopping...
```

**Issue with This Approach:**

Here, the `Main` class creates each vehicle explicitly by calling the constructor of the respective vehicle class. But what if we need to add more vehicle types later, or if we need to change the way vehicles are created?

***

### Interviewer's Follow-up Questions: Can We Improve the Code?

An interviewer might ask:

* **What if we need to add more vehicle types in the future?**
* **What if the logic of vehicle creation changes?**

In this case, the code could become harder to maintain as you add more vehicle types or change the vehicle creation logic. For example, if you had to introduce new behavior or properties for vehicle creation, you would need to modify the creation code in many places, which could lead to potential errors.

***

### Ugly Code: When We Realize the Code Needs Restructuring

Let's say, instead of creating vehicles directly, the vehicle creation process is now complex. For example, you have to choose the vehicle based on user input, configuration files, or network requests. If you don't address this early on, the object creation code quickly becomes cumbersome and ugly.

It might look something like this:

```java
// Main.java becomes a mess as you add more vehicle creation logic
public class Main {
    public static void main(String[] args) {
        String vehicleType = "Truck"; // Imagine this value is dynamic
        Vehicle vehicle;
        
        if (vehicleType.equals("Car")) {
            vehicle = new Car();
        } else if (vehicleType.equals("Truck")) {
            vehicle = new Truck();
        } else if (vehicleType.equals("Bike")) {
            vehicle = new Bike();
        } else {
            throw new IllegalArgumentException("Unknown vehicle type");
        }
        
        vehicle.start();
        vehicle.stop();
    }
}
```

**Output:**

```
Truck is starting...
Truck is stopping...
```

**Why This Code is Problematic:**

This code is fragile. If we want to add another vehicle type, we need to modify this code again, which is error-prone and hard to maintain.

**Issues:**

1. **Violation of Open/Closed Principle** - Code must be modified to add new types
2. **Code duplication** - Similar if-else logic might be repeated in multiple places
3. **Hard to test** - Difficult to mock or test object creation
4. **Poor maintainability** - Changes require modifying existing code
5. **Tight coupling** - Client code directly depends on concrete classes

***

### The Savior: Factory Design Pattern

Now, let's introduce the **Factory Design Pattern** to rescue us. The Factory Pattern will allow us to handle the object creation in a centralized manner, so that we don't need to keep repeating the logic of choosing which vehicle to create in multiple places.

#### Why is it Called "Factory"?

The Factory Design Pattern is named after a **"factory"** because, just like a factory produces different types of products, the pattern provides a central place (the factory) to create objects of different types. Instead of directly instantiating objects, the factory method is responsible for producing the correct object, making the system more flexible and organized.

**Think of it like this:**

* A real factory manufactures different products based on orders
* Similarly, a Factory pattern creates different objects based on parameters
* The client doesn't need to know the manufacturing details
* Just place an order (call the factory method) and get the product (object)

***

### Solving the Problem with Factory Design Pattern

Here's how we can solve this problem by introducing a Factory that creates the vehicles:

```java
// Vehicle.java - Common interface
public interface Vehicle {
    void start();
    void stop();
}

// Concrete vehicle classes remain the same
public class Car implements Vehicle {
    public void start() {
        System.out.println("Car is starting...");
    }
    
    public void stop() {
        System.out.println("Car is stopping...");
    }
}

public class Truck implements Vehicle {
    public void start() {
        System.out.println("Truck is starting...");
    }
    
    public void stop() {
        System.out.println("Truck is stopping...");
    }
}

public class Bike implements Vehicle {
    public void start() {
        System.out.println("Bike is starting...");
    }
    
    public void stop() {
        System.out.println("Bike is stopping...");
    }
}

// VehicleFactory.java - Factory to create vehicles
public class VehicleFactory {
    public static Vehicle getVehicle(String vehicleType) {
        if (vehicleType.equals("Car")) {
            return new Car();
        } else if (vehicleType.equals("Truck")) {
            return new Truck();
        } else if (vehicleType.equals("Bike")) {
            return new Bike();
        } else {
            throw new IllegalArgumentException("Unknown vehicle type");
        }
    }
}

// Main.java - Simplified with Factory
public class Main {
    public static void main(String[] args) {
        Vehicle vehicle1 = VehicleFactory.getVehicle("Car");
        vehicle1.start();
        vehicle1.stop();
        
        Vehicle vehicle2 = VehicleFactory.getVehicle("Truck");
        vehicle2.start();
        vehicle2.stop();
        
        Vehicle vehicle3 = VehicleFactory.getVehicle("Bike");
        vehicle3.start();
        vehicle3.stop();
    }
}
```

**Output:**

```
Car is starting...
Car is stopping...
Truck is starting...
Truck is stopping...
Bike is starting...
Bike is stopping...
```

***

### Advantages of Using the Factory Design Pattern

Let's review how the Factory Pattern improves our solution:

#### 1. Centralized Object Creation

The `VehicleFactory` class handles all the logic of creating vehicles. Now, you only need to call the `getVehicle()` method with the desired vehicle type, and the factory will take care of the rest. This makes the code much cleaner and easier to maintain.

**Benefit:** All creation logic in one place - easy to find and modify

***

#### 2. Scalability

If you want to add a new vehicle type, say `Bus`, you only need to:

1. Create the `Bus` class implementing `Vehicle`
2. Update the `VehicleFactory` class

No changes are needed in the rest of the application.

**Before (Adding Bus):**

```java
// Would need to update if-else logic everywhere vehicles are created
```

**After (With Factory):**

```java
// VehicleFactory.java - Only update in one place
public class VehicleFactory {
    public static Vehicle getVehicle(String vehicleType) {
        if (vehicleType.equals("Car")) {
            return new Car();
        } else if (vehicleType.equals("Truck")) {
            return new Truck();
        } else if (vehicleType.equals("Bike")) {
            return new Bike();
        } else if (vehicleType.equals("Bus")) {  // New addition
            return new Bus();
        } else {
            throw new IllegalArgumentException("Unknown vehicle type");
        }
    }
}
```

***

#### 3. Encapsulation

The client code (in `Main.java`) no longer needs to know how to create the vehicles. The logic is abstracted away in the `VehicleFactory` class, which makes the system easier to manage.

**Benefit:** Client code is decoupled from concrete implementations

***

### Comparison: Before vs. After Factory Pattern

| Aspect               | Without Factory                       | With Factory                        |
| -------------------- | ------------------------------------- | ----------------------------------- |
| **Object Creation**  | Scattered throughout code             | Centralized in factory              |
| **Adding New Types** | Modify multiple locations             | Modify only factory                 |
| **Maintainability**  | Difficult - changes affect many files | Easy - changes in one place         |
| **Code Duplication** | High - if-else repeated               | Low - logic in factory only         |
| **Coupling**         | Tight - client knows concrete classes | Loose - client knows only interface |
| **Testability**      | Hard - difficult to mock              | Easy - can mock factory             |
| **Flexibility**      | Low - hard-coded dependencies         | High - dynamic creation             |

***

### Real-life Use Cases and Examples

The Factory Design Pattern is widely used in real-world software development. Here are some examples:

#### 1. Database Connections

When creating a connection to different types of databases (e.g., MySQL, PostgreSQL, Oracle), the factory can handle the creation of database connections based on configuration parameters without exposing the details to the client.

**Example:**

```java
public class DatabaseConnectionFactory {
    public static Connection getConnection(String dbType) {
        if (dbType.equals("MySQL")) {
            return new MySQLConnection();
        } else if (dbType.equals("PostgreSQL")) {
            return new PostgreSQLConnection();
        } else if (dbType.equals("Oracle")) {
            return new OracleConnection();
        }
        throw new IllegalArgumentException("Unknown database type");
    }
}
```

**Use Case:** Application needs to support multiple databases without changing business logic.

***

#### 2. User Interface Elements

In GUI libraries, different platforms (Windows, Mac, Linux) may require different implementations of buttons, windows, and menus. A factory pattern can be used to create the appropriate UI elements for the specific platform.

**Example:**

```java
public class UIElementFactory {
    public static Button createButton(String platform) {
        if (platform.equals("Windows")) {
            return new WindowsButton();
        } else if (platform.equals("Mac")) {
            return new MacButton();
        } else if (platform.equals("Linux")) {
            return new LinuxButton();
        }
        throw new IllegalArgumentException("Unknown platform");
    }
}
```

**Use Case:** Cross-platform applications that need native-looking UI elements.

***

#### 3. Logging

Depending on the logging requirements (e.g., logging to a file, console, or database), a factory can create the correct type of logger, allowing different components of the system to use the logger without knowing its exact implementation.

**Example:**

```java
public class LoggerFactory {
    public static Logger getLogger(String loggerType) {
        if (loggerType.equals("File")) {
            return new FileLogger();
        } else if (loggerType.equals("Console")) {
            return new ConsoleLogger();
        } else if (loggerType.equals("Database")) {
            return new DatabaseLogger();
        }
        throw new IllegalArgumentException("Unknown logger type");
    }
}
```

**Use Case:** Application needs flexible logging to different destinations.

***

### When to Use Factory Design Pattern

#### Use Factory Pattern When:

1. **Object creation is complex** - Multiple steps or configuration required
2. **Type determined at runtime** - The exact type isn't known until the program runs
3. **Centralized creation logic needed** - Want to manage creation in one place
4. **Multiple similar objects** - Creating several objects of related types
5. **Decoupling required** - Client shouldn't depend on concrete classes

#### Don't Use Factory Pattern When:

1. **Simple object creation** - `new Object()` is sufficient
2. **Only one type** - No need for factory if there's only one implementation
3. **No variation** - Object creation doesn't vary based on conditions
4. **Overengineering** - Adding unnecessary complexity to simple scenarios

***

### Key Components of Factory Pattern

| Component             | Role                           | Example                        |
| --------------------- | ------------------------------ | ------------------------------ |
| **Product Interface** | Defines common interface       | `Vehicle` interface            |
| **Concrete Products** | Implement the interface        | `Car`, `Truck`, `Bike` classes |
| **Factory**           | Creates objects based on input | `VehicleFactory` class         |
| **Client**            | Uses factory to get objects    | `Main` class                   |

***

### Best Practices

1. **Keep factory simple** - Don't overload with complex logic
2. **Use enums for types** - Instead of strings, use enums for type safety
3. **Consider using switch** - Can be cleaner than multiple if-else
4. **Handle unknown types** - Throw meaningful exceptions
5. **Make factory methods static** - If no state is needed
6. **Document supported types** - Clear documentation helps users

**Improved Version with Enum:**

```java
public enum VehicleType {
    CAR, TRUCK, BIKE
}

public class VehicleFactory {
    public static Vehicle getVehicle(VehicleType type) {
        switch (type) {
            case CAR:
                return new Car();
            case TRUCK:
                return new Truck();
            case BIKE:
                return new Bike();
            default:
                throw new IllegalArgumentException("Unknown vehicle type");
        }
    }
}

// Usage
Vehicle car = VehicleFactory.getVehicle(VehicleType.CAR);
```

***

### Summary

The Factory Design Pattern simplifies object creation by centralizing it in a factory, making the code cleaner, more maintainable, and easier to extend.

#### Key Takeaways

**Core Concept:**

* Centralizes object creation logic in a factory class
* Client code requests objects without knowing how they're created
* Factory decides which class to instantiate based on parameters

**Benefits:**

* **Centralized creation** - All logic in one place
* **Easy to extend** - Add new types with minimal changes
* **Loose coupling** - Clients don't depend on concrete classes
* **Better maintainability** - Changes in one location
* **Improved testability** - Easier to mock and test

**When to Use:**

* Multiple related classes with common interface
* Object type determined at runtime
* Complex creation logic needs centralization
* Want to decouple client from concrete classes

**Real-World Usage:**

* Database connection management
* Cross-platform UI element creation
* Logging framework configuration
* Plugin systems and extensible architectures

***

### Conclusion

The Factory Design Pattern simplifies object creation by centralizing it in a factory, making the code cleaner, more maintainable, and easier to extend. It ensures that we can easily add new types or change the instantiation logic without touching the client code.

This pattern is highly beneficial when your application needs to create a variety of objects in a flexible and scalable way. By abstracting the creation process, you achieve:

* **Flexibility** - Easy to add new product types
* **Maintainability** - Changes in one central location
* **Scalability** - System grows without major refactoring
* **Clean Code** - Separation of concerns and reduced coupling

The Factory Pattern is one of the most commonly used design patterns and forms the foundation for more complex patterns like Abstract Factory and Builder. Master this pattern, and you'll have a powerful tool in your software design toolkit.

***

### Next Steps

Continue your learning journey by exploring:

* Abstract Factory Pattern (creates families of related objects)
* Factory Method Pattern (lets subclasses decide which class to instantiate)
* Builder Pattern (constructs complex objects step by step)
* Singleton Pattern (ensures only one instance exists)
* Dependency Injection and Inversion of Control
