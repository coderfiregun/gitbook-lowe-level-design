# 6. Inheritance and it's types

## Inheritance and Its Types

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/inheritance-and-its-types)

### Overview

Inheritance is a cornerstone of Object-Oriented Programming (OOP) that facilitates code reuse and establishes a hierarchical relationship between classes. By inheriting properties and methods from a parent class, a subclass can extend or override functionalities, enabling efficient and scalable application development.

This promotes code reuse, reduces redundancy, and supports polymorphism, making applications easier to develop and maintain.

***

### Types of Inheritance

#### 1. Single Inheritance

In single inheritance, a subclass inherits from a single parent class. This is the simplest form of inheritance and is widely used in Java.

**Example:**

```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // Inherited method
        dog.bark();
    }
}
```

**Output:**

```
This animal eats food.
The dog barks.
```

**Key Features:**

* A single subclass derives from one superclass
* Promotes simplicity and clarity in the inheritance hierarchy

***

#### 2. Multilevel Inheritance

In multilevel inheritance, a class inherits from a parent class, and another class further inherits from this child class, forming a chain.

**Example:**

```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Mammal extends Animal {
    void walk() {
        System.out.println("This mammal walks.");
    }
}

class Dog extends Mammal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // Inherited from Animal
        dog.walk();  // Inherited from Mammal
        dog.bark();
    }
}
```

**Output:**

```
This animal eats food.
This mammal walks.
The dog barks.
```

**Key Features:**

* Establishes a chain of inheritance
* Enables deeper specialization of classes

***

#### 3. Hierarchical Inheritance

In hierarchical inheritance, multiple subclasses inherit from a single parent class. This allows different classes to share common properties and behaviors defined in the superclass.

**Example:**

```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

class Cat extends Animal {
    void meow() {
        System.out.println("The cat meows.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();
        dog.bark();

        Cat cat = new Cat();
        cat.eat();
        cat.meow();
    }
}
```

**Output:**

```
This animal eats food.
The dog barks.
This animal eats food.
The cat meows.
```

**Key Features:**

* Multiple subclasses share common properties from a single superclass
* Promotes code reuse and modularity

***

#### 4. Multiple Inheritance

Java does not support multiple inheritance directly due to the diamond problem, but it can be achieved using interfaces. In multiple inheritance, a single class can inherit properties from multiple interfaces.

**What is the Diamond Problem?**

The diamond problem arises in languages that allow multiple inheritance with classes. Imagine a scenario where a class inherits from two parent classes that both have a method with the same name. If the child class does not override the method, it creates ambiguity as to which implementation the child class should inherit.

**Problem Example:**

```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

// Not supported in Java - This will cause a compilation error
public class HybridAnimal extends Dog, Cat {
    public static void main(String[] args) {
        HybridAnimal hybrid = new HybridAnimal();
        hybrid.sound(); // Ambiguity: Should it call Dog's sound() or Cat's sound()?
    }
}
```

**How Java Resolves This**

Java avoids this problem by not allowing multiple inheritance with classes. Instead, Java provides interfaces as a way to achieve multiple inheritance. When a class implements multiple interfaces, it must provide implementations for the methods defined in the interfaces, eliminating ambiguity.

**Solution Example:**

```java
interface Dog {
    default void sound() {
        System.out.println("Dog barks");
    }
}

interface Cat {
    default void sound() {
        System.out.println("Cat meows");
    }
}

public class HybridAnimal implements Dog, Cat {
    @Override
    public void sound() {
        // You can define custom logic to decide which sound to make
        Dog.super.sound(); // Calls Dog's sound()
        // Cat.super.sound(); // Or you can choose to call Cat's sound()
    }

    public static void main(String[] args) {
        HybridAnimal hybrid = new HybridAnimal();
        hybrid.sound(); // Calls Dog's sound
    }
}
```

**Output:**

```
Dog barks
```

**Key Features:**

* Achieved using interfaces to avoid ambiguity caused by multiple inheritance
* Combines the benefits of various inheritance types
* Eliminates the diamond problem by requiring explicit method implementation

***

#### 5. Hybrid Inheritance

Hybrid inheritance is a combination of more than one type of inheritance. It can involve both single inheritance and multiple inheritance.

In Java, hybrid inheritance is achieved by combining classes and interfaces. Since Java doesn't support multiple inheritance with classes (to avoid the diamond problem), this type of inheritance can only be implemented using interfaces alongside class inheritance.

**Example:**

```java
// Single inheritance
class Animal {
    void eat() {
        System.out.println("The animal eats food.");
    }
}

// Interface for multiple inheritance
interface Mammal {
    void walk();
}

// Interface for multiple inheritance
interface Pet {
    void play();
}

// Hybrid inheritance using a combination of class and interfaces
class Dog extends Animal implements Mammal, Pet {
    @Override
    void eat() {
        System.out.println("The dog eats food.");
    }

    @Override
    public void walk() {
        System.out.println("The dog walks.");
    }

    @Override
    public void play() {
        System.out.println("The dog plays fetch.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();
        dog.walk();
        dog.play();
    }
}
```

**Output:**

```
The dog eats food.
The dog walks.
The dog plays fetch.
```

***

### Inheritance Types Summary

| Type             | Description                                     | Java Support                  |
| ---------------- | ----------------------------------------------- | ----------------------------- |
| **Single**       | One subclass inherits from one superclass       | ✅ Fully supported             |
| **Multilevel**   | Chain of inheritance (A → B → C)                | ✅ Fully supported             |
| **Hierarchical** | Multiple subclasses inherit from one superclass | ✅ Fully supported             |
| **Multiple**     | One class inherits from multiple parents        | ⚠️ Only via interfaces        |
| **Hybrid**       | Combination of multiple inheritance types       | ⚠️ Using classes + interfaces |

***

### Advantages of Inheritance

#### 1. Code Reusability

Enables reuse of existing code, reducing redundancy and effort.

**Example:**

```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    // Inherits eat() method from Animal
}

class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat(); // Reuses the eat method from Animal
    }
}
```

**Output:**

```
Animal is eating
```

***

#### 2. Ease of Maintenance

Centralizes common functionality, making updates and bug fixes more manageable.

**Example:**

```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    // Inherits eat() method from Animal
}

class Cat extends Animal {
    // Inherits eat() method from Animal
}

public class Main {
    public static void main(String[] args) {
        // If we need to fix a bug in eat() or improve it,
        // we only need to do it in Animal
        Animal animal = new Dog();
        animal.eat(); // Animal is eating

        animal = new Cat();
        animal.eat(); // Animal is eating
    }
}
```

> **Key Point:** If we need to fix a bug in the `eat()` method or refactor it, we only need to do it in the `Animal` class and it will be implemented for all subclasses.

***

#### 3. Extensibility

Allows developers to extend functionality without altering existing code.

**Example:**

```java
class Animal {
    public void sleep() {
        System.out.println("Animal is sleeping");
    }
}

class Dog extends Animal {
    @Override
    public void sleep() {
        System.out.println("Dog is sleeping in its kennel");
    }
}

class Cat extends Animal {
    @Override
    public void sleep() {
        System.out.println("Cat sleeps in a tree");
    }
}

class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        myAnimal.sleep(); // Animal is sleeping
        myDog.sleep();    // Dog is sleeping in its kennel
        myCat.sleep();    // Cat sleeps in a tree
    }
}
```

**Output:**

```
Animal is sleeping
Dog is sleeping in its kennel
Cat sleeps in a tree
```

> **Key Point:** This is an example of extensibility—you don't need to modify the `Animal` class itself to extend its behavior for each subclass. You only need to add new behavior in the subclasses as needed.

***

#### 4. Supports Polymorphism

Facilitates runtime polymorphism, enabling dynamic behavior.

**Example:**

```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.sound(); // Dog barks

        myAnimal = new Cat();
        myAnimal.sound(); // Cat meows
    }
}
```

**Output:**

```
Dog barks
Cat meows
```

***

### Disadvantages of Inheritance

#### 1. Increased Coupling

Creates a tightly coupled relationship between classes, making changes in the superclass impact all subclasses.

**Example:**

```java
class Animal {
    public void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    // Inherits eat() method from Animal
}

class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat(); // Reuses the eat method from Animal
    }
}
```

> **Warning:** If we change `Animal`'s `eat()` method, it could break `Dog`'s functionality, leading to an exception. This shows how a change in one method of the parent class can break the properties of its subclasses.

***

#### 2. Complexity

Overuse of inheritance can lead to overly complex and hard-to-maintain hierarchies.

**Example:**

```java
class Animal {}
class Mammal extends Animal {}
class Dog extends Mammal {}
class Bulldog extends Dog {}

class Main {
    public static void main(String[] args) {
        Bulldog bulldog = new Bulldog();
    }
}
```

> **Note:** Understanding this deep nested level of inheritance structure may be difficult in larger systems to maintain and may require refactoring to make the structure more maintainable and scalable.

***

#### 3. Reduced Flexibility

A subclass is heavily dependent on the implementation of its superclass, which may limit customization.

**Example:**

```java
class Animal {
    public void sleep() {
        System.out.println("Animal is sleeping");
    }
}

class Dog extends Animal {
    // The dog inherits the sleep method from Animal
}

class Cat extends Animal {
    // Similarly, the Cat class inherits the sleep method from Animal
}

class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();

        dog.sleep(); // Animal is sleeping (not customized for Dog)
        cat.sleep(); // Animal is sleeping (not customized for Cat)
    }
}
```

**Output:**

```
Animal is sleeping
Animal is sleeping
```

> **Issue:** If you wanted to make `Dog` sleep in a specific way ("Dog is sleeping in its kennel") and `Cat` sleep in another way ("Cat sleeps in a tree"), you would be forced to modify the `sleep()` method in the parent class or override it in each subclass. This reduces flexibility because you can't change or extend behavior independently without affecting others.

***

### Summary

Inheritance is a fundamental feature of Java that enhances code reuse, modularity, and scalability. Understanding its types and proper usage is essential for designing robust applications.

#### Key Takeaways

| Aspect            | Benefit                    | Consideration                      |
| ----------------- | -------------------------- | ---------------------------------- |
| **Code Reuse**    | Write once, use many times | Avoid over-reliance on inheritance |
| **Maintenance**   | Centralized updates        | Changes affect all subclasses      |
| **Extensibility** | Easy to add new features   | Keep hierarchies shallow           |
| **Polymorphism**  | Dynamic behavior support   | Understand type relationships      |
| **Coupling**      | Clear relationships        | Can create tight dependencies      |

#### Best Practices

1. **Favor composition over inheritance** when possible
2. **Keep inheritance hierarchies shallow** (typically 2-3 levels max)
3. **Use abstract classes and interfaces** to define contracts
4. **Follow the Liskov Substitution Principle** (subclasses should be substitutable for base classes)
5. **Document inheritance relationships** clearly
6. **Avoid fragile base class problem** by carefully designing parent classes

Proper use of inheritance fosters efficient development while avoiding common pitfalls such as over-coupling and unnecessary complexity.

***

### Next Steps

Continue your learning journey by exploring:

* Abstract classes and their role in inheritance
* Interface-based design patterns
* Composition vs. Inheritance tradeoffs
* SOLID principles and inheritance
* Design patterns using inheritance (Template Method, Strategy)
