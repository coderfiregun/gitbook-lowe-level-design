# 5. Polymorphism and it's types

## Polymorphism and Its Types

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/polymorphism-and-its-types)

### Overview

Polymorphism is one of the core principles of Object-Oriented Programming (OOP), enabling objects to take on multiple forms. It allows the same operation to behave differently on different classes, enhancing code flexibility and reusability.

#### Real-World Analogy

A real-life example of polymorphism is a person who can have different characteristics at the same time. A man can simultaneously be a father, a husband, and an employee. The same person exhibits different behavior in different situations. This is called polymorphism.

***

### Types of Polymorphism

In Java, polymorphism can be broadly classified into two main types:

| Type                      | Resolution Time | Implementation                           |
| ------------------------- | --------------- | ---------------------------------------- |
| **Compile-time (Static)** | Compile time    | Method overloading, Operator overloading |
| **Runtime (Dynamic)**     | Runtime         | Method overriding                        |

***

### 1. Compile-time (Static) Polymorphism

Compile-time or static polymorphism occurs when the method to be executed is determined at compile time. It is achieved using method overloading or operator overloading.

#### Method Overloading

When there are multiple functions with the same name but different parameters, the functions are said to be overloaded. Functions can be overloaded by:

* Changing the number of arguments
* Changing the type of arguments

**Example 1: Changing the Number of Arguments**

```java
class Vehicle {
    // Method to start a vehicle with basic information
    void start(String vehicleType) {
        System.out.println("Starting a " + vehicleType);
    }

    // Overloaded method to start a vehicle with extra information
    void start(String vehicleType, int speed) {
        System.out.println("Starting a " + vehicleType + " with speed: " + speed + " km/h");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();

        // Calls method with one argument
        vehicle.start("Car");

        // Calls overloaded method with two arguments
        vehicle.start("Bike", 60);
    }
}
```

**Output:**

```
Starting a Car
Starting a Bike with speed: 60 km/h
```

**Example 2: Changing the Type of Arguments**

```java
class Vehicle {
    // Method to start a vehicle with a string parameter
    void start(String vehicleType) {
        System.out.println("Starting a " + vehicleType);
    }

    // Overloaded method to start a vehicle with an integer parameter
    void start(int vehicleId) {
        System.out.println("Starting a vehicle with ID: " + vehicleId);
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();

        // Calls method with a string argument
        vehicle.start("Truck");

        // Calls overloaded method with an integer argument
        vehicle.start(101);
    }
}
```

**Output:**

```
Starting a Truck
Starting a vehicle with ID: 101
```

#### Key Features of Compile-time Polymorphism

* Method resolution happens at compile time
* Provides better readability and cleaner code by allowing methods with the same name to perform similar actions
* No runtime overhead since method binding is done during compilation

***

### 2. Runtime (Dynamic) Polymorphism

Runtime polymorphism occurs when the method to be executed is determined during runtime. It is achieved through method overriding and is closely tied to inheritance.

#### Method Overriding

Method overriding allows a subclass to provide a specific implementation for a method already defined in its parent class. The overridden method in the subclass has the same name, return type, and parameters as the method in the parent class.

**Example: Vehicle Hierarchy**

```java
// Parent class
class Vehicle {
    void start() {
        System.out.println("Starting a generic vehicle");
    }
}

// Subclasses overriding the start method
class Car extends Vehicle {
    @Override
    void start() {
        System.out.println("Starting a car");
    }
}

class Bike extends Vehicle {
    @Override
    void start() {
        System.out.println("Starting a bike");
    }
}

class Truck extends Vehicle {
    @Override
    void start() {
        System.out.println("Starting a truck");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle myVehicle;

        // Assign a Car object to the Vehicle reference
        myVehicle = new Car();
        myVehicle.start(); // Output: Starting a car

        // Assign a Bike object to the Vehicle reference
        myVehicle = new Bike();
        myVehicle.start(); // Output: Starting a bike

        // Assign a Truck object to the Vehicle reference
        myVehicle = new Truck();
        myVehicle.start(); // Output: Starting a truck
    }
}
```

**Output:**

```
Starting a car
Starting a bike
Starting a truck
```

#### Key Features of Runtime Polymorphism

* Method resolution happens at runtime based on the actual object type
* Supports dynamic method dispatch, enabling the Java Virtual Machine (JVM) to determine the appropriate method implementation
* Enables loose coupling and greater flexibility in code design

***

### Advantages of Polymorphism

#### 1. Code Reusability

Encourages writing generic and reusable code by allowing a single interface to handle multiple types.

**Example:**

```java
// Interface
interface Vehicle {
    void start(); // Abstract method
}

// Implementing classes
class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Starting the car");
    }
}

class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("Starting the bike");
    }
}

class Truck implements Vehicle {
    @Override
    public void start() {
        System.out.println("Starting the truck");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle[] vehicles = {new Car(), new Bike(), new Truck()};
        for (Vehicle vehicle : vehicles) {
            vehicle.start(); // Polymorphic behavior
        }
    }
}
```

**Output:**

```
Starting the car
Starting the bike
Starting the truck
```

> **Key Point:** The `Vehicle` interface allows you to reuse a single loop to handle different implementations.

***

#### 2. Flexibility

Provides flexibility in program design by enabling dynamic method behavior.

**Example:**

```java
public class Main {
    public static void main(String[] args) {
        Vehicle vehicle;

        // Flexible: Dynamically assign different types of vehicles
        vehicle = new Car();
        vehicle.start(); // Output: Starting the car

        vehicle = new Bike();
        vehicle.start(); // Output: Starting the bike

        vehicle = new Truck();
        vehicle.start(); // Output: Starting the truck
    }
}
```

> **Key Point:** Using the `Vehicle` interface, we dynamically switch between different implementations at runtime.

***

#### 3. Extensibility

Allows easy extension of code by adding new classes or methods without modifying existing ones.

**Example:**

```java
// Adding a new type of Vehicle
class Bus implements Vehicle {
    @Override
    public void start() {
        System.out.println("Starting the bus");
    }
}

public class Main {
    public static void main(String[] args) {
        // Extensible: Add new vehicle types without changing existing code
        Vehicle[] vehicles = {new Car(), new Bike(), new Truck(), new Bus()};
        for (Vehicle vehicle : vehicles) {
            vehicle.start(); // Polymorphic behavior handles the new type seamlessly
        }
    }
}
```

**Output:**

```
Starting the car
Starting the bike
Starting the truck
Starting the bus
```

> **Key Point:** Adding new vehicle types is seamless and requires no changes to existing code because all new classes implement the `Vehicle` interface.

***

### Disadvantages of Polymorphism

#### 1. Complex Debugging

Runtime polymorphism can make debugging difficult due to dynamic method resolution.

**Example:**

```java
import java.util.ArrayList;
import java.util.List;

// Base class
class Vehicle {
    void start() {
        System.out.println("Starting a generic vehicle");
    }
}

// Subclasses overriding the start method
class Car extends Vehicle {
    @Override
    void start() {
        System.out.println("Starting a car");
    }
}

class Bike extends Vehicle {
    @Override
    void start() {
        System.out.println("Starting a bike");
    }
}

class Truck extends Vehicle {
    @Override
    void start() {
        System.out.println("Starting a truck");
    }
}

public class Main {
    public static void main(String[] args) {
        // List containing various types of vehicles
        List<Vehicle> vehicleList = new ArrayList<>();
        vehicleList.add(new Car());
        vehicleList.add(new Bike());
        vehicleList.add(new Truck());
        vehicleList.add(new Vehicle());

        // Debugging challenge: What type of vehicle is being started?
        for (Vehicle vehicle : vehicleList) {
            vehicle.start(); // Runtime determines which start() method is called
        }
    }
}
```

**Debugging Challenges:**

* When iterating through a list of `Vehicle` objects, it's unclear which specific subclass is being called without stepping through the code
* If the list comes from an external source (API, database), the actual type isn't clear from the source code
* Requires runtime inspection or debugging tools to identify the actual object type

***

#### 2. Performance Overhead

Dynamic method dispatch introduces slight overhead as the JVM resolves the method during runtime.

**Example:**

```java
class Vehicle {
    void start() {
        System.out.println("Starting a generic vehicle");
    }
}

class Car extends Vehicle {
    @Override
    void start() {
        System.out.println("Starting a car");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle myVehicle;
        long startTime = System.nanoTime();

        // Dynamic method dispatch
        myVehicle = new Car();
        myVehicle.start(); // JVM resolves method implementation dynamically

        long endTime = System.nanoTime();
        System.out.println("Time taken for method dispatch: " + (endTime - startTime) + " nanoseconds");
    }
}
```

> **Note:** While the overhead is typically negligible for most applications, it can become significant in performance-critical scenarios with millions of method calls.

***

### Comparison: Compile-time vs Runtime Polymorphism

| Aspect             | Compile-time Polymorphism                | Runtime Polymorphism                  |
| ------------------ | ---------------------------------------- | ------------------------------------- |
| **Binding**        | Static (early binding)                   | Dynamic (late binding)                |
| **Resolution**     | At compile time                          | At runtime                            |
| **Implementation** | Method overloading                       | Method overriding                     |
| **Inheritance**    | Not required                             | Required                              |
| **Performance**    | Faster (no runtime overhead)             | Slightly slower (runtime resolution)  |
| **Flexibility**    | Less flexible                            | More flexible                         |
| **Example**        | `add(int, int)` vs `add(double, double)` | Parent reference holding child object |

***

### Best Practices

1. **Use meaningful method names:** Even with overloading, ensure method names clearly indicate their purpose
2. **Follow the Liskov Substitution Principle:** Subclasses should be substitutable for their base classes without altering program correctness
3. **Use `@Override` annotation:** Always use this annotation when overriding methods to catch errors at compile time
4. **Prefer interfaces for polymorphism:** Using interfaces provides better abstraction and flexibility than concrete classes
5. **Consider performance implications:** Be aware of the slight performance overhead in runtime polymorphism for critical applications
6. **Document polymorphic behavior:** Clearly document which methods are meant to be overridden and their expected behavior

***

### Summary

Polymorphism is a powerful feature in OOP that promotes flexibility, modularity, and reusability. Understanding its types—compile-time and runtime—is essential for mastering OOP principles and designing robust applications.

#### Key Takeaways

* **Compile-time polymorphism** enables multiple methods with the same name but different parameters
* **Runtime polymorphism** allows subclasses to provide specific implementations of parent class methods
* Polymorphism enhances code reusability, flexibility, and extensibility
* Trade-offs include debugging complexity and minor performance overhead
* Essential for building scalable and maintainable object-oriented systems

By leveraging polymorphism effectively, developers can write cleaner, more maintainable code, ensuring their applications are scalable and adaptable to change.

***

### Next Steps

Continue your learning journey by exploring:

* Abstract classes and interfaces
* Design patterns leveraging polymorphism (Strategy, Factory, Template Method)
* SOLID principles and their relationship with polymorphism
* Advanced polymorphism concepts (covariant return types, generic polymorphism)
