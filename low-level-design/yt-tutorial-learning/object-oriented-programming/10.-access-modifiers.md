# 10. Access modifiers

## Access Modifiers

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/access-modifiers)

### Overview

Access modifiers are fundamental in Object-Oriented Programming (OOP) as they control the visibility and accessibility of classes, methods, and variables in a program. They play a crucial role in encapsulation by restricting or allowing access to certain parts of the code based on the specified modifier.

Access modifiers prevent data members or functions of one class from tampering with another class while restricting its access. It allows us to select which members can be accessed directly by outside functions and which are not.

***

### Project Structure Overview

Before diving into the types of access modifiers, let me walk you through the project structure that will be used to demonstrate their behavior.

#### Project Structure

```
src/
├── demoPackage/
│   └── DemoClass.java
├── utilityClasses/
│   ├── PublicClassExample.java
│   ├── PrivateClassExample.java
│   ├── ProtectedClassExample.java
│   └── DefaultClassExample.java
└── Main.java
```

**Components:**

* **src/**: The root folder containing all the code files
* **demoPackage/**: This package contains the `DemoClass`, which we will use to demonstrate the usage of different access modifiers in Java
* **utilityClasses/**: This package contains the following classes:
  * `PublicClassExample`: Demonstrates the use of the public access modifier
  * `PrivateClassExample`: Demonstrates the use of the private access modifier
  * `ProtectedClassExample`: Demonstrates the use of the protected access modifier
  * `DefaultClassExample`: Demonstrates the default (package-private) access modifier
* **Main.java**: The main entry point for running the project

This structure allows us to clearly show how access modifiers work across:

1. Classes within the same package (`demoPackage`)
2. Classes in different packages (`utilityClasses`)

Each of these access modifiers—public, private, protected, and default—will be explored using these classes and their relationships.

***

### Types of Access Modifiers in Java

Java provides four main types of access modifiers:

#### 1. Public

**Scope**

A public class, method, or variable is accessible from anywhere in the application, whether it's within the same package or from a different package.

**Usage**

The public modifier is used when you want the element (class, method, or variable) to be globally accessible. In the context of our project structure, the `PublicClassExample` in the `utilityClasses` package is accessible to other classes such as `DemoClass` in the `demoPackage` package.

**Code Example: Demonstrating the Public Modifier**

Here's how we use the `PublicClassExample` to demonstrate the public modifier:

**PublicClassExample.java**

Located in the `utilityClasses` package:

```java
package utilityClasses; // Declared in the utilityClasses package

public class PublicClassExample {
    public void display() {
        System.out.println("This is a public method in PublicClassExample.");
    }
}
```

**DemoClass.java**

Located in the `demoPackage` package, demonstrating the usage of the public method:

```java
package demoPackage; // Declared in the demoPackage package
import utilityClasses.PublicClassExample; // Importing the PublicClassExample from another package

public class DemoClass {
    public static void main(String[] args) {
        // Creating an object of PublicClassExample
        PublicClassExample example = new PublicClassExample();

        // Calling the public method
        example.display(); // Accessible because 'display()' is public
    }
}
```

**Output:**

```
This is a public method in PublicClassExample.
```

**Explanation**

The `display()` method in `PublicClassExample` is declared as `public`, making it accessible across packages. By importing `utilityClasses.PublicClassExample` in `DemoClass`, we can use the method `display()` without any access restrictions.

***

#### 2. Private

**Scope**

A private class, method, or variable is not accessible from anywhere in the application. It is only accessible within the same class and not from outside the class, whether in the same package, a child class, or a different package. It will be accessible only within the same class.

**Usage**

The private modifier is used when you want an element (class, method, or variable) to be accessible only within the same class. In the context of our project structure, the `PrivateClassExample` in the `utilityClasses` package is accessible to other classes because it is declared public. However, its methods won't be accessible to the `DemoClass` in the `demoPackage` package, as all the methods defined are private, which will result in a compile-time error.

**Code Example: Demonstrating the Private Modifier**

Here's how we use the `PrivateClassExample` to demonstrate the private modifier:

**PrivateClassExample.java**

Located in the `utilityClasses` package:

```java
package utilityClasses;

public class PrivateClassExample {
    private String secret = "Hidden Message";
    
    private void displaySecret() {
        System.out.println(secret);
    }
    
    private void show() {
        displaySecret(); // Accessible within the same class
    }
}
```

**DemoClass.java**

Located in the `demoPackage` package, demonstrating the usage of the private method:

```java
package demoPackage;
import utilityClasses.PrivateClassExample;

public class DemoClass {
    public static void main(String[] args) {
        PrivateClassExample example = new PrivateClassExample();
        // example.show(); // Compile-time error: 'show()' has private access
    }
}
```

**Explanation**

The `show()` method in `PrivateClassExample` is declared as `private`, making it accessible only within the `PrivateClassExample` class. By importing `utilityClasses.PrivateClassExample` in `DemoClass`, we cannot use the `show()` method.

Whenever we try to access the `show()` method of the `PrivateClassExample`, since it's declared private, the compiler will give us a warning stating that `'show() has private access in utilityClasses.PrivateClassExample'`.

**Compile-time Error:**

```
java: show() has private access in utilityClasses.PrivateClassExample
```

> **Key Point:** Even if you forcefully run the `DemoClass`, the output will be a compile-time error, which will be printed in the terminal.

***

#### 3. Protected

**Scope**

The protected modifier allows access members within the same package and from subclasses in other packages. It offers more restricted access compared to public, but it is broader than private. By using protected, you enable controlled inheritance, allowing child classes to reuse and extend parent class functionality while keeping it hidden from unrelated classes.

**Usage**

The protected modifier is used in scenarios where inheritance is a key design pattern. For example, you might define reusable methods or fields in a superclass that should only be accessed or overridden by its subclasses. It is commonly used in frameworks or libraries to expose specific functionality to derived classes while restricting general access.

**Code Example: Demonstrating the Protected Modifier**

Here's how we use the `ProtectedClassExample` to demonstrate the protected modifier:

**ProtectedClassExample.java**

Located in the `utilityClasses` package:

```java
package utilityClasses;

public class ProtectedClassExample {
    protected void display() {
        System.out.println("Hello from Parent class!");
    }
}
```

**DemoClass.java (Without Inheritance)**

Located in the `demoPackage` package, demonstrating the usage of the protected method:

```java
package demoPackage;
import utilityClasses.ProtectedClassExample;

public class DemoClass {
    public static void main(String[] args) {
        ProtectedClassExample example = new ProtectedClassExample();
        // example.display(); // Compile-time error: 'display()' has protected access
    }
}
```

**Explanation**

The `display()` method in `ProtectedClassExample` is declared as `protected`, making it accessible only within the classes present in the same package and also in the classes present in different packages if they are a subclass of the `ProtectedClassExample`. By importing `utilityClasses.ProtectedClassExample` in `DemoClass`, we cannot use the `display()` method, as the `DemoClass` is not a subclass of the `ProtectedClassExample`.

Whenever we try to access the `display()` method of the `ProtectedClassExample`, since it's declared protected, the compiler will give us a warning stating that:

```
'display()' has protected access in 'utilityClasses.ProtectedClassExample'
```

**Accessing Protected Members Through Inheritance**

In order to access the parent class method, we can make `DemoClass` extend the `ProtectedClassExample` class, thereby making `DemoClass` a subclass of `ProtectedClassExample`. This will allow us to access the `display()` method of the `ProtectedClassExample`.

**DemoClass.java (With Inheritance)**

```java
package demoPackage;
import utilityClasses.ProtectedClassExample;

public class DemoClass extends ProtectedClassExample {
    public static void main(String[] args) {
        DemoClass example = new DemoClass();
        example.display(); // Now accessible because DemoClass extends ProtectedClassExample
    }
}
```

**Output:**

```
Hello from Parent class!
```

***

#### 4. Default (Package-Private)

**Scope**

When no access modifier is specified, the default (package-private) access modifier is applied. Members with this access modifier are accessible only within the same package but not from outside it. This ensures that the functionality is available for closely related classes within the package while being hidden from other parts of the application.

**Usage**

Default access is used when you want to limit access to package-level components. It is ideal for internal helper classes, methods, or variables that do not need to be exposed to external packages. This access level supports modularity by grouping related classes and ensuring that their interactions remain encapsulated within the package.

**Code Example: Demonstrating the Default Modifier**

Here's how we use the `DefaultClassExample` to demonstrate the default modifier:

**DefaultClassExample.java**

Located in the `utilityClasses` package:

```java
package utilityClasses;

public class DefaultClassExample {
    void display() {
        System.out.println("This is a default access method.");
    }
}
```

**DemoClass.java (Different Package)**

Located in the `demoPackage` package, demonstrating the usage of the default method:

```java
package demoPackage;
import utilityClasses.DefaultClassExample;

public class DemoClass {
    public static void main(String[] args) {
        DefaultClassExample example = new DefaultClassExample();
        // example.display(); // Compile-time error: 'display()' is not public
    }
}
```

**Explanation**

The `display()` method in `DefaultClassExample` is by default declared as default when no access modifier is assigned, making it accessible only within the classes present in the same package. By importing `utilityClasses.DefaultClassExample` in `DemoClass`, we cannot use the `display()` method, as the `DemoClass` is present in a different package, which is `demoPackage`.

Whenever we try to access the `display()` method of the `DefaultClassExample`, since it's declared default, the compiler will give us a warning stating that:

```
'display()' is not public in 'utilityClasses.DefaultClassExample'. Cannot be accessed from outside package.
```

**Compile-time Error:**

```
java: display() is not public in utilityClasses.DefaultClassExample; cannot be accessed from outside package
```

**Accessing Default Members Within the Same Package**

Now that we have seen we cannot access the default access modifier methods in different packages, if we create a new class, let's say `Main`, in the same `utilityClasses` package, add the same code as we did in the `DemoClass` and try to access the `display()` method of the `DefaultClassExample`, it will not give us any compile-time warnings and will work absolutely fine.

**Main.java (Same Package)**

```java
package utilityClasses;

public class Main {
    public static void main(String[] args) {
        DefaultClassExample example = new DefaultClassExample();
        example.display(); // Works fine - same package
    }
}
```

**Output:**

```
This is a default access method.
```

***

### Summary of Access Modifiers

| Access Modifier | Same Class | Same Package | Subclass (Different Package) | Different Package |
| --------------- | ---------- | ------------ | ---------------------------- | ----------------- |
| **public**      | ✅          | ✅            | ✅                            | ✅                 |
| **protected**   | ✅          | ✅            | ✅                            | ❌                 |
| **default**     | ✅          | ✅            | ❌                            | ❌                 |
| **private**     | ✅          | ❌            | ❌                            | ❌                 |

***

### Access Modifiers Use Cases

#### When to Use Each Modifier

| Modifier      | Use Case                                                         | Example                                   |
| ------------- | ---------------------------------------------------------------- | ----------------------------------------- |
| **public**    | API methods, utility classes, constants meant for external use   | `Math.max()`, `System.out.println()`      |
| **protected** | Methods/fields meant for inheritance, framework extension points | Template methods, callback methods        |
| **default**   | Package-internal helper classes, implementation details          | Package-level utilities, internal helpers |
| **private**   | Implementation details, internal state, helper methods           | Field validation, internal calculations   |

***

### Best Practices

1. **Start with the most restrictive access level** (private) and only increase visibility as needed
2. **Use public sparingly** - Only expose what is absolutely necessary for external use
3. **Prefer protected over public** for methods intended for subclasses
4. **Use default access** for package-internal collaborations
5. **Keep fields private** - Always use getters/setters for controlled access
6. **Document public APIs clearly** - Public members form your contract with users
7. **Consider package organization** - Group related classes to leverage default access

***

### Common Pitfalls

#### 1. Overusing Public Access

**Problem:**

```java
public class User {
    public String password; // Bad: Direct access to sensitive field
}
```

**Solution:**

```java
public class User {
    private String password; // Good: Encapsulated field
    
    public void setPassword(String password) {
        // Add validation logic
        this.password = password;
    }
}
```

#### 2. Forgetting Package Structure with Default Access

**Problem:**

```java
// In package com.app.utils
class Helper {
    void doSomething() { } // Default access
}

// In package com.app.service
class Service {
    Helper helper = new Helper(); // Won't compile - different package
}
```

#### 3. Misusing Protected

**Problem:**

```java
public class Parent {
    protected void display() { }
}

// Different package
public class NonChild {
    void test() {
        Parent p = new Parent();
        p.display(); // Won't compile - not a subclass
    }
}
```

***

### Summary

Access modifiers are essential tools that provide control over the visibility and accessibility of classes, methods, and variables.

#### Key Takeaways

**Public Modifier:**

* Accessible from anywhere in the application
* Use for APIs and globally needed functionality
* Most permissive access level

**Private Modifier:**

* Accessible only within the same class
* Use for implementation details and internal state
* Most restrictive access level

**Protected Modifier:**

* Accessible within the same package and from subclasses
* Use for inheritance hierarchies
* Enables controlled extension

**Default (Package-Private) Modifier:**

* Accessible only within the same package
* Use for package-internal collaborations
* No keyword needed (omit access modifier)

**Benefits:**

* Enhances encapsulation and data hiding
* Supports modular design
* Provides security through access control
* Enables controlled inheritance
* Improves code maintainability

By understanding and using access modifiers effectively, developers can create secure, modular, and maintainable applications. Mastery of access modifiers is key to writing robust and encapsulated programs.

***

### Next Steps

Continue your learning journey by exploring:

* Encapsulation and data hiding principles
* Package design and organization strategies
* The Open/Closed Principle in SOLID design
* Java modules system (Java 9+)
* Access control in nested classes and interfaces
