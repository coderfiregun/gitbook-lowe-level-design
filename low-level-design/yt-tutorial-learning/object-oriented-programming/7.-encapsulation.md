# 7. Encapsulation

## Encapsulation

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/encapsulation)

### Overview

Encapsulation is one of the fundamental principles of Object-Oriented Programming (OOP). It involves bundling data (variables) and methods (functions) that operate on the data into a single unit called a class.

Encapsulation also restricts direct access to certain components, ensuring controlled interaction through methods. This prevents unauthorized or accidental interference with the object's data and ensures better control over the data flow in a program.

#### How Encapsulation is Achieved in Java

In Java, encapsulation is typically achieved by:

1. Declaring class variables as `private`
2. Providing `public` getter and setter methods to access and modify these variables

***

### Key Features of Encapsulation

| Feature         | Description                                                                                            |
| --------------- | ------------------------------------------------------------------------------------------------------ |
| **Data Hiding** | Prevents direct access to sensitive data, ensuring changes can only be made through controlled methods |
| **Modularity**  | Promotes modular design by separating data and behavior, making code easier to manage and debug        |
| **Security**    | Protects the integrity of the data by restricting unwanted modifications                               |
| **Flexibility** | Allows developers to change internal implementation without affecting external code                    |

***

### Basic Example: Bank Account

```java
class BankAccount {
    // Private variables (data hiding)
    private String accountNumber;
    private double balance;

    // Constructor
    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    // Public getter method
    public String getAccountNumber() {
        return accountNumber;
    }

    // Public getter method
    public double getBalance() {
        return balance;
    }

    // Public setter method for deposit
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposited: " + amount);
        } else {
            System.out.println("Invalid deposit amount.");
        }
    }

    // Public setter method for withdrawal
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Withdrawn: " + amount);
        } else {
            System.out.println("Invalid withdrawal amount.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount("12345", 1000.00);
        System.out.println("Account Number: " + account.getAccountNumber());
        System.out.println("Initial Balance: " + account.getBalance());
        
        account.deposit(500.00);
        System.out.println("Updated Balance: " + account.getBalance());
        
        account.withdraw(200.00);
        System.out.println("Final Balance: " + account.getBalance());
    }
}
```

**Output:**

```
Account Number: 12345
Initial Balance: 1000.0
Deposited: 500.0
Updated Balance: 1500.0
Withdrawn: 200.0
Final Balance: 1300.0
```

#### Explanation

**1. Private Variables:**

* The variables `accountNumber` and `balance` are private, restricting direct access from outside the class

**2. Public Methods:**

* Getter methods provide controlled access to the variables
* Setter methods ensure valid updates to the variables

**3. Data Integrity:**

* The class ensures that only valid operations are performed on its data

***

### Advantages of Encapsulation

#### 1. Improved Data Security

Prevents unauthorized access and modifications to the data.

**Example:**

```java
class BankAccount {
    private String accountNumber; // Data is hidden
    private double balance;       // Data is hidden

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    // Public getter for balance (read-only access)
    public double getBalance() {
        return balance;
    }

    // Public method for deposit (controlled access)
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposited: " + amount);
        } else {
            System.out.println("Invalid deposit amount.");
        }
    }

    // Public method for withdrawal (controlled access)
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Withdrawn: " + amount);
        } else {
            System.out.println("Invalid withdrawal amount.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount("12345", 1000.00);

        // Accessing balance only through public methods
        account.deposit(500.00);
        account.withdraw(300.00);

        // Unauthorized access prevented: No direct modification
        System.out.println("Account Balance: " + account.getBalance());
    }
}
```

**Output:**

```
Deposited: 500.0
Withdrawn: 300.0
Account Balance: 1200.0
```

> **Key Point:** Direct access to `balance` and `accountNumber` is not allowed, ensuring that sensitive information is not exposed or modified arbitrarily. This enhances data security and prevents accidental errors.

***

#### 2. Ease of Maintenance

Encapsulated code is easier to modify and debug without affecting external components.

**Example:**

```java
class BankAccount {
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public double getBalance() {
        return balance;
    }

    // Centralized logic for deposit and withdrawal
    public void updateBalance(double amount, boolean isDeposit) {
        if (isDeposit) {
            balance += amount;
            System.out.println("Deposited: " + amount);
        } else if (amount <= balance) {
            balance -= amount;
            System.out.println("Withdrawn: " + amount);
        } else {
            System.out.println("Invalid transaction.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(1000.00);
        // Maintenance: Any bug in updateBalance can be fixed in one place
        account.updateBalance(500.00, true);  // Deposit
        account.updateBalance(300.00, false); // Withdraw
        System.out.println("Final Balance: " + account.getBalance());
    }
}
```

**Output:**

```
Deposited: 500.0
Withdrawn: 300.0
Final Balance: 1200.0
```

> **Key Point:** The `updateBalance` method is the single point of truth for both deposits and withdrawals. Any changes, such as adding transaction limits or fees, can be made in this method without affecting other parts of the code.

***

#### 3. Flexibility and Backward Compatibility

Internal implementation can be updated without affecting external code.

**Example:**

```java
class BankAccount {
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public double getBalance() {
        return balance;
    }

    // Internal implementation can be updated (e.g., adding transaction fee)
    public void withdraw(double amount) {
        double transactionFee = 2.00; // New feature
        if (amount > 0 && (amount + transactionFee) <= balance) {
            balance -= (amount + transactionFee);
            System.out.println("Withdrawn: " + amount + ", Fee: " + transactionFee);
        } else {
            System.out.println("Invalid withdrawal amount.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(1000.00);
        // External code remains unchanged despite internal changes
        account.withdraw(200.00);
        System.out.println("Remaining Balance: " + account.getBalance());
    }
}
```

**Output:**

```
Withdrawn: 200.0, Fee: 2.0
Remaining Balance: 798.0
```

> **Key Point:** The internal implementation of the `withdraw` method was updated to include a transaction fee, but external code (e.g., the `Main` class) didn't need any modifications. This ensures flexibility and backward compatibility.

***

#### 4. Enhanced Readability

Clearly defined interfaces improve code readability and usability.

**Example:**

```java
class BankAccount {
    private String accountNumber;
    private double balance;

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    // Clear and readable methods
    public String getAccountNumber() {
        return accountNumber;
    }

    public double getBalance() {
        return balance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposited: " + amount);
        }
    }

    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Withdrawn: " + amount);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount("12345", 1000.00);

        // Clearly defined interfaces for readability
        System.out.println("Account Number: " + account.getAccountNumber());
        System.out.println("Initial Balance: " + account.getBalance());

        account.deposit(500.00);
        account.withdraw(200.00);
    }
}
```

**Output:**

```
Account Number: 12345
Initial Balance: 1000.0
Deposited: 500.0
Withdrawn: 200.0
```

> **Key Point:** The clear interface (`getAccountNumber`, `deposit`, and `withdraw`) makes it easy for developers to understand how to use the `BankAccount` class, even if they are unfamiliar with its internal workings.

***

### Disadvantages of Encapsulation

#### 1. Slight Overhead

Encapsulation introduces additional boilerplate code (getters and setters), which can increase verbosity.

**Example:**

```java
class BankAccount {
    private String accountNumber;
    private double balance;

    // Boilerplate getters and setters
    public String getAccountNumber() {
        return accountNumber;
    }

    public void setAccountNumber(String accountNumber) {
        this.accountNumber = accountNumber;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        // Verbose code for simple tasks
        account.setAccountNumber("12345");
        account.setBalance(1000.00);
        System.out.println("Account Number: " + account.getAccountNumber());
        System.out.println("Balance: " + account.getBalance());
    }
}
```

**Output:**

```
Account Number: 12345
Balance: 1000.0
```

> **Note:** Although encapsulation provides benefits, it can lead to more verbose code, especially when getters and setters are used extensively without adding significant value.

***

#### 2. Complexity for Beginners

Beginners may find it challenging to understand and implement encapsulation effectively.

**Example:**

```java
class BankAccount {
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public double getBalance() {
        return balance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }

    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(1000.00);
        // Beginners may find concepts like access modifiers and getters challenging
        account.deposit(500.00);
        account.withdraw(200.00);
        System.out.println("Final Balance: " + account.getBalance());
    }
}
```

**Output:**

```
Final Balance: 1300.0
```

> **Note:** For beginners, understanding why direct access to fields is restricted and why getters/setters are used can be confusing. This might make it harder for them to implement encapsulation correctly.

***

### Summary

Encapsulation is a vital aspect of OOP that fosters secure, modular, and maintainable code. By controlling data access through encapsulation, developers can ensure data integrity and create flexible, robust applications.

#### Key Takeaways

| Aspect                | Benefit                 | Implementation                  |
| --------------------- | ----------------------- | ------------------------------- |
| **Data Hiding**       | Protects sensitive data | Use `private` access modifiers  |
| **Controlled Access** | Validates modifications | Provide getter/setter methods   |
| **Maintainability**   | Centralized logic       | Single source of truth          |
| **Flexibility**       | Internal changes safe   | Public interface remains stable |
| **Security**          | Prevents misuse         | Validation in methods           |

#### Best Practices

1. **Always use private for fields:** Make instance variables private by default
2. **Provide getters carefully:** Only expose data that truly needs to be accessed
3. **Validate in setters:** Add validation logic in setter methods to maintain data integrity
4. **Use meaningful method names:** Methods should clearly indicate their purpose
5. **Avoid unnecessary setters:** If a field shouldn't change after initialization, don't provide a setter
6. **Consider immutability:** For objects that shouldn't change, use `final` fields and no setters
7. **Document your interface:** Clearly document what getters and setters do, especially if they have side effects

***

### Real-World Applications

Encapsulation is used extensively in:

* **Banking systems:** Protecting account balances and transactions
* **User authentication:** Securing passwords and credentials
* **Configuration management:** Controlling access to system settings
* **Data models:** Ensuring data consistency in applications
* **API design:** Creating clean, maintainable interfaces

Understanding and applying encapsulation effectively is essential for building scalable Java programs.

***

### Next Steps

Continue your learning journey by exploring:

* Access modifiers in depth (private, protected, public, default)
* JavaBeans conventions and naming patterns
* Immutable objects and their benefits
* Design patterns that leverage encapsulation
* SOLID principles, especially Single Responsibility Principle
