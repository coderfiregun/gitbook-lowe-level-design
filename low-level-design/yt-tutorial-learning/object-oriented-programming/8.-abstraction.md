# 8. Abstraction

## Abstraction

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/abstraction)

### Overview

Abstraction is a core concept of Object-Oriented Programming (OOP) that focuses on exposing only the essential details of an object while hiding the implementation details. It enables developers to interact with objects at a higher level, focusing on **what** an object does rather than **how** it does it.

#### Real-World Analogy

When you use a car, you interact with its accelerator, brake, and steering wheel without needing to know how the engine works internally. This is an example of abstraction.

In Java, abstraction is achieved using **abstract classes** and **interfaces**.

***

### Problem Without Abstraction

Imagine we want to create multiple animal types (Dog, Cat, Bird, etc.) where each animal has unique behaviors, such as making sounds. Without abstraction, we might end up writing repetitive and tightly coupled code.

**Example:**

```java
class Dog {
    void makeSound() {
        System.out.println("Bark");
    }
    void sleep() {
        System.out.println("Sleeping...");
    }
}

class Cat {
    void makeSound() {
        System.out.println("Meow");
    }
    void sleep() {
        System.out.println("Sleeping...");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound(); // Outputs: Bark
        dog.sleep();     // Outputs: Sleeping...
        
        Cat cat = new Cat();
        cat.makeSound(); // Outputs: Meow
        cat.sleep();     // Outputs: Sleeping...
    }
}
```

#### Problems in the Above Code

1. **Repetitive Code:** Both `Dog` and `Cat` have the `sleep()` method, resulting in duplicate logic
2. **No Common Structure:** If a new animal is added, the same methods need to be redefined, leading to code redundancy
3. **Lack of Flexibility:** You can't refer to all animals in a common way (e.g., treating a `Dog` and `Cat` as `Animal`)
4. **Tightly Coupled Code:** You must directly interact with individual classes (`Dog`, `Cat`), making the code less reusable and harder to maintain

***

### Solution Using Abstraction

Abstraction allows us to focus on defining the **what** of an object (its behavior) while hiding the **how** (its implementation).

To solve the above problems, we can define a common structure for all animals, specifying the essential behaviors they must have while leaving the specific implementations to the subclasses.

#### Benefits of Abstraction

* Creates a **scalable design** where adding new animals only involves defining a new subclass or implementing a new interface
* Ensures **consistency** across all animal types by enforcing common methods like `makeSound()` and `sleep()`
* Facilitates **polymorphism**, enabling us to write code that can interact with any animal in a generic way

***

### Ways to Achieve Abstraction

#### 1. Abstract Class

An abstract class acts as a blueprint for other classes, providing a foundation for shared behavior while allowing subclasses to define specific implementations.

It can include both **abstract methods** (declared but not implemented) and **concrete methods** (implemented with logic). Importantly, abstract classes cannot be instantiated directly.

**Example:**

```java
// Abstract Class Animal
abstract class Animal {
    // Abstract method for unique behaviors
    abstract void makeSound();
    
    // Concrete method for shared behaviors
    void sleep() {
        System.out.println("Sleeping...");
    }
}

// Specific implementation for Dog
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}

// Specific implementation for Cat
class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog(); // Treating Dog as an Animal
        myDog.makeSound();        // Outputs: Bark
        myDog.sleep();           // Outputs: Sleeping...
        
        Animal myCat = new Cat(); // Treating Cat as an Animal
        myCat.makeSound();        // Outputs: Meow
        myCat.sleep();           // Outputs: Sleeping...
    }
}
```

**Output:**

```
Bark
Sleeping...
Meow
Sleeping...
```

***

### Advantages of Abstract Classes

#### 1. Improved Code Maintainability

By focusing on essential details, abstraction makes code easier to maintain and understand.

**Example:**

```java
abstract class Animal {
    abstract void makeSound();
    
    void eat() {
        System.out.println("Animal is eating...");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.eat();       // Outputs: Animal is eating...
        myDog.makeSound(); // Outputs: Bark
    }
}
```

> **Key Point:** The `eat()` method is defined in the abstract class `Animal`, and any update to this method will reflect across all subclasses (Dog, Cat, etc.), improving maintainability.

***

#### 2. Enhanced Flexibility

Changes to the internal implementation do not affect the external interface, allowing developers to modify or extend functionality easily.

**Example:**

```java
abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound(); // Outputs: Bark
    }
}
```

> **Key Point:** The `Animal` abstract class provides a consistent way to interact with animals. Even if the `Dog` class changes its internal logic, the external interface (`makeSound()`) remains unchanged.

***

#### 3. Better Code Reusability

Abstract classes promote code reuse by defining common behaviors that can be shared across multiple classes.

**Example:**

```java
abstract class Animal {
    void eat() {
        System.out.println("Animal is eating...");
    }
}

class Dog extends Animal {
    // Inherits the eat() method
}

class Cat extends Animal {
    // Inherits the eat() method
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.eat(); // Outputs: Animal is eating...
        
        Cat myCat = new Cat();
        myCat.eat(); // Outputs: Animal is eating...
    }
}
```

> **Key Point:** The `eat()` method is defined once in the abstract class `Animal` and reused by all subclasses, eliminating code duplication.

***

#### 4. Increased Security

Hiding implementation details reduces the risk of accidental interference with internal workings.

**Example:**

```java
abstract class Animal {
    private String secret = "Sensitive data";
    
    abstract void makeSound();
    
    protected String getSecret() {
        return secret; // Controlled access to sensitive data
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
        System.out.println("Accessing secret: " + getSecret());
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound();
    }
}
```

**Output:**

```
Bark
Accessing secret: Sensitive data
```

> **Key Point:** The private field `secret` in `Animal` is hidden from external access. Subclasses can access it through controlled methods like `getSecret()`, ensuring security.

***

### Disadvantages of Abstract Classes

#### 1. Complexity in Design

Designing abstract classes requires careful planning and understanding of the system's requirements.

**Poor Design Example:**

```java
abstract class Animal {
    abstract void makeSound();
    abstract void fly();  // Not all animals can fly
    abstract void swim(); // Not all animals can swim
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
    
    @Override
    void fly() {
        throw new UnsupportedOperationException("Dogs can't fly");
    }
    
    @Override
    void swim() {
        System.out.println("Dog is swimming");
    }
}
```

**Why this is problematic:**

* Irrelevant methods like `fly()` force unnecessary implementation overhead
* Leads to poor readability and maintainability
* Introduces runtime errors with `UnsupportedOperationException`

**Better Design:**

```java
abstract class Animal {
    abstract void makeSound();
}

interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Dog extends Animal implements Swimmable {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
    
    @Override
    public void swim() {
        System.out.println("Dog is swimming");
    }
}
```

> **Key Point:** Only animals that can fly or swim implement the relevant interfaces, avoiding irrelevant methods in unrelated classes.

***

#### 2. Overhead

Abstraction introduces additional layers of complexity. For simple use cases, this can be unnecessary overhead.

**Example with Unnecessary Abstraction:**

```java
interface Animal {
    void makeSound();
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
}
```

**Simpler Solution:**

```java
class Dog {
    void makeSound() {
        System.out.println("Bark");
    }
}
```

> **Key Point:** For small and simple programs, directly using concrete classes makes the code more straightforward without unnecessary abstraction layers.

***

### 2. Interface

An interface defines a contract or a set of rules that a class must adhere to. It contains abstract methods that specify what a class should do, without dictating how it should be done.

Unlike abstract classes, interfaces focus purely on behavior and do not include state (fields). Starting from Java 8, interfaces can also include **default** and **static** methods.

**Example:**

```java
// Interface Animal
interface Animal {
    void makeSound(); // Abstract method
    void sleep();     // Abstract method
}

// Specific implementation for Dog
class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
    
    @Override
    public void sleep() {
        System.out.println("Sleeping...");
    }
}

// Specific implementation for Cat
class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow");
    }
    
    @Override
    public void sleep() {
        System.out.println("Sleeping...");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound(); // Outputs: Bark
        myDog.sleep();     // Outputs: Sleeping...
        
        Animal myCat = new Cat();
        myCat.makeSound(); // Outputs: Meow
        myCat.sleep();     // Outputs: Sleeping...
    }
}
```

**Output:**

```
Bark
Sleeping...
Meow
Sleeping...
```

***

### Advantages of Interfaces

#### 1. Decoupling

Interfaces ensure that implementation details are completely separate from the method definitions.

**Example:**

```java
interface Animal {
    void makeSound();
    void sleep();
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
    
    @Override
    public void sleep() {
        System.out.println("Dog is sleeping");
    }
}
```

> **Key Point:** By using interfaces, the `Dog` and `Cat` classes are decoupled from the `Animal` interface, allowing for flexible and interchangeable implementations.

***

#### 2. Extensibility

New animal types can be easily added by implementing the interface, without modifying existing code.

**Example:**

```java
class Bird implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Chirp");
    }
    
    @Override
    public void sleep() {
        System.out.println("Bird is sleeping");
    }
}
```

***

#### 3. Standardization

Interfaces define a contract, ensuring that all implementing classes behave consistently.

**Example:**

```java
public class Zoo {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();
        Animal bird = new Bird();
        
        dog.makeSound();
        cat.makeSound();
        bird.makeSound();
    }
}
```

***

### Disadvantages of Interfaces

#### 1. Complexity

Using interfaces can introduce additional complexity, especially in small projects where the benefits may not be significant.

#### 2. Overhead

Implementing multiple interfaces can lead to overhead in terms of code maintenance and readability.

**Example:**

```java
interface Animal {
    void makeSound();
    void sleep();
}

interface Pet {
    void play();
}

class Dog implements Animal, Pet {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
    
    @Override
    public void sleep() {
        System.out.println("Dog is sleeping");
    }
    
    @Override
    public void play() {
        System.out.println("Dog is playing");
    }
}
```

***

### Abstract Class vs Interface

| Aspect               | Abstract Class                               | Interface                                                              |
| -------------------- | -------------------------------------------- | ---------------------------------------------------------------------- |
| **Instantiation**    | Cannot be instantiated                       | Cannot be instantiated                                                 |
| **Methods**          | Can have abstract and concrete methods       | All methods abstract by default (can have default/static since Java 8) |
| **Variables**        | Can have any type of variables               | Only public, static, final variables                                   |
| **Constructors**     | Can have constructors                        | Cannot have constructors                                               |
| **Inheritance**      | Single inheritance only                      | Multiple inheritance supported                                         |
| **Access Modifiers** | Can use any access modifier                  | Methods are public by default                                          |
| **Use Case**         | When classes share common state and behavior | When defining a contract for unrelated classes                         |

***

### When to Use What?

#### Use Abstract Classes When:

**1. Classes need to share common code:**

```java
abstract class Animal {
    void eat() {
        System.out.println("Eating...");
    }
    abstract void makeSound();
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}
```

**2. You need non-static or non-final fields:**

```java
abstract class Animal {
    protected String name;
    
    abstract void makeSound();
    
    void setName(String name) {
        this.name = name;
    }
    
    String getName() {
        return name;
    }
}
```

**3. You need access modifiers other than public:**

```java
abstract class Animal {
    protected int age;
    
    abstract void makeSound();
    
    void setAge(int age) {
        this.age = age;
    }
}
```

***

#### Use Interfaces When:

**1. You need total abstraction:**

```java
interface Animal {
    void makeSound();
    void sleep();
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
    
    @Override
    public void sleep() {
        System.out.println("Dog is sleeping");
    }
}
```

**2. You need multiple inheritance:**

```java
interface Animal {
    void makeSound();
}

interface Pet {
    void play();
}

class Dog implements Animal, Pet {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
    
    @Override
    public void play() {
        System.out.println("Dog is playing");
    }
}
```

**3. You want to specify behavior without worrying about implementation:**

```java
interface Animal {
    void makeSound();
    void sleep();
}
```

***

### When to Use Abstraction?

* When multiple objects share common behavior but have different implementations
* To define a template or a standard for other classes to follow
* To hide implementation details and expose only relevant functionalities

***

### Common Interview Questions

#### 1. What is the difference between an abstract class and an interface? When would you use one over the other?

**Answer:** Abstract classes are used when classes share common functionality and state, whereas interfaces are used to define a contract for unrelated classes. Use abstract classes when you need shared code and interfaces for behavior enforcement.

***

#### 2. Can an abstract class implement an interface?

**Answer:** Yes, an abstract class can implement an interface to provide partial implementation. This is useful when some methods in the interface have common logic that can be shared across subclasses.

***

#### 3. Why can't we instantiate an abstract class?

**Answer:** Abstract classes are incomplete blueprints meant to be extended. Allowing instantiation would violate the principle of abstraction, as abstract methods lack implementation.

***

#### 4. What are the limitations of using abstract classes over interfaces?

**Answer:** Abstract classes allow single inheritance only, whereas interfaces can be implemented by multiple classes, offering more flexibility.

***

#### 5. What are default methods in Java interfaces? Why were they introduced?

**Answer:** Default methods are methods in interfaces that have a body (implementation). They were introduced in Java 8 to provide backward compatibility, allowing interfaces to evolve by adding new methods without breaking existing implementations.

**Example:**

```java
interface Animal {
    default void sound() {
        System.out.println("This is a default animal sound.");
    }
}

class Dog implements Animal {
    // No need to override sound
}
```

***

#### 6. What is the difference between abstract methods and default methods in an interface?

**Answer:** Abstract methods have no body and must be implemented by implementing classes. Default methods have a body and can be optionally overridden.

***

#### 7. What happens if a class implements two interfaces that have a default method with the same name?

**Answer:** The class must override the method to resolve the ambiguity explicitly.

**Example:**

```java
interface DogBehavior {
    default void makeSound() {
        System.out.println("Dog barks.");
    }
}

interface CatBehavior {
    default void makeSound() {
        System.out.println("Cat meows.");
    }
}

class AnimalProcessor implements DogBehavior, CatBehavior {
    @Override
    public void makeSound() {
        DogBehavior.super.makeSound();
        CatBehavior.super.makeSound();
        System.out.println("Custom behavior");
    }
}
```

***

#### 8. Why do we need default methods in Java? Couldn't we achieve the same with abstract classes?

**Answer:** Default methods allow interfaces to add new behavior without forcing all implementing classes to change. Abstract classes cannot achieve this because Java does not allow multiple inheritance of classes. Interfaces with default methods enable flexibility while avoiding the diamond problem.

**Example:**

```java
interface Animal {
    default void sound() {
        System.out.println("This is a default animal sound.");
    }
}

abstract class Mammal {
    abstract void eat();
}

class Dog extends Mammal implements Animal {
    @Override
    void eat() {
        System.out.println("Dog is eating.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // Output: Dog is eating.
        dog.sound(); // Output: This is a default animal sound.
    }
}
```

***

#### 9. Can a class implement an interface without overriding its default methods?

**Answer:** Yes, a class can implement an interface without overriding its default methods. The default implementation will be inherited. However, the class can override the method if it needs custom behavior.

**Example:**

```java
interface Animal {
    default void sound() {
        System.out.println("This is a default animal sound.");
    }
}

class Dog implements Animal {
    // No need to override sound
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.sound(); // Output: This is a default animal sound.
    }
}
```

***

#### 10. What happens if a class implements an interface with a default method and also inherits the same method from a superclass? Which one gets priority?

**Answer:** The method from the superclass takes priority over the default method in the interface. The class will inherit the superclass's method unless it explicitly overrides it.

**Example:**

```java
interface Animal {
    default void sound() {
        System.out.println("This is a default animal sound.");
    }
}

class Mammal {
    public void sound() {
        System.out.println("This is a mammal sound.");
    }
}

class Dog extends Mammal implements Animal {
    // No need to override sound
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.sound(); // Output: This is a mammal sound.
    }
}
```

***

#### 11. What happens if a class implements two interfaces that have a default method with the same name?

**Answer:** If a class implements two interfaces with the same default method, it must override the method to resolve the ambiguity explicitly.

**Example:**

```java
interface DogBehavior {
    default void makeSound() {
        System.out.println("Dog barks.");
    }
}

interface CatBehavior {
    default void makeSound() {
        System.out.println("Cat meows.");
    }
}

class AnimalProcessor implements DogBehavior, CatBehavior {
    // Resolving the conflict by overriding the method
    @Override
    public void makeSound() {
        System.out.println("Resolving conflict between DogBehavior and CatBehavior:");
        
        // Call the default method from DogBehavior
        DogBehavior.super.makeSound();
        
        // Call the default method from CatBehavior
        CatBehavior.super.makeSound();
        
        // Adding custom behavior
        System.out.println("Custom behavior: AnimalProcessor decides which sound to make.");
    }
}

public class Main {
    public static void main(String[] args) {
        AnimalProcessor processor = new AnimalProcessor();
        processor.makeSound();
    }
}
```

**Output:**

```
Resolving conflict between DogBehavior and CatBehavior:
Dog barks.
Cat meows.
Custom behavior: AnimalProcessor decides which sound to make.
```

***

#### 12. Is it possible to override a default method and make it abstract in a subclass or interface? Why or why not?

**Answer:** No, a default method cannot be overridden and made abstract. Once a default method is defined, overriding implementations must provide a concrete implementation.

**Example:**

```java
interface Animal {
    default void sound() {
        System.out.println("This is a default animal sound.");
    }
}

class Dog implements Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.sound(); // Output: Dog barks.
    }
}
```

***

#### 13. Can default methods access instance variables of the implementing class? Why or why not?

**Answer:** No, default methods cannot access instance variables of the implementing class because interfaces do not have state. Default methods are stateless and only work with parameters and their internal logic.

**Example:**

```java
interface Animal {
    default void sound() {
        System.out.println("This is a default animal sound.");
    }
}

class Dog implements Animal {
    private String name = "Buddy";
    
    public void printName() {
        System.out.println("Dog's name is " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.printName(); // Output: Dog's name is Buddy
        dog.sound();     // Output: This is a default animal sound.
    }
}
```

***

#### 14. What are some limitations of default methods in comparison to methods in abstract classes?

**Answer:**

* Default methods cannot have instance variables
* They cannot use `super` to refer to the implementing class's parent
* Abstract classes can have constructors and fields, but interfaces cannot

**Example:**

```java
// Abstract class example showcasing fields, constructors, and abstract methods
abstract class Animal {
    String name; // Instance variable
    
    // Constructor to initialize the name
    Animal(String name) {
        this.name = name;
    }
    
    // Abstract method
    abstract void sound();
    
    // Non-abstract method
    void eat() {
        System.out.println(name + " is eating.");
    }
}

// Interface example showcasing default methods and their limitations
interface Playable {
    // Default method
    default void play() {
        System.out.println("Playing with the animal.");
    }
    
    // Interfaces can only contain static final variables (constants)
    String DEFAULT_NAME = "Buddy";
}

// Dog class extends abstract class Animal and implements interface Playable
class Dog extends Animal implements Playable {
    // Constructor calling the abstract class constructor
    Dog(String name) {
        super(name);
    }
    
    // Overriding the abstract method
    @Override
    void sound() {
        System.out.println(name + " barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy");
        dog.sound(); // Output: Buddy barks.
        dog.eat();   // Output: Buddy is eating.
        dog.play();  // Output: Playing with the animal.
    }
}
```

***

### Summary

Abstraction is a powerful tool in OOP that simplifies code by focusing on what an object does rather than how it does it.

#### Key Takeaways

| Concept             | Purpose                                 | Implementation          |
| ------------------- | --------------------------------------- | ----------------------- |
| **Abstract Class**  | Blueprint with shared code              | Use `abstract` keyword  |
| **Interface**       | Contract for behavior                   | Use `interface` keyword |
| **Abstract Method** | Method without implementation           | Must be overridden      |
| **Default Method**  | Method with implementation in interface | Optional to override    |

#### Best Practices

1. **Use abstract classes** when you need to share state and behavior
2. **Use interfaces** when you need to define a contract without implementation
3. **Keep abstractions focused** - avoid adding irrelevant methods
4. **Favor composition over inheritance** when appropriate
5. **Use default methods** to evolve interfaces without breaking implementations
6. **Document your abstractions** clearly for maintainability

By using abstract classes and interfaces effectively, developers can create flexible, reusable, and maintainable code. Mastering abstraction is crucial for designing robust and scalable Java applications.

***

### Next Steps

Continue your learning journey by exploring:

* Design patterns that leverage abstraction (Template Method, Strategy, Factory)
* SOLID principles and their relationship with abstraction
* Functional interfaces and lambda expressions in Java 8+
* Best practices for designing clean abstractions
