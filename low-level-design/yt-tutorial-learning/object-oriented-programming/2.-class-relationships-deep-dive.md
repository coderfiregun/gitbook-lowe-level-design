# 2. Class relationships deep dive

## Class Relationships: A Deep Dive

> **Source:** [Original Article](https://codewitharyan.com/tech-blogs/class-relationships-a-deep-dive)

### Overview

In object-oriented programming, understanding how classes relate to each other is crucial for designing robust and maintainable software. This guide explores all the fundamental class relationships using Java, complete with real-world examples and practical code snippets.

By the end of this article, you'll understand:

* Inheritance (is-a relationship)
* Association (knows-about relationship)
* Aggregation (has-a relationship with independence)
* Composition (has-a relationship with ownership)
* Dependency (uses relationship)
* Realization (implements relationship)

***

### 1. Inheritance: The Family Tree of Classes

**Relationship Type:** "is-a"

Inheritance represents an "is-a" relationship where a subclass inherits properties and behaviors from its parent class. Think of it like a family tree—just as a Dog is an Animal, a subclass extends the functionality of its superclass.

#### Example: Animal and Dog

```java
// Parent class
class Animal {
    void eat() {
        System.out.println("Animal is eating.");
    }
}

// Subclass inheriting from Animal
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks: Woof Woof!");
    }
}

public class InheritanceDemo {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // Inherited behavior
        dog.bark(); // Specific behavior
    }
}
```

#### Key Points

* `Animal` is the parent class with a basic `eat()` method
* `Dog` extends `Animal` and adds its own `bark()` method
* The `Dog` class inherits behavior from `Animal` while adding its unique actions

***

### 2. Association: Side by Side

**Relationship Type:** "knows-about" or "uses"

Association is a general relationship where one class knows about or uses another. It's like a friendship—two entities are aware of each other, but they exist independently.

#### Example: Person and Car

```java
// A Person can have a Car
class Car {
    String model;
    
    Car(String model) {
        this.model = model;
    }
    
    void drive() {
        System.out.println("Driving a " + model);
    }
}

class Person {
    String name;
    Car car; // Association: A Person "has a" Car
    
    Person(String name, Car car) {
        this.name = name;
        this.car = car;
    }
    
    void goForDrive() {
        System.out.println(name + " is going for a drive.");
        car.drive();
    }
}

public class AssociationDemo {
    public static void main(String[] args) {
        Car car = new Car("Tesla Model 3");
        Person person = new Person("Alice", car);
        person.goForDrive();
    }
}
```

#### Key Points

* `Person` has a reference to `Car`, representing an association
* Both `Person` and `Car` exist independently
* The `Car` doesn't rely solely on the `Person` for its existence

***

### 3. Aggregation: Grouping with a Twist

**Relationship Type:** "has-a" (with independence)

Aggregation is a specialized form of association that represents a "has-a" relationship where the parts can exist independently of the whole—but they are grouped together by a container.

Think of a Team and its Players: a team has players, yet the players can exist even if the team is disbanded.

#### Example: Team and Players

```java
import java.util.ArrayList;
import java.util.List;

class Player {
    String name;
    
    Player(String name) {
        this.name = name;
    }
}

class Team {
    String teamName;
    List<Player> players = new ArrayList<>(); // Aggregation: A team "has" players
    
    Team(String teamName) {
        this.teamName = teamName;
    }
    
    void addPlayer(Player player) {
        players.add(player);
    }
    
    void showTeam() {
        System.out.println("Team " + teamName + " has players:");
        for (Player p : players) {
            System.out.println(" - " + p.name);
        }
    }
}

public class AggregationDemo {
    public static void main(String[] args) {
        Team team = new Team("Warriors");
        team.addPlayer(new Player("Stephen"));
        team.addPlayer(new Player("Klay"));
        team.showTeam();
    }
}
```

#### Key Points

* `Team` aggregates `Player` objects
* Players exist independently of the team—they can join or leave different teams
* While the Team holds and manages Player instances, the players are not solely dependent on the team

#### Association vs. Aggregation

| Aspect           | Association                       | Aggregation                      |
| ---------------- | --------------------------------- | -------------------------------- |
| **Nature**       | General relationship (friendship) | Specialized "has-a" relationship |
| **Ownership**    | No ownership implied              | Container-part relationship      |
| **Independence** | Objects simply interact           | Parts can exist independently    |
| **Example**      | Person uses Car                   | Team has Players                 |

***

### 4. Composition: Bond for Life

**Relationship Type:** "has-a" (with strong ownership)

Composition is a stronger form of aggregation with full ownership—if the whole is destroyed, the parts cannot exist independently. Think of a House and its Rooms: without the house, the rooms cease to exist.

#### Example: House and Rooms

```java
class Room {
    String name;
    
    Room(String name) {
        this.name = name;
    }
}

class House {
    // Composition: A House is composed of Rooms
    private Room livingRoom;
    private Room kitchen;
    
    House() {
        // Rooms are created and owned by the House
        livingRoom = new Room("Living Room");
        kitchen = new Room("Kitchen");
    }
    
    void showHouse() {
        System.out.println("House contains: " + livingRoom.name + " and " + kitchen.name);
    }
}

public class CompositionDemo {
    public static void main(String[] args) {
        House house = new House();
        house.showHouse();
    }
}
```

#### Key Points

* `House` creates and controls the lifecycle of `Room` objects
* The `Room` objects do not exist outside the context of the `House`
* The rooms are created and owned by the house and cannot exist independently

***

### 5. Dependency: Just a Little Connection

**Relationship Type:** "uses" (temporarily)

Dependency represents a temporary relationship where one class uses another class, typically via method parameters or local variables. It's like borrowing a tool for a short while.

#### Example: Document and Printer

```java
class Printer {
    void print(String message) {
        System.out.println("Printing: " + message);
    }
}

class Document {
    String content;
    
    Document(String content) {
        this.content = content;
    }
    
    // Dependency: Document uses Printer to print its content
    void printDocument(Printer printer) {
        printer.print(content);
    }
}

public class DependencyDemo {
    public static void main(String[] args) {
        Document doc = new Document("Hello, World!");
        Printer printer = new Printer();
        doc.printDocument(printer);
    }
}
```

#### Key Points

* `Document` doesn't store a `Printer`; it simply uses one when needed
* The relationship is transient and exists only during the method call

#### Association vs. Dependency

| Aspect       | Association                         | Dependency                            |
| ------------ | ----------------------------------- | ------------------------------------- |
| **Duration** | Long-term relationship              | Short-term, temporary                 |
| **Storage**  | Object stored as field              | Object passed as parameter            |
| **Scope**    | Available throughout class lifetime | Used only within method scope         |
| **Example**  | Person stores Car reference         | Document receives Printer temporarily |

**Association Example:**

```java
class Person {
    Car car; // Stored as field - long-term relationship
    Person(Car car) { this.car = car; }
}
```

**Dependency Example:**

```java
class Document {
    void print(Printer printer) { // Parameter - temporary relationship
        printer.print(content);
    }
}
```

***

### 6. Realization: Walking the Interface Tightrope

**Relationship Type:** "implements"

Realization represents a relationship where a class implements an interface. It's like signing a contract to provide specific behaviors.

#### Example: Payment Interface

```java
interface Payment {
    void pay();
}

class CreditCardPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("Paid using Credit Card.");
    }
}

class CashPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("Paid using Cash.");
    }
}

public class RealizationDemo {
    public static void main(String[] args) {
        Payment payment1 = new CreditCardPayment();
        Payment payment2 = new CashPayment();
        payment1.pay();
        payment2.pay();
    }
}
```

#### Key Points

* `Payment` is an interface that declares the `pay()` method
* `CreditCardPayment` and `CashPayment` implement this interface
* Each class provides its own version of `pay()`

***

### Bringing It All Together: Library Management System

Let's see how these relationships work together in a simplified library management system:

#### System Components

**Readable Interface (Realization):**

* Defines a contract with a `read()` method
* The `Book` class implements this interface

**Book and EBook (Inheritance):**

* `Book` has attributes for title and an associated `Author`
* `EBook` extends `Book` by adding a `fileFormat` attribute
* Shows specialization through inheritance

**Book and Author (Association):**

* Every book is written by an author
* Both objects can exist independently

**Library and Book (Composition):**

* A library is composed of books
* The library strongly owns its books
* Books don't exist outside the library context

**Reader and Book (Dependency):**

* A reader uses a book (to read)
* Reader does not own the book

**ReadingClub and Reader (Aggregation):**

* A reading club groups readers together
* Readers can exist independently of the club

***

### Summary

Understanding class relationships is fundamental to object-oriented design. Here's a quick reference:

| Relationship    | Type        | Symbol                     | Strength | Lifecycle                        |
| --------------- | ----------- | -------------------------- | -------- | -------------------------------- |
| **Inheritance** | is-a        | Solid line + closed arrow  | Strong   | Subclass depends on parent       |
| **Association** | knows-about | Solid line                 | Weak     | Independent                      |
| **Aggregation** | has-a       | Open diamond               | Medium   | Parts can exist independently    |
| **Composition** | has-a       | Filled diamond             | Strong   | Parts cannot exist independently |
| **Dependency**  | uses        | Dashed line                | Weak     | Temporary                        |
| **Realization** | implements  | Dashed line + closed arrow | Strong   | Class must fulfill contract      |

#### Key Takeaways

* **Inheritance** creates a parent-child relationship with code reuse
* **Association** connects objects that work together but remain independent
* **Aggregation** groups parts that can exist without the container
* **Composition** creates parts that depend entirely on the whole
* **Dependency** represents temporary usage without ownership
* **Realization** enforces interface contracts

Understanding these relationships—and how to represent them in UML diagrams—will help you design software that's both robust and easy to maintain.

***

### Next Steps

Continue your learning journey by exploring:

* UML diagram notation and best practices
* Design patterns that use these relationships
* SOLID principles in object-oriented design
* Refactoring techniques for improving class relationships
